import {
  require_react
} from "./chunk-AXJ2GJWQ.js";
import {
  __toESM
} from "./chunk-TCQZMY3T.js";

// node_modules/smart-webcomponents-react/source/modules/smart.chart.js
(() => {
  var __webpack_modules__ = {
    /***/
    2612: (
      /***/
      () => {
        Smart("smart-button", class extends Smart.ContentElement {
          static get properties() {
            return { value: { type: "string" }, name: { type: "string" }, type: { value: "button", type: "string" }, clickMode: { allowedValues: ["hover", "press", "release", "pressAndRelease"], type: "string", value: "release" } };
          }
          static get styleUrls() {
            return ["smart.button.css"];
          }
          template() {
            return `<button class="smart-button smart-unselectable" inner-h-t-m-l='[[innerHTML]]' id='button' type='[[type]]' name='[[name]]' value='[[value]]' disabled='[[disabled]]' role="presentation"></button>`;
          }
          refresh() {
          }
          static get listeners() {
            return { "button.down": "_downHandler", "button.mouseenter": "_mouseEnterHandler", "button.mouseleave": "_mouseLeaveHandler", "button.touchend": "_touchEndHandler", "button.click": "_clickHandler", "button.up": "_upHandler", up: "_upHandler", "button.focus": "_focusHandler", "button.blur": "_blurHandler" };
          }
          focus() {
            const e = this;
            e.$.button ? e.$.button.focus() : HTMLElement.prototype.focus.call(e);
          }
          blur() {
            const e = this;
            e.$.button ? e.$.button.blur() : HTMLElement.prototype.blur.call(e);
          }
          _upHandler(e) {
            const t = this;
            if (e.stopPropagation(), t.$.setAttributeValue("active", false), t.dataset.target) {
              const n = document.querySelector(t.dataset.target);
              let a = t.dataset.toggle;
              const r = "smart-window".toLowerCase();
              if (n && n.nodeName.toLowerCase() === r && "modal" === a && (a = "openModal"), "tab" === a || "pill" === a || "list" === a) {
                const e2 = this.closest(".nav, .list-group"), a2 = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]', r2 = !e2 || "UL" !== e2.nodeName && "OL" !== e2.nodeName ? e2.children(".active") : e2.querySelectorAll("li > .active");
                if (e2) {
                  const n2 = e2.querySelectorAll(a2);
                  for (let e3 = 0; e3 < n2.length; e3++)
                    n2[e3].classList.remove("primary");
                  for (let e3 = 0; e3 < r2.length; e3++)
                    r2[e3].classList.remove("active");
                  let i = t.parentNode;
                  for (; i; ) {
                    if ("LI" === i.nodeName) {
                      i.classList.add("active");
                      break;
                    }
                    i = i.parentNode;
                  }
                  t.classList.add("primary");
                }
                return n.parentNode.querySelectorAll(".active").forEach((e3) => {
                  e3.classList.remove("active"), e3.classList.add("smart-hidden");
                }), n.classList.add("active"), void n.classList.remove("smart-hidden");
              }
              a && n && !n[a] && "collapse" === a && (setTimeout(() => {
                n.classList.contains("smart-hidden") ? n.classList.remove("smart-hidden") : n.classList.add("smart-hidden");
              }), e.originalEvent.preventDefault()), a && n && !n[a] && "dropdown" === a ? (setTimeout(() => {
                n.opened = !n.opened;
              }), e.originalEvent.preventDefault()) : a && n && n[a] && (setTimeout(() => {
                n[a]();
              }, 50), e.originalEvent.preventDefault());
            }
          }
          _focusHandler() {
            this.$.setAttributeValue("focus", true), this.$.fireEvent("focus");
          }
          _blurHandler() {
            this.$.setAttributeValue("focus", false), this.$.fireEvent("blur");
          }
          _clickHandler(e) {
            const t = this;
            ("release" !== t.clickMode && "pressAndRelease" !== t.clickMode || t.readonly) && (e.preventDefault(), e.stopPropagation());
          }
          _downHandler(e) {
            const t = this;
            if (!(t.disabled || (t.hasRippleAnimation && Smart.Utilities.Animation.Ripple.animate(t, e.pageX, e.pageY), t.$.setAttributeValue("active", true), "press" !== t.clickMode && "pressAndRelease" !== t.clickMode || t.readonly))) {
              if (t.hasAttribute("smart-blazor"))
                return void t.$.dispatchEvent(new Event("click"));
              const n = "buttons" in e ? e.buttons : e.which;
              t.$.fireEvent("click", { buttons: n, clientX: e.clientX, clientY: e.clientY, pageX: e.pageX, pageY: e.pageY, screenX: e.screenX, screenY: e.screenY });
            }
          }
          _mouseEnterHandler(e) {
            const t = this;
            if (!t.readonly && (t.$button.setAttributeValue("hover", true), t.$.setAttributeValue("hover", true), "hover" === t.clickMode)) {
              const n = "buttons" in e ? e.buttons : e.which;
              if (t.hasAttribute("smart-blazor"))
                return void t.$.dispatchEvent(new Event("click"));
              t.$.fireEvent("click", { buttons: n, clientX: e.clientX, clientY: e.clientY, pageX: e.pageX, pageY: e.pageY, screenX: e.screenX, screenY: e.screenY });
            }
          }
          _touchEndHandler() {
            const e = this;
            setTimeout(function() {
              e.$button.setAttributeValue("hover", false), e.$.setAttributeValue("hover", false);
            }, 300);
          }
          _mouseLeaveHandler() {
            this.$button.setAttributeValue("hover", false), this.$.setAttributeValue("hover", false);
          }
          propertyChangedHandler(e, t, n) {
            super.propertyChangedHandler(e, t, n);
            const a = this;
            "disabled" === e ? (a._setFocusable(), a.$button && a.$button.setAttributeValue("hover", false), a.$.setAttributeValue("hover", false), a instanceof Smart.RepeatButton && a._stopRepeat()) : "unfocusable" === e && a._setFocusable();
          }
          _setFocusable() {
            const e = this, t = e.$.button ? e.$.button : e;
            if (e.disabled || e.unfocusable)
              return t.removeAttribute("tabindex"), void (t.tabIndex = -1);
            t.tabIndex = e.tabIndex > 0 ? e.tabIndex : 0;
          }
          ready() {
            const e = this;
            super.ready(), e.setAttribute("role", "button"), e._setFocusable(), e.enableShadowDOM && e.$.hiddenInput && e.appendChild(e.$.hiddenInput);
          }
        }), Smart("smart-repeat-button", class extends Smart.Button {
          static get properties() {
            return { delay: { value: 50, type: "number" }, initialDelay: { value: 150, type: "number" } };
          }
          static get listeners() {
            return { "button.down": "_startRepeat", "button.mouseenter": "_overriddenHandler", "button.mouseleave": "_overriddenHandler", "button.pointerenter": "_updateInBoundsFlag", "button.pointerleave": "_updateInBoundsFlag", "button.touchmove": "_touchmoveHandler", "document.up": "_stopRepeat" };
          }
          _clickHandler(e) {
            const t = this;
            ("release" !== t.clickMode || t.preventDefaultClick || t.readonly || t.disabled) && (e.preventDefault(), e.stopPropagation(), t.preventDefaultClick = false);
          }
          _updateInBoundsFlag(e) {
            const t = this;
            -1 !== e.type.indexOf("leave") ? (t._isPointerInBounds = false, t.$button.setAttributeValue("hover", false), t.$.setAttributeValue("hover", false)) : (t._isPointerInBounds = true, t.$button.setAttributeValue("hover", true), t.$.setAttributeValue("hover", true)), 1 !== ("buttons" in e ? e.buttons : e.which) && t._stopRepeat(e);
          }
          _startRepeat(e) {
            const t = this;
            t.setAttribute("active", ""), t._initialTimer || t.readonly || (t._initialTimer = setTimeout(function() {
              t._repeatTimer = setInterval(() => {
                if (t._isPointerInBounds) {
                  if (t.hasAttribute("smart-blazor"))
                    return t.$.dispatchEvent(new Event("click")), void (t.preventDefaultClick = true);
                  const n = "buttons" in e ? e.buttons : e.which;
                  t.$.fireEvent("click", { buttons: n, clientX: e.clientX, clientY: e.clientY, pageX: e.pageX, pageY: e.pageY, screenX: e.screenX, screenY: e.screenY }), t.preventDefaultClick = true;
                }
              }, t.delay);
            }, t.initialDelay));
          }
          _stopRepeat(e) {
            const t = this;
            t.readonly || e && ("pointercancel" === e.type || e.originalEvent && "pointercancel" === e.originalEvent.type) || (t.$.setAttributeValue("active", false), t._repeatTimer && (clearInterval(t._repeatTimer), t._repeatTimer = null), t._initialTimer && (clearTimeout(t._initialTimer), t._initialTimer = null));
          }
          _touchmoveHandler(e) {
            this.preventDefaultClick && e.cancelable && (e.preventDefault(), e.stopPropagation());
          }
          _overriddenHandler() {
          }
        }), Smart("smart-toggle-button", class extends Smart.Button {
          static get properties() {
            return { checked: { value: false, type: "boolean?" }, falseContent: { value: "", reflectToAttribute: false, type: "string" }, indeterminateContent: { value: "", reflectToAttribute: false, type: "string" }, indeterminate: { value: false, type: "boolean" }, trueContent: { value: "", reflectToAttribute: false, type: "string" }, indeterminateTemplate: { value: null, type: "any" }, trueTemplate: { value: null, type: "any" }, falseTemplate: { value: null, type: "any" }, type: { value: "toggle", type: "string", defaultReflectToAttribute: true, readonly: true } };
          }
          static get listeners() {
            return { keydown: "_keyHandler", keyup: "_keyHandler", dragstart: "_dragStartHandler", "button.click": "_buttonClickHandler", "button.mouseenter": "_buttonMouseEnterHandler", "button.mouseleave": "_buttonMouseLeaveHandler", "document.up": "_documentUpHandler" };
          }
          ready() {
            super.ready(), this._setAriaState(), this._updateGroupValue();
          }
          _setAriaState() {
            const e = this, t = e.checked;
            null !== t ? e.setAttribute("aria-pressed", t) : e.setAttribute("aria-pressed", "mixed");
          }
          _buttonClickHandler() {
          }
          _buttonMouseLeaveHandler() {
            this.removeAttribute("hover");
          }
          _buttonMouseEnterHandler() {
            const e = this;
            e.setAttribute("hover", ""), e.disabled || e.readonly || "hover" !== e.clickMode || (e._changeCheckState("pointer"), e.focus(), e._updateHidenInputNameAndValue());
          }
          _documentUpHandler(e) {
            const t = this;
            t._pressed && (t._pressed = false, t.disabled || t.readonly || "press" === t.clickMode || "pointercancel" === e.originalEvent.type || (t._changeCheckState("pointer"), t.focus(), t._updateHidenInputNameAndValue()));
          }
          _downHandler(e) {
            const t = this;
            t.disabled || t.readonly || (t.hasRippleAnimation && Smart.Utilities.Animation.Ripple.animate(t, e.pageX, e.pageY), t._pressed = true, "press" !== t.clickMode && "pressAndRelease" !== t.clickMode || (t._changeCheckState("pointer"), t.hasAttribute("smart-blazor") ? t.$.dispatchEvent(new Event("click")) : t.$.fireEvent("click"), t._updateHidenInputNameAndValue()), "press" === t.clickMode && (e.preventDefault(), e.stopPropagation()));
          }
          _dragStartHandler(e) {
            e.preventDefault();
          }
          _keyHandler(e) {
            const t = this;
            if (true !== t.disabled && !t.readonly && 32 === e.keyCode) {
              if ("keydown" === e.type)
                return void e.preventDefault();
              if ("none" === t.switchMode)
                return;
              t._changeCheckState("keyboard"), t._updateHidenInputNameAndValue();
            }
          }
          _updateGroupValue() {
            const e = this;
            if (e.dataset.target) {
              const t = document.querySelector(e.dataset.target);
              if (t) {
                const n = document.querySelectorAll('[data-target="' + e.dataset.target + '"]'), a = [];
                if (e.checked) {
                  const n2 = e.dataset.property, a2 = e.dataset.value;
                  if (n2 && void 0 !== t[n2]) {
                    let e2 = a2;
                    "true" === e2 && (e2 = true), "false" === e2 && (e2 = false), t[n2] = e2;
                  }
                }
                for (let t2 = 0; t2 < n.length; t2++) {
                  const r = n[t2];
                  r.checked && (r.name ? (a.push(r.name), e.id && r.setAttribute("data-id", e.id)) : e.id && a.push(e.id));
                }
                t.value = a.toString(), e._targetDispatchTimer && clearTimeout(e._targetDispatchTimer), e._targetDispatchTimer = setTimeout(() => {
                  t.dispatchEvent(new Event("change"));
                }, 100);
              }
            }
          }
          _changeCheckState(e) {
            const t = this;
            let n = null;
            null === t.checked ? t.checked = true : (n = t.checked, t.checked = !t.checked), t._handleTextSelection(), t.$.fireEvent("change", { value: t.checked, oldValue: n, changeType: e }), t.checked ? t.$.fireEvent("checkValue", { changeType: e }) : t.$.fireEvent("uncheckValue", { changeType: e }), t._updateGroupValue(), t._setAriaState();
          }
          _handleTextSelection() {
            const e = this;
            e.$.addClass("smart-unselectable"), e.timer && clearTimeout(e.timer), e.timer = setTimeout(() => e.$.removeClass("smart-unselectable"), 500);
          }
          propertyChangedHandler(e, t, n) {
            super.propertyChangedHandler(e, t, n);
            const a = this;
            if ("checked" === e)
              return a.$.fireEvent("change", { value: n, oldValue: t, changeType: "api" }), void a._setAriaState();
            switch (e) {
              case "trueTemplate":
                a._handleTemplate(true);
                break;
              case "falseTemplate":
                a._handleTemplate(false);
                break;
              case "indeterminateTemplate":
                a._handleTemplate();
            }
          }
          _htmlBindOnInitialization() {
            const e = this;
            e._bindContentProperty("trueContent", "smart-true-content"), e._bindContentProperty("falseContent", "smart-false-content"), e._bindContentProperty("indeterminateContent", "smart-indeterminate-content");
          }
          _bindContentProperty(e, t) {
            const n = this;
            if (!n.$[e + "Container"])
              return;
            let a = document.createElement("div");
            a.innerHTML = n.innerHTML;
            let r, i = a.getElementsByClassName(t);
            if (i.length > 0)
              for (let e2 = 0; e2 < i.length; e2++)
                r = i[e2];
            "" === n[e] && (n[e] = void 0 === r ? "" : r.outerHTML), n.$[e + "Container"].innerHTML = n[e];
          }
          _updateContentProperties() {
            const e = this;
            function t(t2) {
              e.$[t2 + "Container"] && (e[t2] = e.$[t2 + "Container"].innerHTML);
            }
            t("trueContent"), t("falseContent"), t("indeterminateContent");
          }
          _updateHidenInputValue() {
            const e = this;
            if (!e.$.hiddenInput)
              return;
            let t;
            t = null === e.checked ? "null" : false === e.checked ? "off" : e.value || "on", e.$.hiddenInput.setAttribute("value", t);
          }
          _updateHidenInputName() {
            const e = this;
            if (!e.$.hiddenInput)
              return;
            let t = false === e.checked ? "" : e.name || "";
            e.$.hiddenInput.setAttribute("name", t);
          }
          _updateHidenInputNameAndValue() {
            this._updateHidenInputName(), this._updateHidenInputValue();
          }
          _handleTemplate(e, t) {
            const n = this;
            let a, r, i;
            if (true === e ? (a = n.trueTemplate, r = n.$.trueContentContainer, i = n.trueContent) : false === e ? (a = n.falseTemplate, r = n.$.falseContentContainer, i = n.falseContent) : (a = n.indeterminateTemplate, r = n.$.indeterminateContentContainer, i = n.indeterminateContent), t && (r.innerHTML = i || ""), null === a || !a)
              return;
            if ("function" == typeof a)
              return void a(r, { value: i });
            if (!("content" in document.createElement("template")))
              return void n.error(n.localize("htmlTemplateNotSuported", { elementType: n.nodeName.toLowerCase() }));
            if (a = document.getElementById(a), null === a || !("content" in a))
              return void n.error(n.localize("invalidTemplate", { elementType: n.nodeName.toLowerCase(), property: "template" }));
            const o = a.content, l = o.childNodes.length, s = /{{\w+}}/g;
            let u, d = [];
            for (let e2 = 0; e2 < l; e2++)
              for (u = s.exec(o.childNodes[e2].innerHTML); u; )
                d.push({ childNodeIndex: e2, bindingString: u[0] }), u = s.exec(o.childNodes[e2].innerHTML);
            const c = d.length;
            let p, h, m = document.importNode(a.content, true);
            for (let e2 = 0; e2 < c; e2++) {
              p = m.childNodes[d[e2].childNodeIndex], h = d.length;
              for (let t2 = 0; t2 < h; t2++)
                p.innerHTML = p.innerHTML.replace(d[e2].bindingString, i);
            }
            r.innerHTML = "";
            for (let e2 = 0; e2 < m.childNodes.length; e2++)
              m.childNodes[e2].outerHTML && (r.innerHTML += m.childNodes[e2].outerHTML);
          }
        });
      }
    ),
    /***/
    8243: (
      /***/
      () => {
        Smart.Chart && (Smart.Chart.prototype._moduleAnnotations = true, Smart.Chart.prototype._renderAnnotation = function(t, e) {
          const i = this.seriesGroups[t], a = this.renderer;
          if (isNaN(t))
            return;
          let s = this._get([this.getXAxisDataPointOffset(e.xValue, t), e.x]), o = this._get([this.getValueAxisDataPointOffset(e.yValue, t), e.y]), n = this._get([this.getXAxisDataPointOffset(e.xValue2, t), e.x2]), r = this._get([this.getValueAxisDataPointOffset(e.yValue2, t), e.y2]);
          if (i.polar || i.spider) {
            const i2 = this.getPolarDataPointOffset(e.xValue, e.yValue, t);
            !i2 || isNaN(i2.x) || isNaN(i2.y) ? (s = e.x, o = e.y) : (s = i2.x, o = i2.y);
          }
          if (isNaN(o) || isNaN(s))
            return false;
          if ("horizontal" === i.orientation) {
            let t2 = s;
            s = o, o = t2, t2 = n, n = r, r = t2;
          }
          e.offset && (isNaN(e.offset.x) || (s += e.offset.x, n += e.offset.x), isNaN(e.offset.y) || (o += e.offset.y, r += e.offset.y));
          const l = this._get([e.width, n - s]), f = this._get([e.height, r - o]);
          let c, h;
          switch (e.type) {
            case "rect":
              c = a.rect(s, o, l, f);
              break;
            case "circle":
              c = a.rect(s, o, e.radius);
              break;
            case "line":
              c = a.rect(s, o, n, r);
              break;
            case "path":
              c = a.path(e.path);
          }
          if (c && a.attr(c, { fill: e.fillColor, stroke: e.lineColor, opacity: this._get([e.fillOpacity, e.opacity]), "stroke-opacity": this._get([e.lineOpacity, e.opacity]), "stroke-width": e.lineWidth, "stroke-dasharray": e.dashStyle || "none" }), e.text) {
            const t2 = e.text;
            let i2 = 0, n2 = 0;
            t2.offset && (isNaN(t2.offset.x) || (i2 += t2.offset.x), isNaN(t2.offset.y) || (n2 += t2.offset.y)), h = a.text(t2.value, s + i2, o + n2, NaN, NaN, t2.angle, {}, true === t2.clip, t2.horizontalAlignment || "center", t2.verticalAlignment || "center", t2.rotationPoint || "centermiddle"), a.attr(h, { fill: t2.fillColor, stroke: t2.lineColor, class: "smart-chart-annotation-text " + (t2.class || "") });
          }
          const y = ["click", "mouseenter", "mouseleave"], p = this;
          for (let t2 = 0; t2 < y.length; t2++) {
            const i2 = y[t2];
            c && this.renderer.addHandler(c, i2, function() {
              p._raiseAnnotationEvent(e, i2);
            }), h && this.renderer.addHandler(h, i2, function() {
              p._raiseAnnotationEvent(e, i2);
            });
          }
        }, Smart.Chart.prototype._raiseAnnotationEvent = function(t, e) {
          this.$.fireEvent("annotation" + e.charAt(0).toUpperCase() + e.slice(1), { annotation: t });
        });
      }
    ),
    /***/
    7177: (
      /***/
      () => {
        Smart.Chart && (Smart.Chart.prototype._moduleApi = true, Smart.Chart.prototype.getItemsCount = function(t, e) {
          const r = this.seriesGroups[t];
          if (!this._isSerieVisible(t, e))
            return 0;
          const i = this._renderData;
          return !r || !i || i.length <= t ? 0 : r.series[e] ? i[t].offsets[e].length : 0;
        }, Smart.Chart.prototype.getXAxisRect = function(t) {
          const e = this._renderData;
          if (e && !(e.length <= t) && e[t].xAxis)
            return e[t].xAxis.rect;
        }, Smart.Chart.prototype.getXAxisLabels = function(t) {
          const e = [];
          let r = this._renderData;
          if (!r || r.length <= t)
            return e;
          if (r = r[t].xAxis, !r)
            return e;
          const i = this.seriesGroups[t];
          if (i.polar || i.spider) {
            for (let t2 = 0; t2 < r.polarLabels.length; t2++) {
              const i2 = r.polarLabels[t2];
              e.push({ offset: { x: i2.x, y: i2.y }, value: i2.value });
            }
            return e;
          }
          const s = this._getXAxis(t), o = this.getXAxisRect(t), a = "top" === s.position || "right" === s.position, n = "horizontal" === i.orientation;
          for (let t2 = 0; t2 < r.data.length; t2++)
            n ? e.push({ offset: { x: o.x + (a ? 0 : o.width), y: o.y + r.data.data[t2] }, value: r.data.xvalues[t2] }) : e.push({ offset: { x: o.x + r.data.data[t2], y: o.y + (a ? o.height : 0) }, value: r.data.xvalues[t2] });
          return e;
        }, Smart.Chart.prototype.getValueAxisRect = function(t) {
          const e = this._renderData;
          if (e && !(e.length <= t) && e[t].valueAxis)
            return e[t].valueAxis.rect;
        }, Smart.Chart.prototype.getValueAxisLabels = function(t) {
          const e = [];
          let r = this._renderData;
          if (!r || r.length <= t)
            return e;
          if (r = r[t].valueAxis, !r)
            return e;
          const i = this._getValueAxis(t), s = "top" === i.position || "right" === i.position, o = this.seriesGroups[t], a = "horizontal" === o.orientation;
          if (o.polar || o.spider) {
            for (let t2 = 0; t2 < r.polarLabels.length; t2++) {
              const i2 = r.polarLabels[t2];
              e.push({ offset: { x: i2.x, y: i2.y }, value: i2.value });
            }
            return e;
          }
          for (let t2 = 0; t2 < r.items.length; t2++)
            a ? e.push({ offset: { x: r.itemOffsets[r.items[t2]].x + r.itemWidth / 2, y: r.rect.y + (s ? r.rect.height : 0) }, value: r.items[t2] }) : e.push({ offset: { x: r.rect.x + r.rect.width, y: r.itemOffsets[r.items[t2]].y + r.itemWidth / 2 }, value: r.items[t2] });
          return e;
        }, Smart.Chart.prototype.getPlotAreaRect = function() {
          return this._plotRect;
        }, Smart.Chart.prototype.getRect = function() {
          return this._rect;
        }, Smart.Chart.prototype.showToolTip = function(t, e, r, i, s) {
          const o = this.getItemCoord(t, e, r);
          isNaN(o.x) || isNaN(o.y) || this._startTooltipTimer(t, e, r, o.x, o.y, i, s);
        }, Smart.Chart.prototype.hideToolTip = function(t) {
          isNaN(t) && (t = 0);
          const e = this;
          e._cancelTooltipTimer(), setTimeout(function() {
            e._hideToolTip(0);
          }, t);
        });
      }
    ),
    /***/
    7799: (
      /***/
      () => {
        Smart("smart-chart", class extends Smart.BaseElement {
          static get properties() {
            return { animationDuration: { value: 300, type: "number" }, backgroundColor: { value: null, type: "string?" }, backgroundImage: { value: "", type: "string" }, borderLineColor: { value: null, type: "string?" }, borderLineWidth: { value: 1, type: "number" }, caption: { value: "Caption", type: "string" }, clip: { value: true, type: "boolean" }, colorScheme: { value: "scheme01", type: "string" }, columnSeriesOverlap: { value: false, type: "boolean" }, crosshairsColor: { value: null, type: "string?" }, crosshairsDashStyle: { value: "2,2", type: "string" }, crosshairsLineWidth: { value: 1, type: "number" }, dataSource: { value: [], type: "object", reflectToAttribute: false }, description: { value: "Description", type: "string" }, draw: { value: null, type: "function?" }, drawBefore: { value: null, type: "function?" }, enableAxisTextAnimation: { value: false, type: "boolean" }, enableCrosshairs: { value: false, type: "boolean" }, greyScale: { value: false, type: "boolean" }, legendLayout: { value: { flow: { value: "horizontal", allowedValues: ["horizontal", "vertical"], type: "string" }, height: { value: null, type: "number?" }, left: { value: null, type: "number?" }, top: { value: null, type: "number?" }, width: { value: null, type: "number?" } }, type: "object?" }, localization: { value: { decimalSeparator: { value: ".", type: "string" }, patterns: { value: null, type: "object?" }, thousandsSeparator: { value: "", type: "string" } }, type: "object" }, messages: { value: { en: { invalidRadiusDataField: "smart-chart: Invalid radiusDataField value at [{{index}}]", invalidSeries: "smart-chart: Invalid property: each series group must have a 'series' property which must be a valid array.", invalidSeriesGroups: "smart-chart: Invalid property: 'seriesGroups' property is required and must be a valid array.", invalidType: 'smart-chart: Invalid serie type "{{type}}".', missingAxis: "smart-chart: seriesGroup[{{index}}] is missing {{axis}} definition.", missingReference: "smart-chart: Missing reference to {{files}}.", missingType: "smart-chart: Invalid property: each series group must have a valid 'type' property." } }, type: "object", extend: true }, padding: { value: { bottom: { value: 5, type: "number" }, left: { value: 5, type: "number" }, right: { value: 5, type: "number" }, top: { value: 5, type: "number" } }, type: "object" }, renderEngine: { value: "", allowedValues: ["", "SVG", "HTML5"], type: "string" }, rightToLeft: { value: false, type: "boolean" }, seriesGroups: { value: [], type: "any", reflectToAttribute: false }, showBorderLine: { value: true, type: "boolean" }, showLegend: { value: true, type: "boolean" }, showToolTips: { value: true, type: "boolean" }, showToolTipsOnAllSeries: { value: false, type: "boolean" }, theme: { value: "light", allowedValues: ["light", "dark"], type: "string" }, titlePadding: { value: { bottom: { value: 10, type: "number" }, left: { value: 5, type: "number" }, right: { value: 5, type: "number" }, top: { value: 5, type: "number" } }, type: "object" }, toolTipBackground: { value: null, type: "string?" }, toolTipFormatFunction: { value: null, type: "function?" }, toolTipHideDelay: { value: 4e3, type: "number" }, toolTipLineColor: { value: null, type: "string?" }, toolTipShowDelay: { value: 300, type: "number" }, valueAxis: { value: { alternatingBackgroundColor: { value: "", type: "string" }, alternatingBackgroundColor2: { value: "", type: "string" }, alternatingBackgroundOpacity: { value: 1, type: "number" }, axisSize: { value: null, type: "any" }, bands: { value: null, type: "array?" }, baselineValue: { value: 0, type: "any" }, customDraw: { value: false, type: "boolean" }, flip: { value: false, type: "boolean" }, formatFunction: { value: null, type: "function?" }, formatSettings: { value: { dateFormat: { value: null, type: "string?" }, decimalPlaces: { value: null, type: "number?" }, decimalSeparator: { value: null, type: "string?" }, negativeWithBrackets: { value: false, type: "boolean" }, prefix: { value: "", type: "string" }, sufix: { value: "", type: "string" }, thousandsSeparator: { value: null, type: "string?" } }, type: "object" }, gridLines: { value: { color: { value: "", type: "string" }, custom: { value: null, type: "array?" }, dashStyle: { value: "", type: "string" }, lineWidth: { value: 1, type: "number" }, step: { value: null, type: "number?" }, unitInterval: { value: null, type: "number?" }, visible: { value: true, type: "any" } }, type: "object" }, labels: { value: { angle: { value: 0, type: "number" }, autoRotate: { value: false, type: "boolean" }, class: { value: null, type: "string?" }, custom: { value: null, type: "array?" }, formatFunction: { value: null, type: "function?" }, formatSettings: { value: { dateFormat: { value: null, type: "string?" }, decimalPlaces: { value: null, type: "number?" }, decimalSeparator: { value: null, type: "string?" }, negativeWithBrackets: { value: false, type: "boolean" }, prefix: { value: "", type: "string" }, sufix: { value: "", type: "string" }, thousandsSeparator: { value: null, type: "string?" } }, type: "object" }, horizontalAlignment: { value: "center", allowedValues: ["left", "center", "right"], type: "string" }, offset: { value: { x: { value: 0, type: "number" }, y: { value: 0, type: "number" } }, type: "object" }, rotationPoint: { value: "auto", allowedValues: ["auto", "left", "center", "right", "topleft", "topcenter", "topright", "bottomleft", "bottomcenter", "bottomright", "centermiddle"], type: "string" }, step: { value: null, type: "number?" }, unitInterval: { value: null, type: "number?" }, verticalAlignment: { value: "center", allowedValues: ["top", "center", "bottom"], type: "string" }, visible: { value: true, type: "any" } }, type: "object" }, line: { value: { color: { value: "", type: "string" }, dashStyle: { value: "", type: "string" }, lineWidth: { value: 1, type: "number" }, visible: { value: true, type: "any" } }, type: "object" }, logarithmicScale: { value: false, type: "boolean" }, logarithmicScaleBase: { value: 10, type: "number" }, maxValue: { value: NaN, type: "any" }, minValue: { value: NaN, type: "any" }, padding: { value: { bottom: { value: 0, type: "number" }, left: { value: 0, type: "number" }, right: { value: 0, type: "number" }, top: { value: 0, type: "number" } }, type: "object" }, position: { value: "left", allowedValues: ["left", "right", "top", "bottom"], type: "string" }, textRotationAngle: { value: null, type: "number?" }, textRotationPoint: { value: "auto", allowedValues: ["auto", "left", "center", "right", "topleft", "topcenter", "topright", "bottomleft", "bottomcenter", "bottomright", "centermiddle"], type: "string" }, tickMarks: { value: { color: { value: "", type: "string" }, custom: { value: null, type: "array?" }, dashStyle: { value: "", type: "string" }, lineWidth: { value: 1, type: "number" }, size: { value: 4, type: "number" }, step: { value: null, type: "number?" }, unitInterval: { value: null, type: "number?" }, visible: { value: true, type: "any" } }, type: "object" }, title: { value: { class: { value: null, type: "string?" }, horizontalAlignment: { value: "center", allowedValues: ["left", "center", "right"], type: "string" }, text: { value: "", type: "string" }, verticalAlignment: { value: "center", allowedValues: ["top", "center", "bottom"], type: "string" }, visible: { value: true, type: "boolean" } }, type: "object" }, unitInterval: { value: null, type: "number?" }, valuesOnTicks: { value: true, type: "boolean" }, visible: { value: true, type: "boolean" } }, type: "object" }, xAxis: { value: { alternatingBackgroundColor: { value: "", type: "string" }, alternatingBackgroundColor2: { value: "", type: "string" }, alternatingBackgroundOpacity: { value: 1, type: "number" }, axisSize: { value: null, type: "any" }, bands: { value: null, type: "array?" }, baseUnit: { value: null, allowedValues: ["year", "month", "day", "hour", "minute", "second", "millisecond", null], type: "string?" }, customDraw: { value: false, type: "boolean" }, dataField: { value: "", type: "string" }, dateFormat: { value: null, type: "string?" }, displayText: { value: null, type: "string?" }, flip: { value: false, type: "boolean" }, formatFunction: { value: null, type: "function?" }, formatSettings: { value: { dateFormat: { value: null, type: "string?" }, decimalPlaces: { value: null, type: "number?" }, decimalSeparator: { value: null, type: "string?" }, negativeWithBrackets: { value: false, type: "boolean" }, prefix: { value: "", type: "string" }, sufix: { value: "", type: "string" }, thousandsSeparator: { value: null, type: "string?" } }, type: "object" }, gridLines: { value: { color: { value: "", type: "string" }, custom: { value: null, type: "array?" }, dashStyle: { value: "", type: "string" }, lineWidth: { value: 1, type: "number" }, step: { value: null, type: "number?" }, unitInterval: { value: null, type: "number?" }, visible: { value: true, type: "any" } }, type: "object" }, labels: { value: { angle: { value: 0, type: "number" }, autoRotate: { value: false, type: "boolean" }, class: { value: null, type: "string?" }, custom: { value: null, type: "array?" }, formatFunction: { value: null, type: "function?" }, formatSettings: { value: { dateFormat: { value: null, type: "string?" }, decimalPlaces: { value: null, type: "number?" }, decimalSeparator: { value: null, type: "string?" }, negativeWithBrackets: { value: false, type: "boolean" }, prefix: { value: "", type: "string" }, sufix: { value: "", type: "string" }, thousandsSeparator: { value: null, type: "string?" } }, type: "object" }, horizontalAlignment: { value: "center", allowedValues: ["left", "center", "right"], type: "string" }, offset: { value: { x: { value: 0, type: "number" }, y: { value: 0, type: "number" } }, type: "object" }, rotationPoint: { value: "auto", allowedValues: ["auto", "left", "center", "right", "topleft", "topcenter", "topright", "bottomleft", "bottomcenter", "bottomright", "centermiddle"], type: "string" }, step: { value: null, type: "number?" }, unitInterval: { value: null, type: "number?" }, verticalAlignment: { value: "center", allowedValues: ["top", "center", "bottom"], type: "string" }, visible: { value: true, type: "any" } }, type: "object" }, line: { value: { color: { value: "", type: "string" }, dashStyle: { value: "", type: "string" }, lineWidth: { value: 1, type: "number" }, visible: { value: true, type: "any" } }, type: "object" }, logarithmicScale: { value: false, type: "boolean" }, logarithmicScaleBase: { value: 10, type: "number" }, maxValue: { value: NaN, type: "any" }, minValue: { value: NaN, type: "any" }, padding: { value: { bottom: { value: 0, type: "number" }, left: { value: 0, type: "number" }, right: { value: 0, type: "number" }, top: { value: 0, type: "number" } }, type: "object" }, position: { value: "bottom", allowedValues: ["bottom", "top", "left", "right"], type: "string" }, rangeSelector: { value: { backgroundColor: { value: null, type: "string?" }, backgroundImage: { value: "", type: "string" }, baseUnit: { value: null, allowedValues: ["year", "month", "day", "hour", "minute", "second", "millisecond", null], type: "string?" }, borderLineColor: { value: null, type: "string?" }, borderLineWidth: { value: null, type: "number?" }, caption: { value: "", type: "string" }, colorScheme: { value: null, type: "string?" }, columnSeriesOverlap: { value: false, type: "boolean" }, columnsGapPercent: { value: 25, type: "number" }, dataField: { value: null, type: "string?" }, description: { value: "", type: "string" }, greyScale: { value: null, type: "boolean?" }, gridLines: { value: { color: { value: "", type: "string" }, custom: { value: null, type: "array?" }, dashStyle: { value: "", type: "string" }, lineWidth: { value: 1, type: "number" }, step: { value: null, type: "number?" }, unitInterval: { value: null, type: "number?" }, visible: { value: true, type: "any" } }, type: "object" }, labels: { value: { angle: { value: 0, type: "number" }, autoRotate: { value: false, type: "boolean" }, class: { value: null, type: "string?" }, custom: { value: null, type: "array?" }, formatFunction: { value: null, type: "function?" }, formatSettings: { value: { dateFormat: { value: null, type: "string?" }, decimalPlaces: { value: null, type: "number?" }, decimalSeparator: { value: null, type: "string?" }, negativeWithBrackets: { value: false, type: "boolean" }, prefix: { value: "", type: "string" }, sufix: { value: "", type: "string" }, thousandsSeparator: { value: null, type: "string?" } }, type: "object" }, horizontalAlignment: { value: "center", allowedValues: ["left", "center", "right"], type: "string" }, offset: { value: { x: { value: 0, type: "number" }, y: { value: 0, type: "number" } }, type: "object" }, rotationPoint: { value: "auto", allowedValues: ["auto", "left", "center", "right", "topleft", "topcenter", "topright", "bottomleft", "bottomcenter", "bottomright", "centermiddle"], type: "string" }, step: { value: null, type: "number?" }, unitInterval: { value: null, type: "number?" }, verticalAlignment: { value: "center", allowedValues: ["top", "center", "bottom"], type: "string" }, visible: { value: true, type: "any" } }, type: "object" }, maxValue: { value: NaN, type: "any" }, minValue: { value: NaN, type: "any" }, padding: { value: { bottom: { value: 0, type: "number" }, left: { value: 0, type: "number" }, right: { value: 0, type: "number" }, top: { value: 0, type: "number" } }, type: "object" }, position: { value: null, allowedValues: ["bottom", "top", "left", "right"], type: "string?" }, renderTo: { value: null, type: "any" }, rightToLeft: { value: null, type: "boolean?" }, seriesGapPercent: { value: 10, type: "number" }, seriesGroups: { value: null, type: "array?" }, serieType: { value: "area", type: "string" }, showBorderLine: { value: null, type: "boolean?" }, size: { value: null, type: "number?" }, skipOverlappingPoints: { value: true, type: "boolean" }, titlePadding: { value: { bottom: { value: 10, type: "number" }, left: { value: 5, type: "number" }, right: { value: 5, type: "number" }, top: { value: 5, type: "number" } }, type: "object" }, unitInterval: { value: null, type: "number?" }, valueAxis: { value: { alternatingBackgroundColor: { value: "", type: "string" }, alternatingBackgroundColor2: { value: "", type: "string" }, alternatingBackgroundOpacity: { value: 1, type: "number" }, axisSize: { value: null, type: "any" }, bands: { value: null, type: "array?" }, baselineValue: { value: 0, type: "any" }, customDraw: { value: false, type: "boolean" }, flip: { value: false, type: "boolean" }, formatFunction: { value: null, type: "function?" }, formatSettings: { value: { dateFormat: { value: null, type: "string?" }, decimalPlaces: { value: null, type: "number?" }, decimalSeparator: { value: null, type: "string?" }, negativeWithBrackets: { value: false, type: "boolean" }, prefix: { value: "", type: "string" }, sufix: { value: "", type: "string" }, thousandsSeparator: { value: null, type: "string?" } }, type: "object" }, gridLines: { value: { color: { value: "", type: "string" }, custom: { value: null, type: "array?" }, dashStyle: { value: "", type: "string" }, lineWidth: { value: 1, type: "number" }, step: { value: null, type: "number?" }, unitInterval: { value: null, type: "number?" }, visible: { value: true, type: "any" } }, type: "object" }, labels: { value: { angle: { value: 0, type: "number" }, autoRotate: { value: false, type: "boolean" }, class: { value: null, type: "string?" }, custom: { value: null, type: "array?" }, formatFunction: { value: null, type: "function?" }, formatSettings: { value: { dateFormat: { value: null, type: "string?" }, decimalPlaces: { value: null, type: "number?" }, decimalSeparator: { value: null, type: "string?" }, negativeWithBrackets: { value: false, type: "boolean" }, prefix: { value: "", type: "string" }, sufix: { value: "", type: "string" }, thousandsSeparator: { value: null, type: "string?" } }, type: "object" }, horizontalAlignment: { value: "center", allowedValues: ["left", "center", "right"], type: "string" }, offset: { value: { x: { value: 0, type: "number" }, y: { value: 0, type: "number" } }, type: "object" }, rotationPoint: { value: "auto", allowedValues: ["auto", "left", "center", "right", "topleft", "topcenter", "topright", "bottomleft", "bottomcenter", "bottomright", "centermiddle"], type: "string" }, step: { value: null, type: "number?" }, unitInterval: { value: null, type: "number?" }, verticalAlignment: { value: "center", allowedValues: ["top", "center", "bottom"], type: "string" }, visible: { value: true, type: "any" } }, type: "object" }, line: { value: { color: { value: "", type: "string" }, dashStyle: { value: "", type: "string" }, lineWidth: { value: 1, type: "number" }, visible: { value: true, type: "any" } }, type: "object" }, logarithmicScale: { value: false, type: "boolean" }, logarithmicScaleBase: { value: 10, type: "number" }, maxValue: { value: NaN, type: "any" }, minValue: { value: NaN, type: "any" }, padding: { value: { bottom: { value: 0, type: "number" }, left: { value: 0, type: "number" }, right: { value: 0, type: "number" }, top: { value: 0, type: "number" } }, type: "object" }, position: { value: "left", allowedValues: ["left", "right", "top", "bottom"], type: "string" }, textRotationAngle: { value: null, type: "number?" }, textRotationPoint: { value: "auto", allowedValues: ["auto", "left", "center", "right", "topleft", "topcenter", "topright", "bottomleft", "bottomcenter", "bottomright", "centermiddle"], type: "string" }, tickMarks: { value: { color: { value: "", type: "string" }, custom: { value: null, type: "array?" }, dashStyle: { value: "", type: "string" }, lineWidth: { value: 1, type: "number" }, size: { value: 4, type: "number" }, step: { value: null, type: "number?" }, unitInterval: { value: null, type: "number?" }, visible: { value: true, type: "any" } }, type: "object" }, title: { value: { class: { value: null, type: "string?" }, horizontalAlignment: { value: "center", allowedValues: ["left", "center", "right"], type: "string" }, text: { value: "", type: "string" }, verticalAlignment: { value: "center", allowedValues: ["top", "center", "bottom"], type: "string" }, visible: { value: true, type: "boolean" } }, type: "object" }, unitInterval: { value: null, type: "number?" }, valuesOnTicks: { value: true, type: "boolean" }, visible: { value: false, type: "boolean" } }, type: "object" }, visible: { value: false, type: "boolean" } }, type: "object" }, textRotationAngle: { value: null, type: "number?" }, textRotationPoint: { value: "auto", allowedValues: ["auto", "left", "center", "right", "topleft", "topcenter", "topright", "bottomleft", "bottomcenter", "bottomright", "centermiddle"], type: "string" }, tickMarks: { value: { color: { value: "", type: "string" }, custom: { value: null, type: "array?" }, dashStyle: { value: "", type: "string" }, lineWidth: { value: 1, type: "number" }, size: { value: 4, type: "number" }, step: { value: null, type: "number?" }, unitInterval: { value: null, type: "number?" }, visible: { value: true, type: "any" } }, type: "object" }, title: { value: { class: { value: null, type: "string?" }, horizontalAlignment: { value: "center", allowedValues: ["left", "center", "right"], type: "string" }, text: { value: "", type: "string" }, verticalAlignment: { value: "center", allowedValues: ["top", "center", "bottom"], type: "string" }, visible: { value: true, type: "boolean" } }, type: "object" }, toolTipFormatFunction: { value: null, type: "function?" }, toolTipFormatSettings: { value: { dateFormat: { value: null, type: "string?" }, decimalPlaces: { value: null, type: "number?" }, decimalSeparator: { value: null, type: "string?" }, negativeWithBrackets: { value: false, type: "boolean" }, prefix: { value: "", type: "string" }, sufix: { value: "", type: "string" }, thousandsSeparator: { value: null, type: "string?" } }, type: "object" }, type: { value: "auto", allowedValues: ["auto", "date", "basic", "linear"], type: "string" }, unitInterval: { value: null, type: "number?" }, valuesOnTicks: { value: true, type: "boolean" }, visible: { value: true, type: "boolean" } }, type: "object", reflectToAttribute: false } };
          }
          get _legendLayout() {
            const e = this.legendLayout;
            return null !== e.height || null !== e.left || null !== e.top || null !== e.width || "vertical" === e.flow;
          }
          _getFormatSettings(e, t) {
            if (!e)
              return null;
            const i = e[t || "formatSettings"];
            return i && (i.dateFormat || null !== i.decimalPlaces || i.decimalSeparator || i.negativeWithBrackets || i.prefix || i.sufix || i.thousandsSeparator) ? i : null;
          }
          static get listeners() {
            return { click: "_clickHandler", down: "_downMoveHandler", mouseleave: "_mouseleaveHandler", move: "_moveHandler", resize: "_resizeHandler", "document.move": "_downMoveHandler", "document.up": "_documentUpHandler" };
          }
          static get requires() {
            return { "Smart.Utilities.Draw": "smart.draw.js" };
          }
          static get styleUrls() {
            return ["smart.chart.css"];
          }
          template() {
            return '<div role="presentation"></div>';
          }
          ready() {
            super.ready(), this.checkLicense();
          }
          render() {
            const e = this;
            e._observeSeriesGroups(), e._isTouchDevice = Smart.Utilities.Core.isMobile, e._setDefaults(), e._createColorsCache(), e.refresh(), e._setAriaProperties(), super.render();
          }
          attached() {
            const e = this;
            super.attached(), e.isCompleted && !e._isRangeSelectorInstance && Object.values(e._rangeSelectorInstances).forEach((e2) => {
              e2.parentDiv.parentDiv.appendChild(e2.parentDiv);
            });
          }
          detached() {
            const e = this;
            super.detached(), e._isRangeSelectorInstance || (e._ttEl && e._ttEl.box && e._ttEl.box.remove(), delete e._ttEl, Object.values(e._rangeSelectorInstances).forEach((e2) => {
              e2.parentDiv.remove();
            }));
          }
          _setAriaProperties() {
            const e = this;
            if (e._isRangeSelectorInstance)
              return;
            const t = e.xAxis, i = e.valueAxis, r = e.seriesGroups;
            let s = e.$.content.children[1], a = "", l = true;
            function n(e2, t2) {
              e2 && (e2.title && e2.title.text || e2.description || e2.dataField) && (a += '; "', e2.title && e2.title.text ? a += e2.title.text : a += e2.description || e2.dataField, a += '" on the ' + t2, isNaN(e2.minValue) || (a += " from " + e2.minValue), isNaN(e2.maxValue) || (a += " up to " + e2.maxValue));
            }
            e.setAttribute("role", "figure"), s || (s = document.createElement("div"), s.id = e.id + "DescriptionContainer", s.className = "smart-hidden", e.$.content.appendChild(s)), e.setAttribute("aria-labelledby", e.id + "TitleText"), e.setAttribute("aria-describedby", e.id + "TitleDescription " + s.id), a += "This chart displays:", n(t, "x-axis"), n(i, "y-axis");
            for (let e2 = 0; e2 < r.length; e2++) {
              const t2 = r[e2];
              if (n(t2.valueAxis, "y-axis"), t2.series) {
                l = l && "horizontal" === t2.orientation;
                for (let i2 = 0; i2 < t2.series.length; i2++) {
                  const r2 = t2.series[i2];
                  0 === i2 && (a += 0 === e2 ? " for " : "; "), a += '"' + (r2.displayText || r2.dataField) + '"', i2 !== t2.series.length - 1 && (a += ", ");
                }
              }
            }
            a = a.replace(":;", ":"), a = a.replace(/<.+?>/g, ""), l && (a = a.replace(/x-axis/g, "@@@"), a = a.replace(/y-axis/g, "x-axis"), a = a.replace(/@@@/g, "y-axis")), e.description && (a = "; " + a), s.innerHTML = a;
          }
          _observeSeriesGroups() {
            const e = this;
            function t(t2) {
              e.context !== e && t2.newValue !== t2.oldValue && e.update();
            }
            if (e._validateSeriesGroups(), Array.isArray(e.seriesGroups)) {
              e.seriesGroups = new Smart.ObservableArray(e.seriesGroups), e.seriesGroups.canNotify = true;
              for (let i = 0; i < e.seriesGroups.length; i++)
                Array.isArray(e.seriesGroups[i].series) && (e.seriesGroups[i].series = new Smart.ObservableArray(e.seriesGroups[i].series), e.seriesGroups[i].series.canNotify = true, e.seriesGroups[i].series.notify(t));
              e.seriesGroups.notify(t);
            }
          }
          _downMoveHandler(e) {
            const t = this;
            let i = e.originalEvent.target;
            t.shadowRoot && i === t && (i = e.originalEvent.composedPath()[0]);
            const r = i.closest(".smart-chart-range-selector");
            if (!r)
              return;
            const s = r.firstElementChild, a = s.parentChart;
            t !== s && t !== a || a["_onSliderMouse" + e.type.slice(0, 1).toUpperCase() + e.type.slice(1)](e);
          }
          _documentUpHandler(e) {
            const t = this;
            t._draggingRangeSelector && t._onSliderMouseUp(e);
          }
          _setDefaults() {
            const e = this;
            e.axisPadding = 5, e.enableEvents = true, e.enableSampling = true, e._itemsToggleState = [], e._isToggleRefresh = false, e._isSelectorRefresh = false, e._sliders = [], e._selectorRange = [], e._rangeSelectorInstances = {}, e._resizeState = {}, e._isRangeSelectorInstance = e._isRangeSelectorInstance || false, e._renderData = {}, e._smartPlot = null, e._animTickInt = 50, e._seriesTypes = ["line", "stackedline", "stackedline100", "spline", "stackedspline", "stackedspline100", "stepline", "stackedstepline", "stackedstepline100", "area", "stackedarea", "stackedarea100", "splinearea", "stackedsplinearea", "stackedsplinearea100", "steparea", "stackedsteparea", "stackedsteparea100", "rangearea", "splinerangearea", "steprangearea", "column", "stackedcolumn", "stackedcolumn100", "rangecolumn", "scatter", "stackedscatter", "stackedscatter100", "bubble", "stackedbubble", "stackedbubble100", "pie", "donut", "candlestick", "ohlc", "waterfall", "stackedwaterfall"], e.colorSchemes = [{ name: "scheme01", colors: ["#307DD7", "#AA4643", "#89A54E", "#71588F", "#4198AF"] }, { name: "scheme02", colors: ["#7FD13B", "#EA157A", "#FEB80A", "#00ADDC", "#738AC8"] }, { name: "scheme03", colors: ["#E8601A", "#FF9639", "#F5BD6A", "#599994", "#115D6E"] }, { name: "scheme04", colors: ["#D02841", "#FF7C41", "#FFC051", "#5B5F4D", "#364651"] }, { name: "scheme05", colors: ["#25A0DA", "#309B46", "#8EBC00", "#FF7515", "#FFAE00"] }, { name: "scheme06", colors: ["#0A3A4A", "#196674", "#33A6B2", "#9AC836", "#D0E64B"] }, { name: "scheme07", colors: ["#CC6B32", "#FFAB48", "#FFE7AD", "#A7C9AE", "#888A63"] }, { name: "scheme08", colors: ["#3F3943", "#01A2A6", "#29D9C2", "#BDF271", "#FFFFA6"] }, { name: "scheme09", colors: ["#1B2B32", "#37646F", "#A3ABAF", "#E1E7E8", "#B22E2F"] }, { name: "scheme10", colors: ["#5A4B53", "#9C3C58", "#DE2B5B", "#D86A41", "#D2A825"] }, { name: "scheme11", colors: ["#993144", "#FFA257", "#CCA56A", "#ADA072", "#949681"] }, { name: "scheme12", colors: ["#105B63", "#EEEAC5", "#FFD34E", "#DB9E36", "#BD4932"] }, { name: "scheme13", colors: ["#BBEBBC", "#F0EE94", "#F5C465", "#FA7642", "#FF1E54"] }, { name: "scheme14", colors: ["#60573E", "#F2EEAC", "#BFA575", "#A63841", "#BFB8A3"] }, { name: "scheme15", colors: ["#444546", "#FFBB6E", "#F28D00", "#D94F00", "#7F203B"] }, { name: "scheme16", colors: ["#583C39", "#674E49", "#948658", "#F0E99A", "#564E49"] }, { name: "scheme17", colors: ["#142D58", "#447F6E", "#E1B65B", "#C8782A", "#9E3E17"] }, { name: "scheme18", colors: ["#4D2B1F", "#635D61", "#7992A2", "#97BFD5", "#BFDCF5"] }, { name: "scheme19", colors: ["#844341", "#D5CC92", "#BBA146", "#897B26", "#55591C"] }, { name: "scheme20", colors: ["#56626B", "#6C9380", "#C0CA55", "#F07C6C", "#AD5472"] }, { name: "scheme21", colors: ["#96003A", "#FF7347", "#FFBC7B", "#FF4154", "#642223"] }, { name: "scheme22", colors: ["#5D7359", "#E0D697", "#D6AA5C", "#8C5430", "#661C0E"] }, { name: "scheme23", colors: ["#16193B", "#35478C", "#4E7AC7", "#7FB2F0", "#ADD5F7"] }, { name: "scheme24", colors: ["#7B1A25", "#BF5322", "#9DA860", "#CEA457", "#B67818"] }, { name: "scheme25", colors: ["#0081DA", "#3AAFFF", "#99C900", "#FFEB3D", "#309B46"] }, { name: "scheme26", colors: ["#0069A5", "#0098EE", "#7BD2F6", "#FFB800", "#FF6800"] }, { name: "scheme27", colors: ["#FF6800", "#A0A700", "#FF8D00", "#678900", "#0069A5"] }, { name: "scheme28", colors: ["#3A43BA", "#281E5D", "#48AAAD", "#0492C2", "#1E456E", "#59788D", "#52B2C0", "#82EDFD"] }, { name: "scheme29", colors: ["#003F5C", "#BC5090", "#58508D", "#FF6361", "#FFA600"] }, { name: "scheme30", colors: ["#16736F", "#A2D56A", "#1C515C", "#62B773", "#EEEF63", "#1F313F", "#309577"] }, { name: "scheme31", colors: ["#74CC66", "#191A4D", "#2D867A", "#EEE3CD", "#224D19", "#0D261B", "#5771C7", "#B6D7E7", "#206052", "#6B5724", "#C3AF4B", "#603620", "#536722", "#B6E7B9", "#34819D", "#94ACDB"] }, { name: "scheme32", colors: ["#87C5FF", "#5B5B60", "#9BE076", "#F7A384", "#7479D3", "#F13A80", "#E4D388", "#2BC6B2", "#F45B14"] }];
          }
          _clickHandler(e) {
            const t = this;
            if (t.disabled || t._isRangeSelectorInstance)
              return;
            let i = e.pageX || e.clientX || e.screenX, r = e.pageY || e.clientY || e.screenY;
            const s = t.getBoundingClientRect();
            t._isTouchDevice && (i = e.pageX, r = e.pageY), i -= s.left, r -= s.top, t._mouseX = i, t._mouseY = r, !isNaN(t._lastClickTs) && (/* @__PURE__ */ new Date()).valueOf() - t._lastClickTs < 100 || (this._hostClickTimer = setTimeout(function() {
              if (t._isTouchDevice || (t._cancelTooltipTimer(), t._hideToolTip(), t._unselect()), t._pointMarker && t._pointMarker.element) {
                const i2 = t.seriesGroups[t._pointMarker.gidx], r2 = i2.series[t._pointMarker.sidx];
                e.stopImmediatePropagation(), t._raiseItemEvent("click", i2, r2, t._pointMarker.iidx);
              }
            }, 100), "HTML5" === t.renderEngine && t._canvasClickHandler(i, r));
          }
          _canvasClickHandler(e, t) {
            const i = this, r = i.renderer._elements;
            let s;
            for (let i2 in r)
              if (Object.prototype.hasOwnProperty.call(r, i2) && "0" !== i2) {
                const a = r[i2];
                if (t > a.y && t < a.y + a.height && e > a.x && e < a.x + a.width) {
                  s = a;
                  break;
                }
              }
            if (s && s.purpose && "legend-toggle" === s.purpose) {
              const e2 = s.data;
              i._toggleSerie(e2.groupIndex, e2.seriesIndex, e2.itemIndex);
            }
          }
          _mouseleaveHandler() {
            const e = this;
            if (e.disabled || e._isRangeSelectorInstance)
              return;
            const t = e._mouseX, i = e._mouseY, r = e._plotRect;
            r && t >= r.x && t <= r.x + r.width && i >= r.y && i <= r.y + r.height || (e._cancelTooltipTimer(), e._hideToolTip(0), e._unselect());
          }
          _moveHandler(e) {
            const t = this;
            if (t.disabled)
              return;
            if (t._isRangeSelectorInstance) {
              const i2 = t.parentChart;
              null === i2.xAxis.rangeSelector.renderTo && (i2._unselect(), i2._hideToolTip()), "touchmove" === e.originalEvent.type && e.originalEvent.preventDefault();
            } else
              t.style.cursor = "default";
            let i = e.pageX || e.clientX || e.screenX, r = e.pageY || e.clientY || e.screenY;
            const s = t.getBoundingClientRect();
            t._isTouchDevice && (i = e.pageX, r = e.pageY), i -= s.left, r -= s.top, t.onmousemove(i, r);
          }
          _resizeHandler() {
            const e = this, t = e.animation;
            e._isRangeSelectorInstance || (e.animation = "none", e.refresh(), e.animation = t);
          }
          propertyChangedHandler(e, t, i) {
            const r = this;
            switch (e) {
              case "animation":
              case "theme":
                r._ttEl && r._ttEl.box.setAttribute(e, i);
                break;
              case "rightToLeft":
                if (!r._ttEl || !r._ttEl.box)
                  break;
                i ? r._ttEl.box.setAttribute("right-to-left", i) : r._ttEl.box.removeAttribute("right-to-left");
                break;
              case "seriesGroups":
                r._observeSeriesGroups();
                break;
              case "xAxis_rangeSelector_renderTo":
                if (null === i) {
                  const e2 = t.getElementsByClassName("smart-chart-range-selector")[0];
                  e2.parentElement.removeChild(e2);
                }
            }
            this.refresh();
          }
          _initRenderer() {
            const e = this;
            e._draw = new Smart.Utilities.Draw(e.$.content, e.renderEngine), e.renderer = e._draw.renderer, e._smartPlot || (e._smartPlot = new Smart.Utilities.Plot(e.renderer)), e.$.content.firstElementChild.setAttribute("role", "presentation");
          }
          _internalRefresh() {
            const e = this;
            if (!(e.offsetWidth || e.offsetHeight || e.getClientRects().length))
              return;
            e._stopAnimations(), e.renderer && (e._isToggleRefresh || e._isUpdate) || (e._hideToolTip(0), e.$.content.innerHTML = "", e._initRenderer());
            const t = e.renderer;
            if (!t)
              return;
            const i = t.getRect();
            e._render({ x: 1, y: 1, width: i.width, height: i.height }), this.$.fireEvent("refreshBegin", { instance: this }), t instanceof Smart.Utilities.HTML5Renderer && t.refresh(), e._isUpdate = false, this.$.fireEvent("refreshEnd", { instance: this });
          }
          saveAsPNG(e) {
            return this._saveAsImage("png", e);
          }
          saveAsJPEG(e) {
            return this._saveAsImage("jpeg", e);
          }
          saveAsPDF(e, t) {
            return this._saveAsImage("pdf", e, t);
          }
          print() {
            return this._saveAsImage("print");
          }
          _saveAsImage(e, t, i) {
            const r = this;
            return r._draw._widgetToImage(r, e, t, r._hasRangeSelector ? r._selectorSaveAsImageCallback : void 0, i);
          }
          _selectorSaveAsImageCallback(e, t) {
            let i = e;
            for (let e2 = 0; e2 < i.seriesGroups.length; e2++) {
              let r = i._getXAxis(e2);
              if (!r || !r.rangeSelector || !r.rangeSelector.visible || r.rangeSelector.renderTo)
                continue;
              let s = i._rangeSelectorInstances[e2];
              if (!s)
                continue;
              let a = s.renderer.getRect(), l = s.renderer.getContainer().getElementsByTagName("canvas")[0].getContext("2d"), n = i._sliders[e2], o = "horizontal" === i.seriesGroups[e2].orientation, h = o ? "height" : "width", d = o ? "width" : "height", u = o ? "y" : "x", g = o ? "x" : "y", f = {};
              f[u] = n.startOffset + n.rect[u], f[g] = n.rect[g], f[h] = n.endOffset - n.startOffset, f[d] = n.rect[d];
              let p = r.rangeSelector.colorSelectedRange || "blue", c = r.rangeSelector.colorRangeLine || "grey", m = [];
              m.push(s.renderer.rect(f.x, f.y, f.width, f.height, { fill: p, opacity: 0.1 }));
              const y = i.renderer;
              o ? (m.push(s.renderer.line(y._ptrnd(n.rect.x + n.rect.width), y._ptrnd(n.rect.y), y._ptrnd(n.rect.x + n.rect.width), y._ptrnd(f.y), { stroke: c, opacity: 0.5 })), m.push(s.renderer.line(y._ptrnd(n.rect.x + n.rect.width), y._ptrnd(f.y + f.height), y._ptrnd(n.rect.x + n.rect.width), y._ptrnd(n.rect.y + n.rect.height), { stroke: c, opacity: 0.5 })), m.push(s.renderer.line(y._ptrnd(n.rect.x), y._ptrnd(f.y), y._ptrnd(n.rect.x + n.rect.width), y._ptrnd(f.y), { stroke: c, opacity: 0.5 })), m.push(s.renderer.line(y._ptrnd(n.rect.x), y._ptrnd(f.y + f.height), y._ptrnd(n.rect.x + n.rect.width), y._ptrnd(f.y + f.height), { stroke: c, opacity: 0.5 }))) : (m.push(s.renderer.line(y._ptrnd(n.rect.x), y._ptrnd(n.rect.y), y._ptrnd(f.x), y._ptrnd(n.rect.y), { stroke: c, opacity: 0.5 })), m.push(s.renderer.line(y._ptrnd(f.x + f.width), y._ptrnd(n.rect.y), y._ptrnd(n.rect.x + n.rect.width), y._ptrnd(n.rect.y), { stroke: c, opacity: 0.5 })), m.push(s.renderer.line(y._ptrnd(f.x), y._ptrnd(n.rect.y), y._ptrnd(f.x), y._ptrnd(n.rect.y + n.rect.height), { stroke: c, opacity: 0.5 })), m.push(s.renderer.line(y._ptrnd(f.x + f.width), y._ptrnd(n.rect.y), y._ptrnd(f.x + f.width), y._ptrnd(n.rect.y + n.rect.height), { stroke: c, opacity: 0.5 }))), s.renderer.refresh();
              let _ = l.getImageData(a.x, a.y, a.width, a.height);
              const x = t.getContext("2d"), v = i.getBoundingClientRect(), b = s.getBoundingClientRect();
              x.putImageData(_, b.left - v.left, b.top - v.top, 1, 1, a.width, a.height);
              for (let e3 = 0; e3 < m.length; e3++)
                s.renderer.removeElement(m[e3]);
              s.renderer.refresh();
            }
            return true;
          }
          refresh() {
            this._internalRefresh(), this._setAriaProperties();
          }
          update() {
            this._isUpdate = true, this._internalRefresh();
          }
          clear() {
            const e = this;
            e.caption = "", e.description = "", e.refresh();
          }
          _validateSeriesGroups() {
            const e = this;
            Array.isArray(this.seriesGroups) || e.seriesGroups instanceof Smart.ObservableArray || e.error(e.localize("invalidSeriesGroups"));
            for (let t = 0; t < this.seriesGroups.length; t++) {
              const i = this.seriesGroups[t];
              i.type || e.error(e.localize("missingType")), Array.isArray(i.series) || i.series instanceof Smart.ObservableArray || e.error(e.localize("invalidSeries"));
            }
          }
          _render(e) {
            var t = this, i = t.renderer;
            t._colorsCache.clear(), !t._isToggleRefresh && t._isUpdate && t._renderData && t._renderDataClone(), t._renderData = [], i.clear(), t._unselect(), t._hideToolTip(0);
            var r = t.backgroundImage;
            t.style.backgroundImage = null == r || "" === r ? "" : -1 !== r.indexOf("(") ? r : 'url("' + r + '")', t._rect = e;
            var s = t.padding || { left: 5, top: 5, right: 5, bottom: 5 }, a = i.createClipRect(e), l = i.beginGroup();
            i.setClip(l, a);
            var n = i.rect(e.x, e.y, e.width - 2, e.height - 2);
            if (null == r || "" === r ? i.attr(n, { fill: t.backgroundColor || t._getThemeColor("background") }) : i.attr(n, { fill: "transparent" }), false !== t.showBorderLine) {
              var o = this.borderLineWidth;
              (isNaN(o) || o < 0 || o > 10) && (o = 1), i.attr(n, { "stroke-width": o, stroke: t.borderLineColor || t._getThemeColor("line") });
            }
            "function" == typeof t.drawBefore && t.drawBefore(i, e);
            var h = { x: s.left, y: s.top, width: e.width - s.left - s.right, height: e.height - s.top - s.bottom };
            t._paddedRect = h;
            var d, u = t.titlePadding || { left: 2, top: 2, right: 2, bottom: 2 };
            t.caption && t.caption.length > 0 && (d = i.measureText(t.caption, 0, { class: "smart-chart-title-text" }), i.text(t.caption, h.x + u.left, h.y + u.top, h.width - (u.left + u.right), d.height, 0, { class: "smart-chart-title-text" }, true, "center", "center").id = t.id + "TitleText", h.y += d.height, h.height -= d.height), t.description && t.description.length > 0 && (d = i.measureText(t.description, 0, { class: "smart-chart-title-description" }), i.text(t.description, h.x + u.left, h.y + u.top, h.width - (u.left + u.right), d.height, 0, { class: "smart-chart-title-description" }, true, "center", "center").id = t.id + "TitleDescription", h.y += d.height, h.height -= d.height), (t.caption || t.description) && (h.y += u.bottom + u.top, h.height -= u.bottom + u.top);
            var g = { x: h.x, y: h.y, width: h.width, height: h.height };
            t._plotRect = g, t._buildStats(g);
            var f, p = t._isPieOnlySeries(), c = t.seriesGroups, m = { xAxis: {}, valueAxis: {} };
            for (let e2 = 0; e2 < c.length && !p; e2++) {
              if ("pie" === c[e2].type || "donut" === c[e2].type)
                continue;
              var y = t._getXAxis(e2);
              y || t.error(t.localize("missingAxis", { index: e2, axis: "xAxis" }));
              let i2 = y === t._getXAxis() ? -1 : e2;
              m.xAxis[i2] = 0;
            }
            var _ = t.axisPadding;
            isNaN(_) && (_ = 5);
            var x = { left: 0, right: 0, leftCount: 0, rightCount: 0 }, v = [];
            for (let e2 = 0; e2 < c.length; e2++) {
              const i2 = c[e2];
              if ("pie" === i2.type || "donut" === i2.type || true === i2.spider || true === i2.polar) {
                v.push({ width: 0, position: 0, xRel: 0 });
                continue;
              }
              f = "horizontal" === i2.orientation;
              let r2 = t._getXAxis(e2), s2 = r2 === t._getXAxis() ? -1 : e2;
              var b = t._getValueAxis(e2), N = b === t._getValueAxis() ? -1 : e2, M = f ? r2.axisSize : b.axisSize, A = { x: 0, y: g.y, width: g.width, height: g.height }, w = f ? t._getXAxis(e2).position : b.position;
              M && "auto" !== M || (f ? (M = this._renderXAxis(e2, A, true, g).width, 1 == (1 & m.xAxis[s2]) ? M = 0 : M > 0 && (m.xAxis[s2] |= 1)) : (M = t._renderValueAxis(e2, A, true, g).width, 1 == (1 & m.valueAxis[N]) ? M = 0 : M > 0 && (m.valueAxis[N] |= 1))), "left" !== w && true === t.rightToLeft && (w = "right"), "right" !== w && (w = "left"), x[w + "Count"] > 0 && x[w] > 0 && M > 0 && (x[w] += _), v.push({ width: M, position: w, xRel: x[w] }), x[w] += M, x[w + "Count"]++;
            }
            var S = Math.max(1, Math.max(e.width, e.height)), C = { top: 0, bottom: 0, topCount: 0, bottomCount: 0 }, k = [];
            for (let e2 = 0; e2 < c.length; e2++) {
              const i2 = c[e2];
              if ("pie" === i2.type || "donut" === i2.type || true === i2.spider || true === i2.polar) {
                k.push({ height: 0, position: 0, yRel: 0 });
                continue;
              }
              f = "horizontal" === i2.orientation;
              let r2 = this._getValueAxis(e2), s2 = r2 === t._getValueAxis() ? -1 : e2, a2 = t._getXAxis(e2), l2 = a2 === t._getXAxis() ? -1 : e2, n2 = f ? r2.axisSize : a2.axisSize, o2 = f ? r2.position : a2.position;
              n2 && "auto" !== n2 || (f ? (n2 = t._renderValueAxis(e2, { x: 0, y: 0, width: S, height: 0 }, true, g).height, 2 == (2 & m.valueAxis[s2]) ? n2 = 0 : n2 > 0 && (m.valueAxis[s2] |= 2)) : (n2 = t._renderXAxis(e2, { x: 0, y: 0, width: S, height: 0 }, true).height, 2 == (2 & m.xAxis[l2]) ? n2 = 0 : n2 > 0 && (m.xAxis[l2] |= 2))), "top" !== o2 && (o2 = "bottom"), C[o2 + "Count"] > 0 && C[o2] > 0 && n2 > 0 && (C[o2] += _), k.push({ height: n2, position: o2, yRel: C[o2] }), C[o2] += n2, C[o2 + "Count"]++;
            }
            t._createAnimationGroup("series");
            const D = false !== t.showLegend, T = t._legendLayout;
            var F = D ? t._renderLegend(T ? t._rect : h, true) : { width: 0, height: 0 };
            if (!T || isNaN(this.legendLayout.left) && isNaN(this.legendLayout.top) || (F = { width: 0, height: 0 }), h.height < C.top + C.bottom + F.height || h.width < x.left + x.right)
              i.endGroup();
            else {
              g.height -= C.top + C.bottom + F.height, g.x += x.left, g.width -= x.left + x.right, g.y += C.top;
              var O = [];
              if (!p)
                for (let e2 = 0; e2 < c.length; e2++) {
                  const i2 = c[e2];
                  if (true === i2.polar || true === i2.spider || "pie" === i2.type || "donut" === i2.type)
                    continue;
                  f = "horizontal" === i2.orientation;
                  let r2 = t._getXAxis(e2) === t._getXAxis() ? -1 : e2, s2 = t._getValueAxis(e2) === t._getValueAxis() ? -1 : e2, a2 = { x: g.x, y: 0, width: g.width, height: k[e2].height };
                  if ("top" !== k[e2].position ? a2.y = g.y + g.height + k[e2].yRel : a2.y = g.y - k[e2].yRel - k[e2].height, f) {
                    if (4 == (4 & m.valueAxis[s2]))
                      continue;
                    if (!t._isGroupVisible(e2))
                      continue;
                    t._renderValueAxis(e2, a2, false, g), m.valueAxis[s2] |= 4;
                  } else {
                    if (O.push(a2), 4 == (4 & m.xAxis[r2]))
                      continue;
                    if (!t._isGroupVisible(e2))
                      continue;
                    t._renderXAxis(e2, a2, false, g), m.xAxis[r2] |= 4;
                  }
                }
              if (D) {
                const e2 = t._legendLayout, i2 = e2 ? t._rect : h;
                let r2 = h.x + this.renderer._ptrnd((h.width - F.width) / 2), s2 = g.y + g.height + C.bottom, a2 = h.width, l2 = F.height;
                e2 && (isNaN(t.legendLayout.left) || (r2 = t.legendLayout.left), isNaN(t.legendLayout.top) || (s2 = t.legendLayout.top), isNaN(t.legendLayout.width) || (a2 = t.legendLayout.width), isNaN(t.legendLayout.height) || (l2 = t.legendLayout.height)), r2 + a2 > i2.x + i2.width && (a2 = i2.x + i2.width - r2), s2 + l2 > i2.y + i2.height && (l2 = i2.y + i2.height - s2), t._renderLegend({ x: r2, y: s2, width: a2, height: l2 });
              }
              if (t._hasHorizontalLines = false, !p)
                for (let e2 = 0; e2 < c.length; e2++) {
                  const i2 = c[e2];
                  if (true === i2.polar || true === i2.spider || "pie" === i2.type || "donut" === i2.type)
                    continue;
                  f = "horizontal" === c[e2].orientation;
                  let r2 = { x: g.x - v[e2].xRel - v[e2].width, y: g.y, width: v[e2].width, height: g.height };
                  "left" !== v[e2].position && (r2.x = g.x + g.width + v[e2].xRel);
                  let s2 = t._getXAxis(e2) === t._getXAxis() ? -1 : e2, a2 = t._getValueAxis(e2) === t._getValueAxis() ? -1 : e2;
                  if (f) {
                    if (O.push(r2), 8 == (8 & m.xAxis[s2]))
                      continue;
                    if (!t._isGroupVisible(e2))
                      continue;
                    t._renderXAxis(e2, r2, false, g), m.xAxis[s2] |= 8;
                  } else {
                    if (8 == (8 & m.valueAxis[a2]))
                      continue;
                    if (!t._isGroupVisible(e2))
                      continue;
                    t._renderValueAxis(e2, r2, false, g), m.valueAxis[a2] |= 8;
                  }
                }
              if (!(g.width <= 0 || g.height <= 0)) {
                t._plotRect = { x: g.x, y: g.y, width: g.width, height: g.height };
                for (let e2 = 0; e2 < c.length; e2++)
                  this._drawPlotAreaLines(e2, true, { gridLines: false, tickMarks: false, alternatingBackground: true }), this._drawPlotAreaLines(e2, false, { gridLines: false, tickMarks: false, alternatingBackground: true });
                for (let e2 = 0; e2 < c.length; e2++)
                  this._drawPlotAreaLines(e2, true, { gridLines: true, tickMarks: true, alternatingBackground: false }), this._drawPlotAreaLines(e2, false, { gridLines: true, tickMarks: true, alternatingBackground: false });
                var I = false;
                for (let e2 = 0; e2 < c.length && !I; e2++) {
                  const t2 = c[e2];
                  if (void 0 !== t2.annotations || "function" == typeof t2.draw || "function" == typeof t2.drawBefore) {
                    I = true;
                    break;
                  }
                }
                var P = i.beginGroup();
                if (t.clip && !I) {
                  var R = i.createClipRect({ x: g.x - 2, y: g.y, width: g.width + 4, height: g.height });
                  i.setClip(P, R);
                }
                for (let r2 = 0; r2 < c.length; r2++) {
                  const s2 = c[r2];
                  var L = false;
                  for (var G in t._seriesTypes)
                    if (t._seriesTypes[G] === s2.type) {
                      L = true;
                      break;
                    }
                  L || t.error(t.localize("invalidType", { type: s2.type })), "function" == typeof s2.drawBefore && s2.drawBefore(i, e, r2, this), true !== s2.polar && true !== s2.spider || -1 === s2.type.indexOf("pie") && -1 === s2.type.indexOf("donut") && t._renderSpiderAxis(r2, g), t._renderAxisBands(r2, g, true), t._renderAxisBands(r2, g, false);
                }
                for (let r2 = 0; r2 < c.length; r2++) {
                  const s2 = c[r2];
                  if (t._isColumnType(s2.type) ? t._renderColumnSeries(r2, g) : -1 !== s2.type.indexOf("pie") || -1 !== s2.type.indexOf("donut") ? t._renderPieSeries(r2, g) : -1 !== s2.type.indexOf("line") || -1 !== s2.type.indexOf("area") ? t._renderLineSeries(r2, g) : -1 !== s2.type.indexOf("scatter") || -1 !== s2.type.indexOf("bubble") ? t._renderScatterSeries(r2, g) : -1 === s2.type.indexOf("candlestick") && -1 === s2.type.indexOf("ohlc") || t._renderCandleStickSeries(r2, g, -1 !== s2.type.indexOf("ohlc")), s2.annotations) {
                    this._moduleAnnotations || t.error(t.localize("missingReference", { files: "smart.chart.annotations.js" }));
                    for (let e2 = 0; e2 < s2.annotations.length; e2++)
                      t._renderAnnotation(r2, s2.annotations[e2], g);
                  }
                  "function" == typeof s2.draw && s2.draw(i, e, r2, this);
                }
                if (i.endGroup(), t.disabled) {
                  var V = i.rect(e.x, e.y, e.width, e.height);
                  i.attr(V, { fill: "#777777", opacity: 0.5, stroke: "#00FFFFFF" });
                }
                "function" == typeof t.draw && t.draw(i, e), i.endGroup(), t._startAnimation("series"), t._credits && t._credits();
                var E = false;
                for (let e2 = 0; e2 < t.seriesGroups.length && !E; e2++) {
                  let i2 = t._getXAxis(e2);
                  i2 && i2.rangeSelector && i2.rangeSelector.visible && (E = true, t._hasRangeSelector = true);
                }
                if (E) {
                  this._moduleRangeSelector || t.error(t.localize("missingReference", { files: "smart.chart.rangeselector.js" }));
                  var B = [];
                  t._isSelectorRefresh || (t._rangeSelectorInstances = {});
                  for (let e2 = 0; e2 < t.seriesGroups.length; e2++) {
                    var H = this._getXAxis(e2);
                    -1 === B.indexOf(H) && this._renderXAxisRangeSelector(e2, O[e2]) && B.push(H);
                  }
                }
              }
            }
          }
          _credits() {
          }
          _isPieOnlySeries() {
            let e = this.seriesGroups;
            if (0 === e.length)
              return false;
            for (let t = 0; t < e.length; t++)
              if ("pie" !== e[t].type && "donut" !== e[t].type)
                return false;
            return true;
          }
          _renderChartLegend(e, t, i, r) {
            var s = this, a = s.renderer, l = { x: t.x, y: t.y, width: t.width, height: t.height };
            l.width >= 6 && (l.x += 3, l.width -= 6), l.height >= 6 && (l.y += 3, l.height -= 6);
            var n = { width: l.width, height: 0 }, o = 0, h = 0, d = 20, u = 0, g = 10, f = 0;
            for (let I = 0; I < e.length; I++) {
              var p = e[I].css;
              p || (p = "smart-chart-legend-text"), d = 20;
              var c = e[I].text, m = a.measureText(c, 0, { class: p });
              m.height > d && (d = m.height), m.width > f && (f = m.width), r ? (0 !== I && (h += d), h > l.height && (h = 0, o += f + 20 + g, f = m.width, n.width = o + f)) : (0 !== o && (o += 10), o + 20 + m.width > l.width && m.width < l.width && (o = 0, h += d, d = 20, u = l.width, n.height = h + d));
              var y = false;
              if (m.width > l.width) {
                y = true;
                var _ = l.width, x = c.split(/\s+/);
                let e2 = [], t2 = "";
                for (let i2 = 0; i2 < x.length; i2++) {
                  var v = t2 + (t2.length > 0 ? " " : "") + x[i2];
                  s.renderer.measureText(v, 0, { class: p }).width > _ && v.length > 0 && t2.length > 0 ? (e2.push({ text: t2 }), t2 = x[i2]) : t2 = v, i2 + 1 === x.length && e2.push({ text: t2 });
                }
                m.width = 0;
                var b = 0;
                for (let t3 = 0; t3 < e2.length; t3++) {
                  var N = e2[t3].text;
                  let i2 = s.renderer.measureText(N, 0, { class: p });
                  m.width = Math.max(m.width, i2.width), b += m.height;
                }
                m.height = b;
              }
              var M = o + m.width < l.width && h + m.height < t.height;
              if (s._legendLayout) {
                let e2 = l.x + o + m.width < s._rect.x + s._rect.width && l.y + h + m.height < s._rect.y + s._rect.height;
                this._renderInBounds = e2;
              }
              if (!i && M) {
                var A = e[I].seriesIndex, w = e[I].groupIndex, S = e[I].itemIndex, C = e[I].fillColor, k = e[I].lineColor, D = s._isSerieVisible(w, A, S), T = a.beginGroup(), F = D ? e[I].opacity : 0.1;
                if (y) {
                  let t2 = c, i2 = l.width, n2 = t2.split(/\s+/);
                  var O = 0;
                  let u2 = [], f2 = "";
                  for (let e2 = 0; e2 < n2.length; e2++) {
                    let t3 = f2 + (f2.length > 0 ? " " : "") + n2[e2], r2 = s.renderer.measureText(t3, 0, { class: p });
                    r2.width > i2 && t3.length > 0 && f2.length > 0 ? (u2.push({ text: f2, dy: O }), O += r2.height, f2 = n2[e2]) : f2 = t3, e2 + 1 === n2.length && u2.push({ text: f2, dy: O });
                  }
                  for (let e2 = 0; e2 < u2.length; e2++) {
                    let t3 = u2[e2].text;
                    O = u2[e2].dy, s.renderer.measureText(t3, 0, { class: p }), r ? s.renderer.text(t3, l.x + o + 15, l.y + h + O, m.width, d, 0, { class: p }, false, "left", "center") : s.renderer.text(t3, l.x + o + 15, l.y + h + O, m.width, d, 0, { class: p }, false, "center", "center");
                  }
                  let y2 = a.rect(l.x + o, l.y + h + 5 + O / 2, g, g);
                  r && (h += O), s.renderer.attr(y2, { fill: C, "fill-opacity": F, stroke: k, "stroke-width": 1, "stroke-opacity": e[I].opacity });
                } else {
                  let t2, i2 = a.rect(l.x + o, l.y + h + 5, g, g);
                  s.renderer.attr(i2, { fill: C, "fill-opacity": F, stroke: k, "stroke-width": 1, "stroke-opacity": e[I].opacity, purpose: "legend-toggle", data: e[I] }), t2 = r ? s.renderer.text(c, l.x + o + 15, l.y + h, m.width, m.height + 5, 0, { class: p }, false, "left", "center") : s.renderer.text(c, l.x + o + 15, l.y + h, m.width, d, 0, { class: p }, false, "center", "center"), a.attr(t2, { purpose: "legend-toggle", data: e[I] });
                }
                s.renderer.endGroup(), s._setLegendToggleHandler(w, A, S, T);
              }
              r || u < (o += m.width + 20) && (u = o);
            }
            if (i)
              return n.height = this.renderer._ptrnd(h + d + 5), n.width = this.renderer._ptrnd(u), n;
          }
          isSerieVisible(e, t, i) {
            return this._isSerieVisible(e, t, i);
          }
          _isSerieVisible(e, t, i) {
            for (; this._itemsToggleState.length < e + 1; )
              this._itemsToggleState.push([]);
            let r = this._itemsToggleState[e];
            for (; r.length < t + 1; )
              r.push(!!isNaN(i) || []);
            let s = r[t];
            if (isNaN(i))
              return s;
            for (Array.isArray(s) || (r[t] = s = []); s.length < i + 1; )
              s.push(true);
            return s[i];
          }
          isGroupVisible(e) {
            return this._isGroupVisible(e);
          }
          _isGroupVisible(e) {
            let t = false, i = this.seriesGroups[e].series;
            if (!i)
              return t;
            for (let r = 0; r < i.length; r++)
              if (this._isSerieVisible(e, r)) {
                t = true;
                break;
              }
            return t;
          }
          _toggleSerie(e, t, i, r) {
            let s = !this._isSerieVisible(e, t, i);
            void 0 !== r && (s = r);
            let a = this.seriesGroups[e], l = a.series[t];
            if (this.$.fireEvent("toggle", { state: s, seriesGroup: a, serie: l, elementIndex: i }), isNaN(i))
              this._itemsToggleState[e][t] = s;
            else {
              let r2 = this._itemsToggleState[e][t];
              for (Array.isArray(r2) || (r2 = []); r2.length < i; )
                r2.push(true);
              r2[i] = s;
            }
            this._isToggleRefresh = true, this.update(), this._isToggleRefresh = false;
          }
          showSerie(e, t, i) {
            this._toggleSerie(e, t, i, true);
          }
          hideSerie(e, t, i) {
            this._toggleSerie(e, t, i, false);
          }
          _setLegendToggleHandler(e, t, i, r) {
            let s = this.seriesGroups[e], a = s.series[t].enableSeriesToggle;
            if (null == a && (a = false !== s.enableSeriesToggle), a) {
              let s2 = this;
              this.renderer.addHandler(r, "click", function() {
                s2._toggleSerie(e, t, i);
              });
            }
          }
          _renderLegend(e, t) {
            let i = this, r = [];
            for (let e2 = 0; e2 < i.seriesGroups.length; e2++) {
              let t2 = i.seriesGroups[e2];
              if (false !== t2.showLegend)
                for (let s = 0; s < t2.series.length; s++) {
                  let a = t2.series[s];
                  if (false === a.showLegend)
                    continue;
                  let l, n = i._getSerieSettings(e2, s);
                  if ("pie" === t2.type || "donut" === t2.type) {
                    let o2 = i._getXAxis(e2);
                    const h2 = a.legendFormatSettings || t2.legendFormatSettings || i._getFormatSettings(o2) || i._getFormatSettings(a) || i._getFormatSettings(t2);
                    let d2 = a.legendFormatFunction || t2.legendFormatFunction || o2.formatFunction || a.formatFunction || t2.formatFunction, u2 = i._getDataLen(e2);
                    for (let t3 = 0; t3 < u2; t3++) {
                      l = i._getDataValue(t3, a.displayText, e2), l = i._formatValue(l, h2, d2, e2, s, t3);
                      let o3 = i._getColors(e2, s, t3);
                      r.push({ groupIndex: e2, seriesIndex: s, itemIndex: t3, text: l, css: a.displayTextClass, fillColor: o3.fillColor, lineColor: o3.lineColor, opacity: n.opacity });
                    }
                    continue;
                  }
                  const o = a.legendFormatSettings || t2.legendFormatSettings;
                  let h = a.legendFormatFunction || t2.legendFormatFunction;
                  l = i._formatValue(a.displayText || a.dataField || "", o, h, e2, s, NaN);
                  let d = i._getSeriesColors(e2, s), u = this._get([a.legendFillColor, a.legendColor, d.fillColor]), g = this._get([a.legendLineColor, a.legendColor, d.lineColor]);
                  r.push({ groupIndex: e2, seriesIndex: s, text: l, css: a.displayTextClass, fillColor: u, lineColor: g, opacity: n.opacity });
                }
            }
            return i._renderChartLegend(r, e, t, i._legendLayout && "vertical" === i.legendLayout.flow);
          }
          _getInterval(e, t) {
            if (!e)
              return t;
            let i = this._get([e.unitInterval, t]);
            return isNaN(e.step) || null === e.step || (i = e.step * t), i;
          }
          _getOffsets(e, t, i, r, s, a, l, n, o) {
            let h, d = this._getInterval(s[e], n), u = [];
            if (("" === e || s[e].visible && "custom" !== s[e].visible) && (u = this._generateIntervalValues(r, d, n, l, o)), "labels" !== e) {
              let e2 = l ? a.left : 0;
              if (!l && n > 1 && (e2 = a.left * (n + 1)), 1 === u.length && (e2 *= 2), h = this._valuesToOffsets(u, t, r, i, a, false, e2), !l) {
                let e3 = (a.left + a.right) * d / n;
                t.flip ? h.unshift(h[0] + e3) : h.push(h[h.length - 1] + e3);
              }
            } else {
              let e2 = a.left;
              1 === u.length && (e2 *= 2), h = this._valuesToOffsets(u, t, r, i, a, l, e2);
            }
            let g = this._arraysToObjectsArray([u, h], ["value", "offset"]);
            if (t[e] && t[e].custom) {
              let s2 = this._objectsArraysToArray(t[e].custom, "value"), n2 = this._objectsArraysToArray(t[e].custom, "offset"), o2 = this._valuesToOffsets(s2, t, r, i, a, l, a.left);
              for (let i2 = 0; i2 < t[e].custom.length; i2++)
                g.push({ value: s2[i2], offset: isNaN(n2[i2]) ? o2[i2] : n2[i2] });
            }
            return g;
          }
          _renderXAxis(e, t, i, r) {
            let s = this, a = s._getXAxis(e), l = s.seriesGroups[e], n = "horizontal" === l.orientation, o = { width: 0, height: 0 }, h = s._getAxisSettings(a);
            if (!a || !h.visible || "spider" === l.type)
              return o;
            if (!s._isGroupVisible(e) || this._isPieGroup(e))
              return o;
            let d = s._alignValuesWithTicks(e);
            for (; s._renderData.length < e + 1; )
              s._renderData.push({});
            s.rightToLeft ? (a._flip = a.flip, a.flip = true) : void 0 !== a._flip && (a.flip = a._flip);
            let u = n ? t.height : t.width, g = s._calculateXOffsets(e, u), f = g.axisStats, p = a.rangeSelector && a.rangeSelector.visible, c = 0;
            p && (this._moduleRangeSelector || s.error(s.localize("missingReference", { files: "smart.chart.rangeselector.js" })), c = this._selectorGetSize(a));
            let m = n && "right" === a.position || !n && "top" === a.position;
            !i && p && (n ? (t.width -= c, "right" !== a.position && (t.x += c)) : (t.height -= c, "top" === a.position && (t.y += c)));
            let y = { rangeLength: g.rangeLength, itemWidth: g.itemWidth, intervalWidth: g.intervalWidth, data: g, settings: h, isMirror: m, rect: t };
            s._renderData[e].xAxis = y;
            let _ = f.interval;
            if (isNaN(_))
              return o;
            n && (h.title.angle -= 90, h.labels.angle -= 90);
            let x, v, b = this._getInterval(h.gridLines, _), N = this._getInterval(h.tickMarks, _), M = this._getInterval(h.labels, _), A = f.min, w = f.max, S = g.padding, C = true === a.flip || s.rightToLeft, k = { min: A, max: w };
            f.logAxis.enabled && (k.min = f.logAxis.minPow, k.max = f.logAxis.maxPow), "date" === a.type ? (h.gridLines.offsets = this._generateDTOffsets(A, w, u, S, b, _, f.dateTimeUnit, d, NaN, false, C), h.tickMarks.offsets = this._generateDTOffsets(A, w, u, S, N, _, f.dateTimeUnit, d, NaN, false, C), x = this._generateDTOffsets(A, w, u, S, M, _, f.dateTimeUnit, d, NaN, true, C)) : (h.gridLines.offsets = this._getOffsets("gridLines", a, u, f, h, S, d, _), h.tickMarks.offsets = this._getOffsets("tickMarks", a, u, f, h, S, d, _), x = this._getOffsets("labels", a, u, f, h, S, d, _)), s._elementRenderInfo && s._elementRenderInfo.length > e && (v = s._elementRenderInfo[e].xAxis);
            let D, T = [];
            h.labels.formatFunction && (D = h.labels.formatFunction);
            const F = s._getFormatSettings(h.labels);
            let O;
            F && (O = Object.assign({}, F)), "date" === a.type && (a.dateFormat && !D ? O ? O.dateFormat = O.dateFormat || a.dateFormat : O = { dateFormat: a.dateFormat } : D || O && (!O || O.dateFormat) || (D = this._getDefaultDTFormatFn(a.baseUnit || "day")));
            for (let t2 = 0; t2 < x.length; t2++) {
              let i2, r2 = x[t2].value, l2 = x[t2].offset;
              if (isNaN(l2))
                continue;
              "date" !== a.type && f.useIndeces && a.dataField && (i2 = Math.round(r2), r2 = s._getDataValue(i2, a.dataField, e), null == r2 && (r2 = ""));
              let n2 = s._formatValue(r2, O, D, e, void 0, i2);
              null != n2 && "" !== n2.toString() || (isNaN(i2) && (i2 = t2), i2 >= f.filterRange.min && i2 <= f.filterRange.max && (n2 = f.useIndeces ? (f.min + i2).toString() : void 0 === r2 ? "" : r2.toString()));
              let o2 = { key: r2, text: n2, targetX: l2, x: l2 };
              v && v.itemOffsets[r2] && (o2.x = v.itemOffsets[r2].x, o2.y = v.itemOffsets[r2].y), T.push(o2);
            }
            let I = s._getAnimProps(e), P = I.enabled && T.length < 500 ? I.duration : 0;
            false === s.enableAxisTextAnimation && (P = 0);
            let R = { items: T, renderData: y }, L = s._renderAxis(n, m, h, { x: t.x, y: t.y, width: t.width, height: t.height }, r, _, false, true, R, i, P);
            return n ? L.width += c : L.height += c, L;
          }
          _animateAxisText(e, t) {
            let i = e.items, r = e.textSettings;
            for (let e2 = 0; e2 < i.length; e2++) {
              let s = i[e2];
              if (!s)
                continue;
              if (!s.visible)
                continue;
              let a = s.targetX, l = s.targetY;
              isNaN(s.x) || isNaN(s.y) || (a = s.x + (a - s.x) * t, l = s.y + (l - s.y) * t), s.element && (this.renderer.removeElement(s.element), s.element = void 0), s.element = this.renderer.text(s.text, a, l, s.width, s.height, r.angle, { class: r.style }, false, r.halign, r.valign, r.textRotationPoint);
            }
          }
          _getPolarAxisCoords(e, t) {
            let i = this.seriesGroups[e], r = t.x + this._draw.getNum([i.offsetX, t.width / 2]), s = t.y + this._draw.getNum([i.offsetY, t.height / 2]), a = Math.min(t.width, t.height), l = i.radius;
            this._isPercent(l) && (l = parseFloat(l) / 100 * a / 2), isNaN(l) && (l = a / 2 * 0.6);
            let n = this._alignValuesWithTicks(e), o = this._get([i.startAngle, i.minAngle, 0]) - 90;
            o = isNaN(o) ? 0 : 2 * Math.PI * o / 360;
            let h = this._get([i.endAngle, i.maxAngle, 360]) - 90;
            if (h = isNaN(h) ? 2 * Math.PI : 2 * Math.PI * h / 360, o > h) {
              let e2 = o;
              o = h, h = e2;
            }
            let d = this.renderer._rnd(Math.abs(o - h) / (2 * Math.PI), 1e-3, true), u = 2 * Math.PI * l * d, g = this._calcGroupOffsets(e, t).xoffsets;
            if (!g)
              return;
            let f, p = !(Math.abs(Math.abs(h - o) - 2 * Math.PI) > 1e-5);
            if (i.spider) {
              const t2 = this._getXAxisStats(e, this._getXAxis(e), u);
              let i2 = t2.interval;
              (isNaN(i2) || 0 === i2) && (i2 = 1);
              let r2 = (t2.max - t2.min) / i2 + (p ? 1 : 0);
              if (r2 = Math.round(r2), r2 > 2) {
                let e2 = Math.cos(Math.abs(h - o) / 2 / r2);
                e2 = this.renderer._rnd(e2, 0.01), 0 === e2 && (e2 = 1), f = l / e2, f > l && n && (l = f);
              }
            }
            return l = this.renderer._ptrnd(l), { x: r, y: s, r: l, adjR: this._get([f, l]), itemWidth: g.itemWidth, rangeLength: g.rangeLength, valuesOnTicks: n, startAngle: o, endAngle: h, isClosedCircle: p, axisSize: u };
          }
          _toPolarCoord(e, t, i, r) {
            let s = Math.abs(e.startAngle - e.endAngle) / (2 * Math.PI), a = 2 * (i - t.x) * Math.PI * s / Math.max(1, t.width) + e.startAngle, l = (t.height + t.y - r) * e.r / Math.max(1, t.height), n = e.x + l * Math.cos(a), o = e.y + l * Math.sin(a);
            return { x: this.renderer._ptrnd(n), y: this.renderer._ptrnd(o) };
          }
          _renderSpiderAxis(e, t) {
            let i = this, r = i._getXAxis(e), s = this._getAxisSettings(r);
            if (!r || !s.visible)
              return;
            let a = i.seriesGroups[e], l = i._getPolarAxisCoords(e, t);
            if (!l)
              return;
            let n = this.renderer._ptrnd(l.x), o = this.renderer._ptrnd(l.y), h = l.adjR, d = l.startAngle, u = l.endAngle;
            if (h < 1)
              return;
            let g = this.renderer._rnd(Math.abs(d - u) / (2 * Math.PI), 1e-3, true), f = 2 * Math.PI * h * g, p = l.isClosedCircle, c = this._renderData[e].xoffsets;
            if (!c.rangeLength)
              return;
            let m = c.axisStats.interval;
            for ((isNaN(m) || m < 1) && (m = 1); i._renderData.length < e + 1; )
              i._renderData.push({});
            let y = { rangeLength: c.rangeLength, itemWidth: c.itemWidth, data: c, rect: t, settings: s };
            i._renderData[e].xAxis = y, i._renderData[e].polarCoords = l;
            let _ = true;
            for (let t2 = 0; t2 < e; t2++) {
              let e2 = i._renderData[t2].polarCoords, s2 = i._getXAxis(t2), a2 = false;
              for (let t3 in l)
                if (l[t3] !== e2[t3]) {
                  a2 = true;
                  break;
                }
              a2 && s2 === r || (_ = false);
            }
            let x, v, b = s.gridLines, N = s.tickMarks, M = s.labels, A = this._getInterval(b, m), w = this._getInterval(N, m), S = this._getInterval(M, m), C = i._alignValuesWithTicks(e), k = i.renderer, D = c.axisStats, T = D.min, F = D.max, O = this._getPaddingSize(c.axisStats, r, C, f, true, p, false), I = true === r.flip || i.rightToLeft;
            "date" === r.type ? (b.offsets = this._generateDTOffsets(T, F, f, O, A, m, r.baseUnit, true, 0, false, I), N.offsets = this._generateDTOffsets(T, F, f, O, w, m, r.baseUnit, true, 0, false, I), x = this._generateDTOffsets(T, F, f, O, S, m, r.baseUnit, true, 0, true, I)) : (s.gridLines.offsets = this._getOffsets("gridLines", r, f, D, s, O, true, m), s.tickMarks.offsets = this._getOffsets("tickMarks", r, f, D, s, O, true, m), x = this._getOffsets("labels", r, f, D, s, O, true, m)), i._elementRenderInfo && i._elementRenderInfo.length > e && (v = i._elementRenderInfo[e].xAxis);
            let P = [], R = this._getDataLen(e);
            for (let t2 = 0; t2 < x.length; t2++) {
              let s2, a2 = x[t2].offset, l2 = x[t2].value;
              if ("date" !== r.type && D.useIndeces && r.dataField) {
                if (s2 = Math.round(l2), s2 >= R)
                  continue;
                l2 = i._getDataValue(s2, r.dataField), null == l2 && (l2 = "");
              }
              let n2 = i._formatValue(l2, i._getFormatSettings(M.formatSettings), M.formatFunction, e, void 0, s2);
              null != n2 && "" !== n2.toString() || (n2 = D.useIndeces ? (D.min + t2).toString() : null == l2 ? "" : l2.toString());
              let o2 = { key: l2, text: n2, targetX: a2, x: a2 };
              v && v.itemOffsets[l2] && (o2.x = v.itemOffsets[l2].x, o2.y = v.itemOffsets[l2].y), P.push(o2);
            }
            let L = { stroke: b.color || i._getThemeColor("line"), fill: "none", "stroke-width": b.width, "stroke-dasharray": b.dashStyle || "" };
            if (!a.spider)
              if (1 === g)
                k.circle(n, o, h, L);
              else {
                let e2 = -d / Math.PI * 180, t2 = -u / Math.PI * 180;
                this.renderer.pieslice(n, o, 0, h, Math.min(e2, t2), Math.max(e2, t2), void 0, L);
              }
            let G = d;
            if (b.visible && _) {
              C || p || b.offsets.unshift({ offset: -O.right });
              for (let e2 = 0; e2 < b.offsets.length; e2++) {
                let t2 = b.offsets[e2].offset;
                C || (t2 += p ? O.right / 2 : O.right);
                const i2 = G + 2 * t2 * Math.PI * g / Math.max(1, f);
                if (i2 - u > 0.01)
                  continue;
                let r2 = this.renderer._ptrnd(n + h * Math.cos(i2)), s2 = this.renderer._ptrnd(o + h * Math.sin(i2));
                k.line(n, o, r2, s2, L);
              }
            }
            if (N.visible && _) {
              let e2 = 5, t2 = { stroke: N.color || i._getThemeColor("line"), fill: "none", "stroke-width": N.width, "stroke-dasharray": N.dashStyle || "" };
              C || p || N.offsets.unshift({ offset: -O.right });
              for (let i2 = 0; i2 < N.offsets.length; i2++) {
                let r2 = N.offsets[i2].offset;
                C || (r2 += p ? O.right / 2 : O.right);
                const s2 = G + 2 * r2 * Math.PI * g / Math.max(1, f);
                if (s2 - u > 0.01)
                  continue;
                let a2 = { x: n + h * Math.cos(s2), y: o + h * Math.sin(s2) }, l2 = { x: n + (h + e2) * Math.cos(s2), y: o + (h + e2) * Math.sin(s2) };
                k.line(this.renderer._ptrnd(a2.x), this.renderer._ptrnd(a2.y), this.renderer._ptrnd(l2.x), this.renderer._ptrnd(l2.y), t2);
              }
            }
            let V = [];
            if (a.spider) {
              let e2 = [];
              e2 = "date" === r.type ? this._generateDTOffsets(T, F, f, O, m, m, r.baseUnit, true, 0, false, I) : this._getOffsets("", r, f, D, s, O, true, m), C || p || e2.unshift({ offset: -O.right });
              for (let t2 = 0; t2 < e2.length; t2++) {
                let i2 = e2[t2].offset;
                C || (i2 += p ? O.right / 2 : O.right);
                const r2 = G + 2 * i2 * Math.PI * g / Math.max(1, f);
                r2 - u > 0.01 || V.push(r2);
              }
              y.offsetAngles = V;
            }
            let E = i._renderSpiderValueAxis(e, t, C ? l.adjR : l.r, V);
            if (E || (E = []), a.spider) {
              if (!C)
                for (let e2 = 0; e2 < E.length; e2++)
                  E[e2] = E[e2] * l.adjR / l.r;
              E.push(h), this._renderSpiderLines(n, o, E, l, V, L);
            }
            if (_ && M.visible) {
              y.polarLabels = [];
              for (let e2 = 0; e2 < P.length; e2++) {
                let t2 = G + 2 * P[e2].x * Math.PI * g / Math.max(1, f);
                t2 = (360 - t2 / (2 * Math.PI) * 360) % 360, t2 < 0 && (t2 = 360 + t2);
                let i2, r2 = k.measureText(P[e2].text, 0, { class: s.labels.style }), a2 = (C ? l.adjR : l.r) + (N.visible ? 7 : 2), h2 = s.labels;
                if (h2.autoRotate) {
                  let e3 = this._draw._ptRotate(n - r2.width / 2, o - a2 - r2.height, n, o, -t2 / 180 * Math.PI), s2 = this._draw._ptRotate(n + r2.width / 2, o - a2, n, o, -t2 / 180 * Math.PI);
                  r2.width = Math.abs(e3.x - s2.x), r2.height = Math.abs(e3.y - s2.y), i2 = { x: Math.min(e3.x, s2.x), y: Math.min(e3.y, s2.y) };
                } else
                  i2 = this._adjustTextBoxPosition(n, o, r2, a2, t2, false, false, false);
                y.polarLabels.push({ x: i2.x, y: i2.y, value: P[e2].text }), k.text(P[e2].text, i2.x, i2.y, r2.width, r2.height, h2.autoRotate ? 90 - t2 : h2.angle, { class: h2.style }, false, h2.halign, h2.valign);
              }
            }
          }
          _renderSpiderLines(e, t, i, r, s, a) {
            let l = this.renderer, n = r.isClosedCircle;
            for (let r2 = 0; r2 < i.length; r2++) {
              let o, h, d = i[r2];
              for (let i2 = 0; i2 < s.length; i2++) {
                let r3 = s[i2], n2 = this.renderer._ptrnd(e + d * Math.cos(r3)), u = this.renderer._ptrnd(t + d * Math.sin(r3));
                o && l.line(o.x, o.y, n2, u, a), o = { x: n2, y: u }, h || (h = { x: n2, y: u });
              }
              h && n && l.line(o.x, o.y, h.x, h.y, a);
            }
          }
          _renderSpiderValueAxis(e, t, i, r) {
            var s = this, a = this.seriesGroups[e], l = this._getPolarAxisCoords(e, t);
            if (!l)
              return;
            var n = this.renderer._ptrnd(l.x), o = this.renderer._ptrnd(l.y);
            i = i || l.r;
            var h = l.startAngle, d = l.endAngle, u = this.renderer._rnd(Math.abs(h - d) / (2 * Math.PI), 1e-3, true);
            if (i < 1)
              return;
            i = this.renderer._ptrnd(i);
            var g = this._getValueAxis(e);
            const f = this._getAxisSettings(g);
            if (g && false !== f.visible) {
              var p = this._stats.seriesGroups[e].mu, c = f.labels, m = s._getFormatSettings(c);
              -1 !== a.type.indexOf("stacked") && -1 !== a.type.indexOf("100") && !m && (m = { sufix: "%" });
              var y = this._get([c.step, c.unitInterval / p]);
              isNaN(y) && (y = 1), y = Math.max(1, Math.round(y)), this._calcValueAxisItems(e, i, y);
              var _ = f.gridLines, x = f.tickMarks, v = f.labels, b = { stroke: _.color || s._getThemeColor("line"), fill: "none", "stroke-width": 1, "stroke-dasharray": _.dashStyle || "" }, N = this._renderData[e].valueAxis, M = N.items, A = h;
              if (M.length && f.line.visible) {
                isNaN(f.line.angle) || (A = 2 * Math.PI * f.line.angle / 360);
                var w = n + Math.cos(A) * i, S = o + Math.sin(A) * i;
                if (-1 === r.indexOf(A)) {
                  var C = Object.assign({}, b);
                  C["stroke-width"] = f.line.lineWidth, C.stroke = f.line.color || s._getThemeColor("line"), C["stroke-dasharray"] = f.line.dashStyle, this.renderer.line(n, o, w, S, C);
                }
              }
              M = M.reverse();
              var k = this.renderer;
              N.polarLabels = [];
              for (let e2 = 0; e2 < M.length - 1; e2++) {
                var D = M[e2];
                if (isNaN(D))
                  continue;
                var T = v.formatFunction ? v.formatFunction(D) : this._formatNumber(D, m), F = k.measureText(T, 0, { class: v.style }), O = n + (false !== g.showTickMarks ? 3 : 2);
                let t2 = o - N.itemWidth * e2 - F.height / 2;
                var I = this._draw._ptRotate(O, t2, n, o, A), P = this._draw._ptRotate(O + F.width, t2 + F.height, n, o, A);
                O = Math.min(I.x, P.x), t2 = Math.min(I.y, P.y), F.width = Math.abs(I.x - P.x), F.height = Math.abs(I.y - P.y), O += f.labels.textOffset.x, t2 += f.labels.textOffset.y, N.polarLabels.push({ x: O, y: t2, value: T }), k.text(T, O, t2, F.width, F.height, v.autoRotate ? 90 + 180 * h / Math.PI : v.angle, { class: v.style }, false, v.halign, v.valign);
              }
              var R = false !== g.valuesOnTicks, L = this._stats.seriesGroups[e], G = L.mu, V = true === g.logarithmicScale;
              V && (G = 1);
              var E = { min: L.min, max: L.max, logAxis: { enabled: true === V, base: g.logarithmicScaleBase, minPow: L.minPow, maxPow: L.maxPow } };
              (_.visible || a.spider || g.alternatingBackgroundColor || g.alternatingBackgroundColor2) && (_.offsets = this._getOffsets("gridLines", g, i, E, f, { left: 0, right: 0 }, R, G));
              var B = [];
              if (_.visible || a.spider) {
                let e2 = { stroke: _.color || s._getThemeColor("line"), fill: "none", "stroke-width": 1, "stroke-dasharray": _.dashStyle || "" };
                for (let t2 = 0; t2 < _.offsets.length; t2++) {
                  let r2 = this.renderer._ptrnd(_.offsets[t2].offset);
                  if (r2 !== i)
                    if (a.spider)
                      B.push(r2);
                    else if (1 !== u) {
                      var H = -h / Math.PI * 180, z = -d / Math.PI * 180;
                      this.renderer.pieslice(n, o, 0, r2, Math.min(H, z), Math.max(H, z), void 0, e2);
                    } else
                      k.circle(n, o, r2, e2);
                }
              }
              if (g.tickMarks && (g.tickMarks.visible || g.showTickMarks) || (x.visible = false), x.visible) {
                x.offsets = this._getOffsets("tickMarks", g, i, E, f, { left: 0, right: 0 }, R, G);
                const e2 = 2 * x.size;
                let t2 = { stroke: x.color || s._getThemeColor("line"), fill: "none", "stroke-width": 1, "stroke-dasharray": x.dashStyle || "" };
                for (let i2 = 0; i2 < x.offsets.length; i2++) {
                  var W = x.offsets[i2].offset;
                  let r2 = { x: n + W * Math.cos(A) - e2 / 2 * Math.sin(A + Math.PI / 2), y: o + W * Math.sin(A) - e2 / 2 * Math.cos(A + Math.PI / 2) }, s2 = { x: n + W * Math.cos(A) + e2 / 2 * Math.sin(A + Math.PI / 2), y: o + W * Math.sin(A) + e2 / 2 * Math.cos(A + Math.PI / 2) };
                  k.line(this.renderer._ptrnd(r2.x), this.renderer._ptrnd(r2.y), this.renderer._ptrnd(s2.x), this.renderer._ptrnd(s2.y), t2);
                }
              }
              return B;
            }
          }
          _renderAxis(e, t, i, r, s, a, l, n, o, h, d) {
            if (i.customDraw && !h)
              return { width: NaN, height: NaN };
            let u = i.title, g = i.labels, f = i.tickMarks, p = i.padding, c = f.visible ? f.size : 0, m = { width: 0, height: 0 }, y = { width: 0, height: 0 };
            e ? m.height = y.height = r.height : m.width = y.width = r.width, !h && t && e && (r.x -= r.width);
            let _ = o.renderData, x = _.itemWidth;
            if (u.visible && void 0 !== u.text && null !== u.text && "" !== u) {
              let i2 = u.angle, s2 = this.renderer.measureText(u.text, i2, { class: u.style });
              y.width = s2.width, y.height = s2.height, h || this.renderer.text(u.text, r.x + u.offset.x + (e ? t ? -p.right - 2 + 2 * r.width - y.width : 2 + p.left : 0), r.y + u.offset.y + (e ? 0 : t ? p.top + 2 : r.height - 2 - y.height - p.bottom), e ? y.width : r.width, e ? r.height : y.height, i2, { class: u.style }, true, u.halign, u.valign, u.rotationPoint);
            }
            let v = 0, b = n ? -x / 2 : 0;
            n && !e && (g.halign = "center");
            let N = r.x, M = r.y, A = g.textOffset;
            A && (isNaN(A.x) || (N += A.x), isNaN(A.y) || (M += A.y)), e ? (N += p.left + 2 + (y.width > 0 ? y.width + 2 : 0) + (t ? r.width - y.width : 0), M += b) : (N += b, t ? (M += y.height > 0 ? y.height + 6 : 4, M += c - (n ? c : c / 4)) : M += n ? c : c / 4, M += p.top);
            let w = 0, S = 0, C = o.items;
            _.itemOffsets = {}, !this._isToggleRefresh && this._isUpdate || (d = 0);
            let k = false, D = 0;
            for (let i2 = 0; i2 < C.length && g.visible; i2++, v += x) {
              if (!C[i2] || isNaN(x))
                continue;
              let s2 = C[i2].text;
              isNaN(C[i2].targetX) || (v = C[i2].targetX);
              let a2 = this.renderer.measureText(s2, g.angle, { class: g.style });
              if (a2.width > S && (S = a2.width), a2.height > w && (w = a2.height), D += e ? w : S, !h) {
                if (e && v > r.height + 2 || !e && v > r.width + 2)
                  continue;
                const s3 = e ? N + (t ? 0 === y.width ? c : c - 2 : 0) : N + v;
                let a3 = e ? M + v : M;
                _.itemOffsets[C[i2].key] = { x: s3, y: a3 }, k || (!isNaN(C[i2].x) || !isNaN(C[i2].y) && d) && (k = true), C[i2].targetX = s3, C[i2].targetY = a3, C[i2].width = e ? r.width - p.left - p.right - 4 - c - (y.width > 0 ? y.width + 2 : 0) : x, C[i2].height = e ? x : r.height - p.top - p.bottom - 4 - c - (y.height > 0 ? y.height + 2 : 0), C[i2].visible = true;
              }
            }
            if (_.avgWidth = 0 === C.length ? 0 : D / C.length, !h) {
              let e2 = { items: C, textSettings: g };
              if (!isNaN(d) && k || (d = 0), this._animateAxisText(e2, 0 === d ? 1 : 0), 0 !== d) {
                let t2 = this;
                this._enqueueAnimation("series", void 0, void 0, d, function(e3, i2, r2) {
                  t2._animateAxisText(i2, r2);
                }, e2);
              }
            }
            if (m.width += 4 + c + y.width + S + (e && y.width > 0 ? 2 : 0), m.height += 4 + c + y.height + w + (!e && y.height > 0 ? 2 : 0), e ? m.width += p.left + p.right : m.height += p.top + p.bottom, !h && i.line.visible) {
              let s2 = { stroke: i.line.color || self._getThemeColor("line"), "stroke-width": i.line.width, "stroke-dasharray": i.line.dashStyle || "" };
              if (e) {
                let e2 = r.x + r.width + (t ? p.left : -p.right);
                e2 = this.renderer._ptrnd(e2), this.renderer.line(e2, r.y, e2, r.y + r.height, s2);
              } else {
                let e2 = this.renderer._ptrnd(r.y + (t ? r.height - p.bottom : p.top));
                this.renderer.line(this.renderer._ptrnd(r.x), e2, this.renderer._ptrnd(r.x + r.width + 1), e2, s2);
              }
            }
            return m.width = this.renderer._rup(m.width), m.height = this.renderer._rup(m.height), m;
          }
          _drawPlotAreaLines(e, t, i) {
            var r = this.seriesGroups[e], s = "horizontal" !== r.orientation;
            if (!this._renderData || this._renderData.length <= e)
              return;
            var a = t ? "valueAxis" : "xAxis", l = this._renderData[e][a];
            if (!l)
              return;
            var n = this._renderData.axisDrawState;
            n || (n = this._renderData.axisDrawState = {});
            var o, h = "";
            t ? (h = "valueAxis_" + (r.valueAxis ? e : "") + (s ? "swap" : ""), o = this._getValueAxis(e)) : (h = "xAxis_" + (r.xAxis ? e : "") + (s ? "swap" : ""), o = this._getXAxis(e)), n = n[h] ? n[h] : n[h] = {}, t || (s = !s);
            var d = l.settings;
            if (!d)
              return;
            if (d.customDraw)
              return;
            var u = d.gridLines, g = d.tickMarks, f = d.padding, p = l.rect, c = this._plotRect;
            if (!u || !g)
              return;
            var m = 0.5, y = {};
            let _ = { stroke: u.color || self._getThemeColor("line"), "stroke-width": u.width, "stroke-dasharray": u.dashStyle || "" };
            var x = t ? p.y + p.height : p.x, v = u.offsets;
            let b;
            if (t && !o.flip && (v = (v = v.slice(0)).reverse()), v && v.length > 0) {
              var N = NaN;
              for (let e2 = 0; e2 < v.length; e2++)
                if (s ? (b = this.renderer._ptrnd(p.y + v[e2].offset), b < p.y - m && (b = this.renderer._ptrnd(p.y)), b > p.y + p.height && (b = p.y + p.height)) : (b = this.renderer._ptrnd(p.x + v[e2].offset), b > p.x + p.width + m && (b = this.renderer._ptrnd(p.x + p.width))), !isNaN(b) && (isNaN(N) || !(Math.abs(b - N) < 2))) {
                  if (N = b, i.gridLines && false !== u.visible && true !== n.gridLines && (s ? this.renderer.line(this.renderer._ptrnd(c.x), b, this.renderer._ptrnd(c.x + c.width), b, _) : this.renderer.line(b, this.renderer._ptrnd(c.y), b, this.renderer._ptrnd(c.y + c.height), _)), y[b] = true, i.alternatingBackground && (u.alternatingBackgroundColor || u.alternatingBackgroundColor2) && true !== n.alternatingBackground) {
                    var M, A = e2 % 2 == 0 ? u.alternatingBackgroundColor2 : u.alternatingBackgroundColor;
                    e2 > 0 && A && (M = s ? this.renderer.rect(this.renderer._ptrnd(c.x), x, this.renderer._ptrnd(c.width - 1), b - x, _) : this.renderer.rect(x, this.renderer._ptrnd(c.y), b - x, this.renderer._ptrnd(c.height), _), this.renderer.attr(M, { "stroke-width": 0, fill: A, opacity: u.alternatingBackgroundOpacity || 1 }));
                  }
                  x = b;
                }
            }
            if (_ = { stroke: g.color || self._getThemeColor("line"), "stroke-width": g.width, "stroke-dasharray": g.dashStyle || "" }, i.tickMarks && g.visible && true !== n.tickMarks) {
              var w = g.size;
              let e2 = g.offsets, i2 = NaN;
              for (let r2 = 0; r2 < e2.length; r2++)
                if (s ? (b = this.renderer._ptrnd(p.y + e2[r2].offset), b < p.y - m && (b = this.renderer._ptrnd(p.y)), b > p.y + p.height && (b = p.y + p.height)) : (b = this.renderer._ptrnd(p.x + e2[r2].offset), b > p.x + p.width + m && (b = this.renderer._ptrnd(p.x + p.width))), !isNaN(b) && (isNaN(i2) || !(Math.abs(b - i2) < 2))) {
                  if (y[b - 1] ? b-- : y[b + 1] && b++, s) {
                    if (b > p.y + p.height + m)
                      break;
                  } else if (b > p.x + p.width + m)
                    break;
                  i2 = b;
                  var S = l.isMirror ? w : -w;
                  if (s) {
                    var C = p.x + p.width + ("right" === o.position ? f.left : -f.right);
                    t || (C = p.x + (l.isMirror ? f.left : -f.right + p.width)), this.renderer.line(C, b, C + S, b, _);
                  } else {
                    var k = p.y + (l.isMirror ? p.height : 0);
                    k += l.isMirror ? -f.bottom : f.top, k = this.renderer._ptrnd(k), this.renderer.line(b, k, b, k - S, _);
                  }
                }
            }
            n.tickMarks = n.tickMarks || i.tickMarks, n.gridLines = n.gridLines || i.gridLines, n.alternatingBackground = n.alternatingBackground || i.alternatingBackground;
          }
          _calcValueAxisItems(e, t, i) {
            let r = this._stats.seriesGroups[e];
            if (!r || !r.isValid)
              return false;
            let s = this.seriesGroups[e], a = this._getValueAxis(e), l = false !== a.valuesOnTicks, n = r.intervals, o = t / n, h = r.min, d = r.mu, u = true === a.logarithmicScale, g = a.logarithmicScaleBase || 10, f = -1 !== s.type.indexOf("stacked") && -1 !== s.type.indexOf("100");
            for (u && (d = isNaN(a.unitInterval) ? 1 : a.unitInterval), l || (n = Math.max(n - 1, 1)); this._renderData.length < e + 1; )
              this._renderData.push({});
            this._renderData[e].valueAxis = {};
            let p = this._renderData[e].valueAxis;
            p.itemWidth = p.intervalWidth = o, p.items = [];
            let c = p.items;
            for (let e2 = 0; e2 <= n; e2++) {
              let t2 = 0;
              t2 = u ? f ? r.max / Math.pow(g, n - e2) : h * Math.pow(g, e2) : l ? h + e2 * d : h + (e2 + 0.5) * d, e2 % i == 0 ? c.push(t2) : c.push(NaN);
            }
            return p.rangeLength = u && !f ? r.intervals : r.intervals * d, true !== a.flip && (c = c.reverse()), true;
          }
          _getDecimalPlaces(e, t, i) {
            let r = 0;
            isNaN(i) && (i = 10);
            for (let s = 0; s < e.length; s++) {
              let a = void 0 === t ? e[s] : e[s][t];
              if (isNaN(a))
                continue;
              let l = a.toString();
              for (let e2 = 0; e2 < l.length; e2++)
                if ((l[e2] < "0" || l[e2] > "9") && (r = l.length - (e2 + 1), r >= 0))
                  return Math.min(r, i);
              for (r > 0 && (a *= Math.pow(10, r)); Math.round(a) !== a && r < i; )
                r++, a *= 10;
            }
            return r;
          }
          _renderValueAxis(e, t, i, r) {
            let s = this.seriesGroups[e], a = "horizontal" === s.orientation, l = this._getValueAxis(e);
            l || this.error(this.localize("missingAxis", { index: e, axis: "valueAxis" }));
            let n = { width: 0, height: 0 };
            if (!this._isGroupVisible(e) || this._isPieOnlySeries() || "spider" === s.type)
              return n;
            let o = false !== l.valuesOnTicks, h = this._stats.seriesGroups[e], d = h.mu, u = true === l.logarithmicScale, g = l.logarithmicScaleBase || 10;
            if (u && (d = isNaN(l.unitInterval) ? 1 : l.unitInterval), 0 === d && (d = 1), isNaN(d))
              return n;
            let f = this._getAxisSettings(l), p = f.title, c = f.labels, m = l.labels || {};
            this._get([l.horizontalTextAlignment, m.horizontalAlignment]) || 0 !== c.angle || (c.halign = a ? "center" : "right" === l.position ? "left" : "right");
            let y = this._get([c.step, c.unitInterval / d]);
            if (isNaN(y) && (y = 1), y = Math.max(1, Math.round(y)), !this._calcValueAxisItems(e, a ? t.width : t.height, y) || !f.visible)
              return n;
            a || (p.angle = this.rightToLeft ? 90 : -90, "centercenter" === p.rotationPoint && ("top" === p.valign ? p.rotationPoint = "rightcenter" : "bottom" === p.valign && (p.rotationPoint = "leftcenter")));
            let _ = this._renderData[e].valueAxis, x = this._getFormatSettings(c);
            -1 !== s.type.indexOf("stacked") && -1 !== s.type.indexOf("100") && !x && (x = { sufix: "%" }), c.formatFunction || x && null !== x.decimalPlaces && void 0 !== x.decimalPlaces || (x = x || {}, x.decimalPlaces = this._getDecimalPlaces([h.min, h.max, d], void 0, 3));
            let v = f.gridLines, b = a ? t.width : t.height, N = true === l.flip;
            l.flip = !N;
            let M = { min: h.min, max: h.max, logAxis: { enabled: true === u, base: g, minPow: h.minPow, maxPow: h.maxPow } };
            (v.visible || l.alternatingBackgroundColor || l.alternatingBackgroundColor2) && (v.offsets = this._getOffsets("gridLines", l, b, M, f, { left: 0, right: 0 }, o, d));
            let A = f.tickMarks;
            A.visible && (A.offsets = this._getOffsets("tickMarks", l, b, M, f, { left: 0, right: 0 }, o, d));
            const w = this._getOffsets("labels", l, b, M, f, { left: 0, right: 0 }, o, d, !o);
            l.flip = N;
            let S, C = [];
            this._elementRenderInfo && this._elementRenderInfo.length > e && (S = this._elementRenderInfo[e].valueAxis);
            for (let e2 = 0; e2 < w.length; e2++) {
              let t2 = w[e2].value;
              if (isNaN(w[e2].offset)) {
                C.push(void 0);
                continue;
              }
              let i2 = { key: t2, text: c.formatFunction ? c.formatFunction(t2) : isNaN(t2) ? t2 : this._formatNumber(t2, x) };
              S && S.itemOffsets[t2] && (i2.x = S.itemOffsets[t2].x, i2.y = S.itemOffsets[t2].y), i2.targetX = w[e2].offset, isNaN(i2.targetX) || C.push(i2);
            }
            let k = a && "top" === l.position || !a && "right" === l.position || !a && this.rightToLeft && "left" !== l.position, D = { items: C, renderData: _ }, T = this._getAnimProps(e), F = T.enabled && C.length < 500 ? T.duration : 0;
            return false === this.enableAxisTextAnimation && (F = 0), _.settings = f, _.isMirror = k, _.rect = t, this._renderAxis(!a, k, f, t, r, d, u, true, D, i, F);
          }
          _objectsArraysToArray(e, t) {
            let i = [];
            if (!Array.isArray(e))
              return i;
            for (let r = 0; r < e.length; r++)
              i.push(e[r][t]);
            return i;
          }
          _arraysToObjectsArray(e, t) {
            let i = [];
            if (e.length !== t.length)
              return i;
            for (let r = 0; r < e.length; r++)
              for (let s = 0; s < e[r].length; s++)
                i.length <= s && i.push({}), i[s][t[r]] = e[r][s];
            return i;
          }
          _valuesToOffsets(e, t, i, r, s, a, l) {
            let n = [];
            if (!t || !Array.isArray(e))
              return n;
            let o = i.logAxis.base, h = i.logAxis.enabled ? "logarithmic" : "linear", d = t.flip, u = r, g = 0, f = 0;
            s && !isNaN(s.left) && (g = s.left), s && !isNaN(s.right) && (f = s.right), u = r - g - f, r = u;
            for (let t2 = 0; t2 < e.length; t2++) {
              let s2 = this._smartPlot.scale(e[t2], { min: i.min.valueOf(), max: i.max.valueOf(), type: h, base: o }, { min: 0, max: a ? r : u, flip: d }, {});
              isNaN(s2) ? n.push(NaN) : (isNaN(l) || (s2 += l), s2 <= r + g + f + 1 ? n.push(this.renderer._ptrnd(s2)) : n.push(NaN));
            }
            return n;
          }
          _generateIntervalValues(e, t, i, r, s) {
            let a = [], l = e.min, n = e.max;
            if (e.logAxis && e.logAxis.enabled && (l = e.logAxis.minPow, n = e.logAxis.maxPow), null == l || null == n)
              return a;
            if (l === n)
              return e.logAxis && e.logAxis.enabled ? [Math.pow(e.logAxis.base, l)] : [l];
            let o = 1;
            i < 1 && (o = 1e6, l *= o, n *= o, i *= o);
            for (let e2 = l; e2 <= n; e2 += i)
              a.push(e2 / o + (s ? i / 2 : 0));
            if (t > i) {
              let e2 = [], r2 = Math.round(t / i);
              for (let t2 = 0; t2 < a.length; t2++)
                t2 % r2 == 0 && e2.push(a[t2]);
              a = e2;
            }
            if (e.logAxis && e.logAxis.enabled)
              for (let t2 = 0; t2 < a.length; t2++)
                a[t2] = Math.pow(e.logAxis.base, a[t2]);
            return a;
          }
          _generateDTOffsets(e, t, i, r, s, a, l, n, o, h, d) {
            l || (l = "day");
            var u = [];
            if (e > t)
              return u;
            if (e === t)
              return h ? u.push({ offset: n ? i / 2 : r.left, value: e }) : n && u.push({ offset: i / 2, value: e }), u;
            var g = i - r.left - r.right, f = e, p = r.left, c = p, m = a = Math.max(a, 1), y = Math.min(1, a);
            for (a > 1 && "millisecond" !== l && (a = 1); this.renderer._ptrnd(c) <= this.renderer._ptrnd(r.left + g + (n ? 0 : r.right)); ) {
              u.push({ offset: c, value: f });
              var _ = new Date(f.valueOf());
              if ("millisecond" === l)
                _.setMilliseconds(f.getMilliseconds() + a);
              else if ("second" === l)
                _.setSeconds(f.getSeconds() + a);
              else if ("minute" === l)
                _.setMinutes(f.getMinutes() + a);
              else if ("hour" === l) {
                var x = _.valueOf();
                _.setHours(f.getHours() + a), x === _.valueOf() && _.setHours(f.getHours() + a + 1);
              } else
                "day" === l ? _.setDate(f.getDate() + a) : "month" === l ? _.setMonth(f.getMonth() + a) : "year" === l && _.setFullYear(f.getFullYear() + a);
              c = p + ((f = _).valueOf() - e.valueOf()) * y / (t.valueOf() - e.valueOf()) * g;
            }
            if (d)
              for (let e2 = 0; e2 < u.length; e2++)
                u[e2].offset = i - u[e2].offset;
            if (m > 1 && "millisecond" !== l) {
              var v = [];
              for (let e2 = 0; e2 < u.length; e2 += m)
                v.push({ offset: u[e2].offset, value: u[e2].value });
              u = v;
            }
            if (!n && !h && u.length > 1) {
              let e2 = [];
              e2.push({ offset: 0, value: void 0 });
              for (let t2 = 1; t2 < u.length; t2++)
                e2.push({ offset: u[t2 - 1].offset + (u[t2].offset - u[t2 - 1].offset) / 2, value: void 0 });
              var b = e2.length;
              b > 1 ? e2.push({ offset: e2[b - 1].offset + (e2[b - 1].offset - e2[b - 2].offset) }) : e2.push({ offset: i, value: void 0 }), u = e2;
            }
            if (s > a) {
              let e2 = [];
              var N = Math.round(s / m);
              for (let t2 = 0; t2 < u.length; t2++)
                t2 % N == 0 && e2.push({ offset: u[t2].offset, value: u[t2].value });
              u = e2;
            }
            return u;
          }
          _hasStackValueReversal(e, t) {
            let i = this.seriesGroups[e];
            if (-1 === i.type.indexOf("stacked"))
              return false;
            let r = -1 !== i.type.indexOf("waterfall"), s = this._getDataLen(e), a = 0, l = false, n = [];
            for (let t2 = 0; t2 < i.series.length; t2++)
              n[t2] = this._isSerieVisible(e, t2);
            for (let o = 0; o < s; o++) {
              let s2;
              r || (l = false);
              for (let r2 = 0; r2 < i.series.length; r2++) {
                if (!n[r2])
                  continue;
                const h = this._getDataValueAsNumber(o, i.series[r2].dataField, e);
                if (isNaN(h))
                  continue;
                if (i.series[r2].summary && void 0 !== this._getDataValue(o, i.series[r2].summary, e))
                  continue;
                let d = l ? h < 0 : h < t;
                if (l = true, void 0 === s2 && (s2 = d), d !== s2)
                  return true;
                s2 = d, a += h;
              }
            }
            return this.waterfallStackSum = a, false;
          }
          _getValueAxis(e) {
            let t = null == e ? this.valueAxis : this.seriesGroups[e].valueAxis || this.valueAxis;
            return t || (t = this.valueAxis = {}), t;
          }
          _buildStats(e) {
            var t = { seriesGroups: [] };
            this._stats = t;
            for (let B2 = 0; B2 < this.seriesGroups.length; B2++) {
              var i = this.seriesGroups[B2];
              t.seriesGroups[B2] = {};
              var r = this._getXAxis(B2), s = this._getValueAxis(B2), a = this._getXAxisStats(B2, r, "horizontal" !== i.orientation ? e.width : e.height);
              let H = t.seriesGroups[B2];
              H.isValid = true;
              var l = "horizontal" === i.orientation ? e.width : e.height, n = true === s.logarithmicScale, o = s.logarithmicScaleBase;
              isNaN(o) && (o = 10);
              var h = -1 !== i.type.indexOf("stacked"), d = h && -1 !== i.type.indexOf("100"), u = -1 !== i.type.indexOf("range"), g = -1 !== i.type.indexOf("waterfall");
              g && !this._moduleWaterfall && self.error(self.localize("missingReference", { files: "smart.chart.waterfall.js" })), d && (H.psums = [], H.nsums = []);
              var f = NaN, p = NaN, c = NaN, m = NaN, y = s ? s.baselineValue : NaN;
              isNaN(y) && (y = n && !d ? 1 : 0);
              var _ = false;
              0 !== y && h && (_ = this._hasStackValueReversal(B2, y)) && (y = 0), h && g && (_ = this._hasStackValueReversal(B2, y));
              var x = this._getDataLen(B2), v = 0, b = NaN, N = [];
              if (g)
                for (let e2 = 0; e2 < i.series.length; e2++)
                  N.push(NaN);
              var M = NaN;
              for (let e2 = 0; e2 < x && H.isValid; e2++) {
                if (r.rangeSelector && r.rangeSelector.visible) {
                  var A = r.dataField ? this._getDataValue(e2, r.dataField, B2) : e2;
                  if (A && a.isDateTime && (A = this._castAsDate(A, r.dateFormat)), a.useIndeces && (A = e2), A && (A.valueOf() < a.min.valueOf() || A.valueOf() > a.max.valueOf()))
                    continue;
                }
                var w = s.minValue, S = s.maxValue;
                s.baselineValue && (w = isNaN(w) ? y : Math.min(y, w), S = isNaN(S) ? y : Math.max(y, S));
                var C = 0, k = 0;
                for (let t2 = 0; i.series && t2 < i.series.length; t2++)
                  if (this._isSerieVisible(B2, t2)) {
                    var D = NaN, T = NaN, F = NaN;
                    if (-1 !== i.type.indexOf("candle") || -1 !== i.type.indexOf("ohlc")) {
                      var O = ["Open", "Low", "Close", "High"];
                      for (var I in O) {
                        var P = this._getDataValueAsNumber(e2, i.series[t2]["dataField" + O[I]], B2);
                        isNaN(P) || (F = isNaN(T) ? P : Math.min(F, P), T = isNaN(T) ? P : Math.max(T, P));
                      }
                    } else if (u) {
                      var R = this._getDataValueAsNumber(e2, i.series[t2].dataFieldFrom, B2), L = this._getDataValueAsNumber(e2, i.series[t2].dataFieldTo, B2);
                      T = Math.max(R, L), F = Math.min(R, L);
                    } else {
                      if (D = this._getDataValueAsNumber(e2, i.series[t2].dataField, B2), g) {
                        if (this._isSummary(B2, e2) && void 0 !== this._getDataValue(e2, i.series[t2].summary, B2))
                          continue;
                        h ? (isNaN(M) || (D += M), M = D) : (isNaN(N[t2]) ? N[t2] = D : D += N[t2], N[t2] = D);
                      }
                      if (isNaN(D) || n && D <= 0)
                        continue;
                      F = T = D;
                    }
                    (isNaN(S) || T > S) && (isNaN(s.maxValue) || T <= s.maxValue) && (S = T), (isNaN(w) || F < w) && (isNaN(s.minValue) || F >= s.minValue) && (w = F), isNaN(D) || !h || g || (D > y ? C += D : D < y && (k += D));
                  }
                if (d || (isNaN(s.maxValue) || (C = Math.min(s.maxValue, C)), isNaN(s.minValue) || (k = Math.max(s.minValue, k))), n && d)
                  for (let t2 = 0; t2 < i.series.length; t2++) {
                    if (!this._isSerieVisible(B2, t2)) {
                      b = 0.01;
                      continue;
                    }
                    let r2 = this._getDataValueAsNumber(e2, i.series[t2].dataField, B2);
                    if (isNaN(r2) || r2 <= 0)
                      b = 0.01;
                    else {
                      var G = 0 === C ? 0 : r2 / C;
                      (isNaN(b) || G < b) && (b = G);
                    }
                  }
                var V = C - k;
                v < V && (v = V), d && (H.psums[e2] = C, H.nsums[e2] = k), (S > p || isNaN(p)) && (p = S), (w < f || isNaN(f)) && (f = w), (C > c || isNaN(c)) && (c = C), (k < m || isNaN(m)) && (m = k);
              }
              d && (c = 0 === c ? 0 : Math.max(c, -m), m = 0 === m ? 0 : Math.min(m, -c)), f === p && (!isNaN(s.minValue) && isNaN(s.maxValue) ? (f = s.minValue, p = n ? f * o : f + 1) : isNaN(s.minValue) && !isNaN(s.maxValue) && (p = s.maxValue, f = n ? p / o : p - 1)), f === p && (0 === f ? (f = -1, p = 1) : f < 0 ? p = 0 : n ? 1 === f && (f /= o, p *= o) : f = 0);
              var E = { gmin: f, gmax: p, gsumP: c, gsumN: m, gbase: y, isLogAxis: n, logBase: o, minPercent: b, gMaxRange: v, isStacked: h, isStacked100: d, isWaterfall: g, hasStackValueReversal: _, valueAxis: s, valueAxisSize: l };
              E.isStacked && (E.gsumN < 0 && (E.gmin = Math.min(E.gmin, E.gbase + E.gsumN)), E.gsumP > 0 && (E.gmax = Math.max(E.gmax, E.gbase + E.gsumP))), H.context = E;
            }
            this._mergeCommonValueAxisStats();
            for (let e2 = 0; e2 < t.seriesGroups.length; e2++) {
              let i2 = t.seriesGroups[e2];
              if (i2.isValid) {
                var B = this._calcOutputGroupStats(i2.context);
                for (let e3 in B)
                  i2[e3] = B[e3];
                delete i2.context;
              }
            }
          }
          _mergeCommonValueAxisStats() {
            let e = {};
            for (let t = 0; t < this.seriesGroups.length; t++) {
              if (!this._isGroupVisible(t))
                continue;
              if (this.seriesGroups[t].valueAxis)
                continue;
              let i = this._stats.seriesGroups[t].context;
              e.gbase = i.gbase, (isNaN(e.gmin) || i.gmin < e.gmin) && (e.gmin = i.gmin), (isNaN(e.gmax) || i.gmax > e.gmax) && (e.gmax = i.gmax), (isNaN(e.gsumP) || i.gsumP > e.gsumP) && (e.gsumP = i.gsumP), (isNaN(e.gsumN) || i.gsumN < e.gsumN) && (e.gsumN = i.gsumN), (isNaN(e.logBase) || i.logBase < e.logBase) && (e.logBase = i.logBase), (isNaN(e.minPercent) || i.minPercent < e.minPercent) && (e.minPercent = i.minPercent), e.gsumN > 0 && (e.gmin = Math.min(e.gmin, e.gbase + e.gsumN)), e.gsumP > 0 && (e.gmax = Math.max(e.gmax, e.gbase + e.gsumP));
            }
            for (let t = 0; t < this.seriesGroups.length; t++) {
              if (this.seriesGroups[t].valueAxis)
                continue;
              let i = this._stats.seriesGroups[t].context;
              for (let t2 in e)
                i[t2] = e[t2];
            }
          }
          _calcOutputGroupStats(e) {
            let t = e.gmin, i = e.gmax, r = e.gsumP, s = e.gsumN, a = e.gbase, l = e.isLogAxis, n = e.logBase, o = e.minPercent, h = e.gMaxRange, d = e.isStacked, u = e.isStacked100, g = e.isWaterfall, f = e.hasStackValueReversal, p = e.valueAxis, c = e.valueAxisSize, m = e.valueAxis.unitInterval;
            m || (m = this._calcInterval(t, i, Math.max(c / 80, 2))), t === i && (t = a, i *= 2);
            let y = NaN, _ = 0, x = 0;
            if (l) {
              if (u) {
                y = 0;
                let e2 = 1;
                for (_ = x = this._draw.log(100, n); e2 > o; )
                  e2 /= n, _--, y++;
                t = Math.pow(n, _);
              } else
                d && !g && (i = Math.max(i, r)), x = this.renderer._rnd(this._draw.log(i, n), 1, true), i = Math.pow(n, x), _ = this.renderer._rnd(this._draw.log(t, n), 1, false), t = Math.pow(n, _);
              m = n;
            }
            t < s && (s = t), i > r && (r = i);
            let v = t, b = i;
            if (l || 0 != Math.abs(b - v) % m && (v = this.renderer._rnd(t, m, false), b = this.renderer._rnd(i, m, true)), u && b > 100 && (b = 100), u && !l && (b = b > 0 ? 100 : 0, v = v < 0 ? -100 : 0, m = p.unitInterval, (isNaN(m) || m <= 0 || m >= 100) && (m = 10), 100 % m != 0))
              for (; m >= 1 && 100 % m != 0; m--)
                ;
            return isNaN(b) || isNaN(v) || isNaN(m) ? {} : (isNaN(y) && (y = parseInt(((b - v) / (0 === m ? 1 : m)).toFixed())), l && !u && (y = x - _, h = Math.pow(n, y)), y < 1 ? {} : { min: v, max: b, logarithmic: l, logBase: n, base: l ? v : a, minPow: _, maxPow: x, sumP: r, sumN: s, mu: m, maxRange: h, intervals: y, hasStackValueReversal: f });
          }
          _getDataLen(e) {
            let t = this.dataSource;
            return null != e && -1 !== e && this.seriesGroups[e].dataSource && (t = this.seriesGroups[e].dataSource), t ? t.length : 0;
          }
          _getDataValue(e, t, i) {
            let r = this.dataSource;
            if (null != i && -1 !== i && (r = this.seriesGroups[i].dataSource || r), !(!r || e < 0 || e > r.length - 1))
              return "function" == typeof t ? t(e, r) : t && "" !== t ? r[e][t] : r[e];
          }
          _getDataValueAsNumber(e, t, i) {
            let r = this._getDataValue(e, t, i);
            return this._isDate(r) ? r.valueOf() : ("number" != typeof r && (r = parseFloat(r)), "number" != typeof r && (r = void 0), r);
          }
          _isPieGroup(e) {
            let t = this.seriesGroups[e];
            return !(!t || !t.type || -1 === t.type.indexOf("pie") && -1 === t.type.indexOf("donut"));
          }
          _renderPieSeries(e, t) {
            let i = this._getDataLen(e), r = this.seriesGroups[e], s = this._calcGroupOffsets(e, t).offsets;
            for (let a = 0; a < r.series.length; a++) {
              let l = r.series[a];
              if (l.customDraw)
                continue;
              let n = this._getSerieSettings(e, a), o = this._getAnimProps(e, a), h = o.enabled && i < 5e3 && !this._isToggleRefresh && o.duration;
              this._isTouchDevice && this.renderer instanceof Smart.Utilities.HTML5Renderer && (h = 0);
              let d = this._get([l.minAngle, l.startAngle]);
              (isNaN(d) || d < 0 || d > 360) && (d = 0);
              let u = this._get([l.maxAngle, l.endAngle]);
              (isNaN(u) || u < 0 || u > 360) && (u = 360);
              let g = { rect: t, minAngle: d, maxAngle: u, groupIndex: e, serieIndex: a, settings: n, items: [] };
              for (let t2 = 0; t2 < i; t2++) {
                let i2 = s[a][t2];
                if (!i2.visible)
                  continue;
                let r2 = i2.fromAngle, l2 = Math.round(i2.toAngle), n2 = this.renderer.pieslice(i2.x, i2.y, i2.innerRadius, i2.outerRadius, r2, 0 === h ? l2 : r2, i2.centerOffset);
                this._setRenderInfo(e, a, t2, { element: n2 });
                let o2 = { displayValue: i2.displayValue, itemIndex: t2, visible: i2.visible, x: i2.x, y: i2.y, innerRadius: i2.innerRadius, outerRadius: i2.outerRadius, fromAngle: r2, toAngle: l2, centerOffset: i2.centerOffset };
                g.items.push(o2);
              }
              this._animatePieSlices(g, 0);
              let f = this;
              this._enqueueAnimation("series", void 0, void 0, h, function(e2, t2, i2) {
                f._animatePieSlices(t2, i2);
              }, g);
            }
          }
          _sliceSortFunction(e, t) {
            return e.fromAngle - t.fromAngle;
          }
          _animatePieSlices(e, t) {
            var i;
            this._elementRenderInfo && this._elementRenderInfo.length > e.groupIndex && this._elementRenderInfo[e.groupIndex].series && this._elementRenderInfo[e.groupIndex].series.length > e.serieIndex && (i = this._elementRenderInfo[e.groupIndex].series[e.serieIndex]);
            var r = this._getLabelsSettings(e.groupIndex, e.serieIndex, NaN), s = r.visible, a = [];
            for (let r2 = 0; r2 < e.items.length; r2++) {
              const s2 = e.items[r2];
              if (!s2.visible)
                continue;
              let h2 = s2.fromAngle;
              var l = s2.fromAngle + t * (s2.toAngle - s2.fromAngle);
              if (i && i[s2.displayValue]) {
                var n = i[s2.displayValue].fromAngle, o = i[s2.displayValue].toAngle;
                h2 = n + (h2 - n) * t, l = o + (l - o) * t;
              }
              a.push({ index: r2, from: h2, to: l });
            }
            i && a.sort(this._sliceSortFunction);
            var h = NaN;
            for (let l2 = 0; l2 < a.length; l2++) {
              const n2 = e.items[a[l2].index];
              var d = this._getRenderInfo(e.groupIndex, e.serieIndex, n2.itemIndex);
              let o2 = a[l2].from, p = a[l2].to;
              i && (!isNaN(h) && o2 > h && (o2 = h), h = p, l2 === a.length - 1 && p !== a[0].from && (p = e.maxAngle + a[0].from));
              var u = this.renderer.pieSlicePath(n2.x, n2.y, n2.innerRadius, n2.outerRadius, o2, p, n2.centerOffset);
              this.renderer.attr(d.element, { d: u });
              var g = this._getColors(e.groupIndex, e.serieIndex, n2.itemIndex, "radialGradient", n2.outerRadius), f = e.settings;
              d.colors = g, d.settings = f, this.renderer.attr(d.element, { fill: g.fillColor, stroke: g.lineColor, "stroke-width": f.stroke, "fill-opacity": f.opacity, "stroke-opacity": f.opacity, "stroke-dasharray": "none" }), s && this._showPieLabel(e.groupIndex, e.serieIndex, n2.itemIndex, r, void 0, d.colors.lineColor), 1 === t && this._installHandlers(d.element, "pieslice", e.groupIndex, e.serieIndex, n2.itemIndex);
            }
          }
          _showPieLabel(e, t, i, r, s) {
            let a = this._renderData[e].offsets[t][i];
            if (a.elementInfo.labelElement && this.renderer.removeElement(a.elementInfo.labelElement), r || (r = this._getLabelsSettings(e, t, NaN)), !r.visible)
              return;
            let l = a.fromAngle, n = a.toAngle, o = Math.abs(l - n);
            o > 360 && (l = 0, n = 360);
            let h = o / 2 + l;
            h %= 360;
            let d, u = h * Math.PI * 2 / 360;
            true === r.autoRotate && (d = h < 90 || h > 270 ? 360 - h : 180 - h);
            let g = r.linesEnabled, f = this._showLabel(e, t, i, { x: 0, y: 0, width: 0, height: 0 }, "center", "center", true, false, false, d), p = r.radius || a.outerRadius + Math.max(f.width, f.height);
            this._isPercent(p) && (p = parseFloat(p) / 100 * Math.min(this._plotRect.width, this._plotRect.height) / 2), p += a.centerOffset, isNaN(s) && (s = 0), p += s;
            let c = this.seriesGroups[e], m = c.series[t], y = this._draw.getNum([m.offsetX, c.offsetX, this._plotRect.width / 2]), _ = this._draw.getNum([m.offsetY, c.offsetY, this._plotRect.height / 2]), x = this._plotRect.x + y, v = this._plotRect.y + _, b = this._adjustTextBoxPosition(x, v, f, p, h, a.outerRadius > p, false !== r.linesAngles, true === r.autoRotate);
            const N = {}, M = b.x < x ? 0 : f.width / 2, A = Math.sqrt(Math.pow(b.x - x, 2) + Math.pow(b.y - v, 2)) + M < a.outerRadius ? arguments[5] : void 0;
            if (a.elementInfo.labelElement = this._showLabel(e, t, i, { x: b.x, y: b.y, width: f.width, height: f.height }, "left", "top", false, false, false, d, N, A), p > a.outerRadius + s + 5 && false !== g) {
              let e2 = { lineColor: a.elementInfo.colors.lineColor, stroke: a.elementInfo.settings.stroke, opacity: a.elementInfo.settings.opacity, dashStyle: a.elementInfo.settings.dashStyle };
              a.elementInfo.labelArrowPath = this._updateLebelArrowPath(a.elementInfo.labelArrowPath, x, v, p, a.outerRadius + s, u, false !== r.linesAngles, e2, N);
            }
          }
          _updateLebelArrowPath(e, t, i, r, s, a, l, n, o) {
            const h = this.renderer;
            let d = h._ptrnd(t + (r - 0) * Math.cos(a)), u = h._ptrnd(i - (r - 0) * Math.sin(a)), g = h._ptrnd(t + (s + 2) * Math.cos(a)), f = h._ptrnd(i - (s + 2) * Math.sin(a)), p = [];
            p.push({ x: o.x + o.width / 2, y: o.y }), p.push({ x: o.x + o.width / 2, y: o.y + o.height }), p.push({ x: o.x, y: o.y + o.height / 2 }), p.push({ x: o.x + o.width, y: o.y + o.height / 2 }), l || (p.push({ x: o.x, y: o.y }), p.push({ x: o.x + o.width, y: o.y }), p.push({ x: o.x + o.width, y: o.y + o.height }), p.push({ x: o.x, y: o.y + o.height })), p = p.sort(function(e2, r2) {
              return h._ptdist(e2.x, e2.y, t, i) - h._ptdist(r2.x, r2.y, t, i);
            }), p = p.sort(function(e2, r2) {
              return Math.abs(e2.x - t) + Math.abs(e2.y - i) - (Math.abs(r2.x - t) + Math.abs(r2.y - i));
            });
            for (let e2 = 0; e2 < p.length; e2++)
              p[e2].x = h._ptrnd(p[e2].x), p[e2].y = h._ptrnd(p[e2].y);
            d = p[0].x, u = p[0].y;
            let c = "M " + d + "," + u + " L" + g + "," + f;
            return l && (c = "M " + d + "," + u + " L" + g + "," + u + " L" + g + "," + f), e ? h.attr(e, { d: c }) : e = h.path(c, {}), h.attr(e, { fill: "none", stroke: n.lineColor, "stroke-width": n.stroke, "stroke-opacity": n.opacity, "stroke-dasharray": "none" }), e;
          }
          _adjustTextBoxPosition(e, t, i, r, s, a, l, n) {
            let o = s * Math.PI * 2 / 360, h = this.renderer._ptrnd(e + r * Math.cos(o)), d = this.renderer._ptrnd(t - r * Math.sin(o));
            if (n) {
              let s2 = i.width, a2 = i.height, l2 = Math.atan(a2 / s2) % (2 * Math.PI), n2 = o % (2 * Math.PI), h2 = 0;
              n2 <= l2 ? h2 = s2 / 2 * Math.cos(o) : n2 >= l2 && n2 < Math.PI - l2 ? h2 = a2 / 2 * Math.sin(o) : n2 >= Math.PI - l2 && n2 < Math.PI + l2 ? h2 = s2 / 2 * Math.cos(o) : n2 >= Math.PI + l2 && n2 < 2 * Math.PI - l2 ? h2 = a2 / 2 * Math.sin(o) : n2 >= 2 * Math.PI - l2 && n2 < 2 * Math.PI && (h2 = s2 / 2 * Math.cos(o)), r += Math.abs(h2) + 3;
              let d2 = this.renderer._ptrnd(e + r * Math.cos(o)), u = this.renderer._ptrnd(t - r * Math.sin(o));
              return d2 -= i.width / 2, u -= i.height / 2, { x: d2, y: u };
            }
            return a ? (h -= i.width / 2, d -= i.height / 2) : l ? s >= 90 && s < 270 ? (d -= i.height / 2, h -= i.width) : d -= i.height / 2 : s >= 0 && s < 45 || s >= 315 && s < 360 ? d -= i.height / 2 : s >= 45 && s < 135 ? (d -= i.height, h -= i.width / 2) : s >= 135 && s < 225 ? (d -= i.height / 2, h -= i.width) : s >= 225 && s < 315 && (h -= i.width / 2), { x: h, y: d };
          }
          _isColumnType(e) {
            return -1 !== e.indexOf("column") || -1 !== e.indexOf("waterfall");
          }
          _getColumnGroupsCount(e) {
            let t = 0;
            e = e || "vertical";
            let i = this.seriesGroups;
            for (let r = 0; r < i.length; r++) {
              let s = i[r].orientation || "vertical";
              this._isColumnType(i[r].type) && s === e && t++;
            }
            return this.columnSeriesOverlap && (t = 1), t;
          }
          _getColumnGroupIndex(e) {
            let t = 0, i = this.seriesGroups[e].orientation || "vertical";
            for (let r = 0; r < e; r++) {
              let e2 = this.seriesGroups[r], s = e2.orientation || "vertical";
              this._isColumnType(e2.type) && s === i && t++;
            }
            return t;
          }
          _renderAxisBands(e, t, i) {
            var r = i ? this._getXAxis(e) : this._getValueAxis(e), s = this.seriesGroups[e], a = i ? void 0 : s.bands;
            if (!a) {
              for (let t2 = 0; t2 < e; t2++)
                if ((i ? this._getXAxis(t2) : this._getValueAxis(t2)) === r)
                  return;
              a = r.bands;
            }
            if (Array.isArray(a)) {
              var l = t, n = "horizontal" === s.orientation;
              n && (l = { x: t.y, y: t.x, width: t.height, height: t.width }), this._calcGroupOffsets(e, l);
              for (let r2 = 0; r2 < a.length; r2++) {
                var o = a[r2], h = o.minValue, d = o.maxValue, u = i ? this.getXAxisDataPointOffset(h, e) : this.getValueAxisDataPointOffset(h, e), g = i ? this.getXAxisDataPointOffset(d, e) : this.getValueAxisDataPointOffset(d, e);
                if (!isNaN(u) && !isNaN(g)) {
                  var f, p = Math.abs(u - g);
                  if (s.polar || s.spider) {
                    var c = this._renderData[e], m = c.polarCoords;
                    if (i)
                      if (s.spider) {
                        const t2 = this.getPolarDataPointOffset(h, this._stats.seriesGroups[e].max, e), i2 = this.getPolarDataPointOffset(d, this._stats.seriesGroups[e].max, e);
                        let r3 = "M " + m.x + "," + m.y;
                        r3 += " L " + t2.x + "," + t2.y, r3 += " L " + i2.x + "," + i2.y, f = this.renderer.path(r3);
                      } else {
                        var y = {}, _ = { x: Math.min(u, g), y: t.y, width: p, height: t.height };
                        this._columnAsPieSlice(y, t, m, _), f = y.element;
                      }
                    else {
                      var x = this._toPolarCoord(m, t, t.x, c.baseOffset), v = this._toPolarCoord(m, t, t.x, u), b = this._toPolarCoord(m, t, t.x, g), N = this.renderer._ptdist(x.x, x.y, v.x, v.y), M = this.renderer._ptdist(x.x, x.y, b.x, b.y), A = Math.round(360 * -m.startAngle / (2 * Math.PI)), w = Math.round(360 * -m.endAngle / (2 * Math.PI));
                      if (A > w) {
                        const e2 = A;
                        A = w, w = e2;
                      }
                      if (s.spider) {
                        var S = c.xAxis.offsetAngles;
                        let e2 = "";
                        var C = [M, N], k = S;
                        for (var D in m.isClosedCircle && (k = S.slice(0)).push(k[0]), C) {
                          for (let t2 = 0; t2 < k.length; t2++) {
                            var T = 0 === D ? t2 : S.length - t2 - 1;
                            let i2 = m.x + C[D] * Math.cos(k[T]), r3 = m.y + C[D] * Math.sin(k[T]);
                            e2 += "" === e2 ? "M " : " L", e2 += this.renderer._ptrnd(i2) + "," + this.renderer._ptrnd(r3);
                          }
                          if (0 === D) {
                            let t2 = m.x + C[1] * Math.cos(k[T]), i2 = m.y + C[1] * Math.sin(k[T]);
                            e2 += " L" + this.renderer._ptrnd(t2) + "," + this.renderer._ptrnd(i2);
                          }
                        }
                        e2 += " Z", f = this.renderer.path(e2);
                      } else
                        f = this.renderer.pieslice(m.x, m.y, N, M, A, w);
                    }
                  } else {
                    var F = { x: Math.min(u, g), y: l.y, width: p, height: l.height };
                    if (i || (F = { x: l.x, y: Math.min(u, g), width: l.width, height: p }), n) {
                      let e2 = F.x;
                      F.x = F.y, F.y = e2, e2 = F.width, F.width = F.height, F.height = e2;
                    }
                    f = 0 === p || 1 === p ? this.renderer.line(this.renderer._ptrnd(F.x), this.renderer._ptrnd(F.y), this.renderer._ptrnd(F.x + (n ? 0 : F.width)), this.renderer._ptrnd(F.y + (n ? F.height : 0))) : this.renderer.rect(F.x, F.y, F.width, F.height);
                  }
                  var O = o.color || this._getThemeColor("band"), I = o.lineColor || O, P = o.lineWidth;
                  isNaN(P) && (P = 1);
                  var R = o.opacity;
                  (isNaN(R) || R < 0 || R > 1) && (R = 1), this.renderer.attr(f, { fill: O, "fill-opacity": R, stroke: I, "stroke-opacity": R, "stroke-width": P, "stroke-dasharray": o.dashStyle });
                }
              }
            }
          }
          _getColumnGroupWidth(e, t, i) {
            let r = this.seriesGroups[e], s = -1 !== r.type.indexOf("stacked"), a = this._getColumnGroupsCount(r.orientation);
            (isNaN(a) || 0 === a) && (a = 1);
            let l = t.rangeLength >= 1 ? t.itemWidth : 0.9 * i, n = r.columnsMinWidth;
            isNaN(n) && (n = 1), isNaN(r.columnsMaxWidth) || (n = Math.min(r.columnsMaxWidth, n)), n > l && t.length > 0 && (l = Math.max(l, 0.9 * i / t.length));
            let o = n;
            if (!s) {
              let e2 = r.seriesGapPercent;
              (isNaN(e2) || e2 < 0) && (e2 = 10), e2 /= 100;
              let t2 = n;
              t2 *= 1 + e2, o += r.series.length * t2;
            }
            return { requiredWidth: o, availableWidth: l, targetWidth: Math.max(l / a, o) };
          }
          _getColumnSerieWidthAndOffset(e, t) {
            let i = this.seriesGroups[e], r = "horizontal" === i.orientation, s = this._plotRect;
            r && (s = { x: s.y, y: s.x, width: s.height, height: s.width });
            let a = this._calcGroupOffsets(e, s);
            if (!a || 0 === a.xoffsets.length)
              return;
            let l = this._getColumnGroupsCount(i.orientation);
            "candlestick" !== i.type && "ohlc" !== i.type || (l = 1);
            let n = this._getColumnGroupIndex(e), o = this._getColumnGroupWidth(e, a.xoffsets, r ? s.height : s.width), h = 0, d = o.targetWidth;
            (true === this.columnSeriesOverlap || Math.round(d) > Math.round(o.availableWidth / l)) && (l = 1, n = 0), h -= d * l / 2, h += d * n;
            let u = i.columnsGapPercent;
            u <= 0 && (u = 0), (isNaN(u) || u >= 100) && (u = 25), u /= 100;
            let g = d * u;
            g + o.requiredWidth > o.targetWidth && (g = Math.max(0, o.targetWidth - o.requiredWidth)), Math.round(d) > Math.round(o.availableWidth) && (g = 0), d -= g, h += g / 2;
            let f = i.seriesGapPercent;
            (isNaN(f) || f < 0) && (f = 10);
            let p = -1 !== i.type.indexOf("stacked"), c = d;
            p || (c /= i.series.length);
            let m = this._get([i.seriesGap, d * f / 100 / (i.series.length - 1)]);
            (true === i.polar || true === i.spider || p || i.series.length <= 1) && (m = 0);
            let y = m * (i.series.length - 1);
            i.series.length > 1 && y > d - 1 * i.series.length && (y = d - 1 * i.series.length, m = y / Math.max(1, i.series.length - 1));
            let _ = c - y / i.series.length, x = 0, v = i.columnsMaxWidth;
            isNaN(v) || _ > v && (x = _ - v, _ = v);
            let b = 0;
            return b = p ? x / 2 : (d - _ * i.series.length - y) / 2 + _ * t + Math.max(0, t) * m, { width: _, offset: h + b };
          }
          _renderColumnSeries(e, t) {
            let i = this.seriesGroups[e];
            if (!i.series || 0 === i.series.length)
              return;
            let r = "horizontal" === i.orientation, s = t;
            r && (s = { x: t.y, y: t.x, width: t.height, height: t.width });
            let a, l = this._calcGroupOffsets(e, s);
            if (!l || 0 === l.xoffsets.length)
              return;
            true !== i.polar && true !== i.spider || (a = this._getPolarAxisCoords(e, s));
            let n = { groupIndex: e, rect: t, vertical: !r, seriesCtx: [], renderData: l, polarAxisCoords: a };
            n.columnGroupWidth = this._getColumnGroupWidth(e, l.xoffsets, r ? s.height : s.width);
            let o, h = this._getGroupGradientType(e);
            for (let t2 = 0; t2 < i.series.length; t2++) {
              let r2 = i.series[t2];
              if (r2.customDraw)
                continue;
              let s2 = this._getAnimProps(e, t2);
              o = s2.enabled && !this._isToggleRefresh && l.xoffsets.length < 100 ? s2.duration : 0;
              let d2 = this._getColumnSerieWidthAndOffset(e, t2), u = this._isSerieVisible(e, t2), g = this._getSerieSettings(e, t2), f = this._getColors(e, t2, NaN, this._getGroupGradientType(e), 4), p = [];
              if ("function" == typeof r2.colorFunction && !a)
                for (let i2 = l.xoffsets.first; i2 <= l.xoffsets.last; i2++)
                  p.push(this._getColors(e, t2, i2, h, 4));
              let c = { seriesIndex: t2, serieColors: f, itemsColors: p, settings: g, columnWidth: d2.width, xAdjust: d2.offset, isVisible: u };
              n.seriesCtx.push(c);
            }
            this._animColumns(n, 0 === o ? 1 : 0);
            let d = this;
            this._enqueueAnimation("series", void 0, void 0, o, function(e2, t2, i2) {
              d._animColumns(t2, i2);
            }, n);
          }
          _getPercent(e, t, i, r) {
            return isNaN(e) && (e = t), !isNaN(i) && !isNaN(e) && e < i && (e = i), !isNaN(r) && !isNaN(e) && e > r && (e = r), isNaN(e) ? NaN : e;
          }
          _getColumnVOffsets(e, t, i, r, s, a) {
            var l = this.seriesGroups[t], n = this._getPercent(l.columnsTopWidthPercent, 100, 0, 100), o = this._getPercent(l.columnsBottomWidthPercent, 100, 0, 100);
            0 === n && 0 === o && (o = 100);
            var h = this._getPercent(l.columnsNeckHeightPercent, NaN, 0, 100) / 100, d = this._getPercent(l.columnsNeckWidthPercent, 100, 0, 100) / 100, u = [], g = NaN;
            for (let l2 = 0; l2 < i.length; l2++) {
              var f, p = i[l2], c = p.seriesIndex, m = e.offsets[c][r].from, y = e.offsets[c][r].to, _ = e.xoffsets.data[r], x = p.isVisible;
              x || (y = m);
              var v = this._elementRenderInfo;
              if (x && v && v.length > t && v[t].series.length > c) {
                var b = e.xoffsets.xvalues[r];
                !(f = v[t].series[c][b]) || isNaN(f.from) || isNaN(f.to) || (m = f.from + (m - f.from) * a, y = f.to + (y - f.to) * a, _ = f.xoffset + (_ - f.xoffset) * a);
              }
              f || (y = m + (y - m) * (s ? 1 : a)), isNaN(m) && (m = isNaN(g) ? e.baseOffset : g), g = !isNaN(y) && s ? y : m, isNaN(y) && (y = m);
              var N = { from: m, to: y, xOffset: _ };
              100 === n && 100 === o || (N.funnel = true, N.toWidthPercent = n, N.fromWidthPercent = o), u.push(N);
            }
            if (s && u.length > 1 && !(this._elementRenderInfo && this._elementRenderInfo.length > t)) {
              var M = 0, A = 0, w = -1 / 0, S = 1 / 0, C = 1 / 0, k = -1 / 0;
              for (let e2 = 0; e2 < u.length; e2++)
                i[e2].isVisible && (u[e2].to >= u[e2].from ? (A += u[e2].to - u[e2].from, C = Math.min(C, u[e2].from), k = Math.max(k, u[e2].to)) : (M += u[e2].from - u[e2].to, w = Math.max(w, u[e2].from), S = Math.min(S, u[e2].to)));
              var D = M, T = A;
              M *= a, A *= a;
              var F = 0, O = 0;
              for (let e2 = 0; e2 < u.length; e2++)
                if (u[e2].to >= u[e2].from) {
                  let t2 = u[e2].to - u[e2].from;
                  t2 + O > A && (t2 = Math.max(0, A - O), u[e2].to = u[e2].from + t2), 100 === n && 100 === o || (u[e2].funnel = true, !isNaN(h) && T * h >= O ? u[e2].fromWidthPercent = 100 * d : u[e2].fromWidthPercent = Math.abs(u[e2].from - C) / T * (n - o) + o, !isNaN(h) && T * h >= 0 + (O + t2) ? u[e2].toWidthPercent = 100 * d : u[e2].toWidthPercent = Math.abs(u[e2].to - C) / T * (n - o) + o), O += t2;
                } else {
                  let t2 = u[e2].from - u[e2].to;
                  t2 + F > M && (t2 = Math.max(0, M - F), u[e2].to = u[e2].from - t2), 100 === n && 100 === o || (u[e2].funnel = true, !isNaN(h) && D * h >= F ? u[e2].fromWidthPercent = 100 * d : u[e2].fromWidthPercent = Math.abs(u[e2].from - w) / D * (n - o) + o, !isNaN(h) && D * h >= 0 + (F + t2) ? u[e2].toWidthPercent = 100 * d : u[e2].toWidthPercent = Math.abs(u[e2].to - w) / D * (n - o) + o), F += t2;
                }
            }
            return u;
          }
          _columnAsPieSlice(e, t, i, r) {
            let s = this._toPolarCoord(i, t, r.x, r.y), a = this._toPolarCoord(i, t, r.x, r.y + r.height), l = this.renderer._ptdist(i.x, i.y, a.x, a.y), n = this.renderer._ptdist(i.x, i.y, s.x, s.y), o = t.width, h = 180 * Math.abs(i.startAngle - i.endAngle) / Math.PI, d = -(r.x - t.x) * h / o, u = -(r.x + r.width - t.x) * h / o, g = i.startAngle;
            if (g = 360 * g / (2 * Math.PI), d -= g, u -= g, e)
              if (void 0 !== e.element && null !== e.element) {
                let t2 = this.renderer.pieSlicePath(i.x, i.y, l, n, u, d, 0);
                t2 += " Z", this.renderer.attr(e.element, { d: t2 });
              } else
                e.element = this.renderer.pieslice(i.x, i.y, l, n, u, d, 0);
            return { fromAngle: u, toAngle: d, innerRadius: l, outerRadius: n };
          }
          _setRenderInfo(e, t, i, r) {
            this._renderData[e].offsets[t][i].elementInfo = r;
          }
          _getRenderInfo(e, t, i) {
            return this._renderData[e].offsets[t][i].elementInfo || {};
          }
          _animColumns(e, t) {
            var i = this, r = e.groupIndex, s = this.seriesGroups[r], a = e.renderData, l = -1 !== s.type.indexOf("waterfall"), n = this._getXAxis(r), o = -1 !== s.type.indexOf("stacked"), h = e.polarAxisCoords, d = -1;
            for (let e2 = 0; e2 < s.series.length; e2++)
              if (this._isSerieVisible(r, e2)) {
                d = e2;
                break;
              }
            var u = NaN, g = NaN;
            for (let t2 = 0; t2 < e.seriesCtx.length; t2++) {
              var f = e.seriesCtx[t2];
              (isNaN(u) || u > f.xAdjust) && (u = f.xAdjust), (isNaN(g) || g < f.xAdjust + f.columnWidth) && (g = f.xAdjust + f.columnWidth);
            }
            var p = Math.abs(g - u), c = this._get([s.columnsGapPercent, 25]) / 100;
            (isNaN(c) < 0 || c >= 1) && (c = 0.25);
            var m = c * p, y = e.renderData.xoffsets, _ = -1, x = {}, v = true === s.skipOverlappingPoints;
            for (let u2 = y.first; u2 <= y.last; u2++) {
              var b = y.data[u2];
              if (!(isNaN(b) || -1 !== _ && Math.abs(b - _) < p - 1 + m && v)) {
                _ = b;
                var N = this._getColumnVOffsets(a, r, e.seriesCtx, u2, o, t), M = false;
                if (l)
                  for (let e2 = 0; e2 < s.series.length; e2++)
                    s.series[e2].summary && y.xvalues[u2][s.series[e2].summary] && (M = true);
                for (let g2 = 0; g2 < e.seriesCtx.length; g2++) {
                  let f2 = e.seriesCtx[g2];
                  var A = f2.seriesIndex, w = s.series[A], S = N[g2].from, C = N[g2].to, k = N[g2].xOffset, D = (e.vertical ? e.rect.x : e.rect.y) + f2.xAdjust, T = f2.settings;
                  let p2 = 0 !== f2.itemsColors.length ? f2.itemsColors[u2 - a.xoffsets.first] : f2.serieColors;
                  var F = this._isSerieVisible(r, A);
                  if (!F)
                    continue;
                  let c2 = this.renderer._ptrnd(D + k);
                  var O = { x: c2, width: f2.columnWidth };
                  N[g2].funnel && (O.fromWidthPercent = N[g2].fromWidthPercent, O.toWidthPercent = N[g2].toWidthPercent);
                  var I = true;
                  e.vertical ? (O.y = S, O.height = C - S, O.height < 0 && (O.y += O.height, O.height = -O.height, I = false)) : (O.x = S < C ? S : C, O.width = Math.abs(S - C), I = S - C < 0, O.y = c2, O.height = f2.columnWidth);
                  var P = S - C;
                  if (!isNaN(P)) {
                    P = Math.abs(P);
                    var R = void 0, L = i._getRenderInfo(r, A, u2), G = L.element, V = L.labelElement, E = null == G;
                    if (V && (i.renderer.removeElement(V), V = void 0), h) {
                      var B = { element: G };
                      R = this._columnAsPieSlice(B, e.rect, h, O), G = B.element, p2 = this._getColors(r, A, void 0, "radialGradient", R.outerRadius);
                    } else if (N[g2].funnel) {
                      var H = this._getTrapezoidPath(Object.assign({}, O), e.vertical, I);
                      E ? G = this.renderer.path(H, {}) : this.renderer.attr(G, { d: H });
                    } else
                      E ? G = this.renderer.rect(O.x, O.y, e.vertical ? O.width : 0, e.vertical ? 0 : O.height) : true === e.vertical ? this.renderer.attr(G, { x: O.x, y: O.y, height: P }) : this.renderer.attr(G, { x: O.x, y: O.y, width: P });
                    if (P < 1 && (1 !== t || h) ? this.renderer.attr(G, { display: "none" }) : this.renderer.attr(G, { display: "block" }), E && this.renderer.attr(G, { fill: p2.fillColor, "fill-opacity": T.opacity, "stroke-opacity": T.opacity, stroke: p2.lineColor, "stroke-width": T.stroke, "stroke-dasharray": T.dashStyle }), V && this.renderer.removeElement(V), !F || 0 === P && t < 1)
                      L = { element: G, labelElement: V }, i._setRenderInfo(r, A, u2, L);
                    else {
                      if (l && false !== this._get([w.showWaterfallLines, s.showWaterfallLines])) {
                        if (!o || o && g2 === d) {
                          var z = o ? -1 : g2;
                          if (1 === t && !isNaN(a.offsets[g2][u2].from) && !isNaN(a.offsets[g2][u2].to)) {
                            var W = x[z];
                            if (null != W) {
                              var j = { x: W.x, y: this.renderer._ptrnd(W.y) }, X = { x: c2, y: j.y }, U = s.columnsTopWidthPercent / 100;
                              (isNaN(U) || U > 1 || U < 0) && (U = 1);
                              var Y = s.columnsBottomWidthPercent / 100;
                              (isNaN(Y) || Y > 1 || Y < 0) && (Y = 1);
                              var q = e.vertical ? O.width : O.height;
                              if (j.x = j.x - q / 2 + q / 2 * U, M) {
                                let e2 = q * U / 2;
                                X.x = X.x + q / 2 - (n.flip ? -e2 : e2);
                              } else {
                                let e2 = q * Y / 2;
                                X.x = X.x + q / 2 - (n.flip ? -e2 : e2);
                              }
                              e.vertical || (this._swapXY([j]), this._swapXY([X])), this.renderer.line(j.x, j.y, X.x, X.y, { stroke: W.color, "stroke-width": T.stroke, "stroke-opacity": T.opacity, "fill-opacity": T.opacity, "stroke-dasharray": T.dashStyle });
                            }
                          }
                        }
                        1 === t && 0 !== P && (x[o ? -1 : g2] = { y: C, x: e.vertical ? O.x + O.width : O.y + O.height, color: p2.lineColor });
                      }
                      if (h) {
                        let e2 = this._showLabel(r, A, u2, O, void 0, void 0, true);
                        var Z = R.outerRadius + 10;
                        const t2 = this._adjustTextBoxPosition(h.x, h.y, e2, Z, (R.fromAngle + R.toAngle) / 2, true, false, false);
                        V = this._showLabel(r, A, u2, { x: t2.x, y: t2.y }, void 0, void 0, false, false, false);
                      } else
                        V = this._showLabel(r, A, u2, O, void 0, void 0, false, false, I);
                      L = { element: G, labelElement: V }, i._setRenderInfo(r, A, u2, L), 1 === t && this._installHandlers(G, "column", r, A, u2);
                    }
                  }
                }
              }
            }
          }
          _getTrapezoidPath(e, t, i) {
            let r = "", s = e.fromWidthPercent / 100, a = e.toWidthPercent / 100;
            if (!t) {
              let t2 = e.width;
              e.width = e.height, e.height = t2, t2 = e.x, e.x = e.y, e.y = t2;
            }
            let l = e.x + e.width / 2, n = [{ x: l - e.width * (i ? a : s) / 2, y: e.y + e.height }, { x: l - e.width * (i ? s : a) / 2, y: e.y }, { x: l + e.width * (i ? s : a) / 2, y: e.y }, { x: l + e.width * (i ? a : s) / 2, y: e.y + e.height }];
            t || this._swapXY(n), r += "M " + this.renderer._ptrnd(n[0].x) + "," + this.renderer._ptrnd(n[0].y);
            for (let e2 = 1; e2 < n.length; e2++)
              r += " L " + this.renderer._ptrnd(n[e2].x) + "," + this.renderer._ptrnd(n[e2].y);
            return r += " Z", r;
          }
          _swapXY(e) {
            for (let t = 0; t < e.length; t++) {
              let i = e[t].x;
              e[t].x = e[t].y, e[t].y = i;
            }
          }
          _renderCandleStickSeries(e, t, i) {
            let r = this, s = r.seriesGroups[e];
            if (!s.series || 0 === s.series.length)
              return;
            let a = "horizontal" === s.orientation, l = t;
            a && (l = { x: t.y, y: t.x, width: t.height, height: t.width });
            let n, o = r._calcGroupOffsets(e, l);
            if (!o || 0 === o.xoffsets.length)
              return;
            (s.polar || s.spider) && (n = r._getPolarAxisCoords(e, l));
            let h = r._getGroupGradientType(e), d = [];
            for (let t2 = 0; t2 < s.series.length; t2++)
              d[t2] = r._getColumnSerieWidthAndOffset(e, t2);
            for (let l2 = 0; l2 < s.series.length; l2++) {
              if (!this._isSerieVisible(e, l2))
                continue;
              let u = r._getSerieSettings(e, l2), g = s.series[l2];
              if (g.customDraw)
                continue;
              let f = "function" == typeof g.colorFunction ? void 0 : r._getColors(e, l2, NaN, h), p = { rect: t, inverse: a, groupIndex: e, seriesIndex: l2, symbolType: g.symbolType, symbolSize: g.symbolSize, "fill-opacity": u.opacity, "stroke-opacity": u.opacity, "stroke-width": u.stroke, "stroke-dasharray": u.dashStyle, gradientType: h, colors: f, renderData: o, polarAxisCoords: n, columnsInfo: d, isOHLC: i, items: [], self: r }, c = r._getAnimProps(e, l2), m = c.enabled && !r._isToggleRefresh && o.xoffsets.length < 5e3 ? c.duration : 0;
              r._animCandleStick(p, 0), r._enqueueAnimation("series", void 0, void 0, m, function(e2, t2, i2) {
                r._animCandleStick(t2, i2, e2);
              }, p);
            }
          }
          _animCandleStick(e, t) {
            var i = ["Open", "Low", "Close", "High"], r = e.columnsInfo[e.seriesIndex].width, s = e.self.seriesGroups[e.groupIndex], a = e.renderData.xoffsets, l = -1, n = Math.abs(a.data[a.last] - a.data[a.first]);
            n *= t;
            var o = NaN, h = NaN;
            for (let t2 = 0; t2 < e.columnsInfo.length; t2++) {
              var d = e.columnsInfo[t2];
              (isNaN(o) || o > d.offset) && (o = d.offset), (isNaN(h) || h < d.offset + d.width) && (h = d.offset + d.width);
            }
            var u = Math.abs(h - o), g = false !== s.skipOverlappingPoints;
            for (let o2 = a.first; o2 <= a.last; o2++) {
              var f = a.data[o2];
              if (!(isNaN(f) || -1 !== l && Math.abs(f - l) < u && g)) {
                if (Math.abs(a.data[o2] - a.data[a.first]) > n)
                  break;
                l = f;
                var p = e.items[o2] = e.items[o2] || {};
                for (let t2 in i) {
                  var c = e.self._getDataValueAsNumber(o2, s.series[e.seriesIndex]["dataField" + i[t2]], e.groupIndex);
                  if (isNaN(c))
                    break;
                  var m = e.renderData.offsets[e.seriesIndex][o2][i[t2]];
                  if (isNaN(m))
                    break;
                  p[i[t2]] = m;
                }
                if (f += e.inverse ? e.rect.y : e.rect.x, e.polarAxisCoords) {
                  var y = this._toPolarCoord(e.polarAxisCoords, this._plotRect, f, m);
                  f = y.x, m = y.y;
                }
                for (var _ in f = this.renderer._ptrnd(f), i)
                  p[_] = this.renderer._ptrnd(p[_]);
                var x = e.colors;
                if (x || (x = e.self._getColors(e.groupIndex, e.seriesIndex, o2, e.gradientType)), e.isOHLC) {
                  var v = "M" + f + "," + p.Low + " L" + f + "," + p.High + " M" + (f - r / 2) + "," + p.Open + " L" + f + "," + p.Open + " M" + (f + r / 2) + "," + p.Close + " L" + f + "," + p.Close;
                  e.inverse && (v = "M" + p.Low + "," + f + " L" + p.High + "," + f + " M" + p.Open + "," + (f - r / 2) + " L" + p.Open + "," + f + " M" + p.Close + "," + f + " L" + p.Close + "," + (f + r / 2));
                  let i2 = p.lineElement;
                  i2 || (i2 = this.renderer.path(v, {}), this.renderer.attr(i2, { fill: x.fillColor, "fill-opacity": e["fill-opacity"], "stroke-opacity": e["fill-opacity"], stroke: x.lineColor, "stroke-width": e["stroke-width"], "stroke-dasharray": e["stroke-dasharray"] }), p.lineElement = i2), 1 === t && this._installHandlers(i2, "column", e.groupIndex, e.seriesIndex, o2);
                } else {
                  var b = p.lineElement;
                  b || (b = e.inverse ? this.renderer.line(p.Low, f, p.High, f) : this.renderer.line(f, p.Low, f, p.High), this.renderer.attr(b, { fill: x.fillColor, "fill-opacity": e["fill-opacity"], "stroke-opacity": e["fill-opacity"], stroke: x.lineColor, "stroke-width": e["stroke-width"], "stroke-dasharray": e["stroke-dasharray"] }), p.lineElement = b);
                  var N = p.stickElement;
                  if (f -= r / 2, !N) {
                    var M = x.fillColor;
                    p.Close <= p.Open && x.fillColorAlt && (M = x.fillColorAlt), N = e.inverse ? this.renderer.rect(Math.min(p.Open, p.Close), f, Math.abs(p.Close - p.Open), r) : this.renderer.rect(f, Math.min(p.Open, p.Close), r, Math.abs(p.Close - p.Open)), this.renderer.attr(N, { fill: M, "fill-opacity": e["fill-opacity"], "stroke-opacity": e["fill-opacity"], stroke: x.lineColor, "stroke-width": e["stroke-width"], "stroke-dasharray": e["stroke-dasharray"] }), p.stickElement = N;
                  }
                  1 === t && this._installHandlers(N, "column", e.groupIndex, e.seriesIndex, o2);
                }
              }
            }
          }
          _renderScatterSeries(e, t, i) {
            var r = this.seriesGroups[e];
            if (r.series && 0 !== r.series.length) {
              var s = -1 !== r.type.indexOf("bubble"), a = "horizontal" === r.orientation, l = t;
              a && (l = { x: t.y, y: t.x, width: t.height, height: t.width });
              var n = this._calcGroupOffsets(e, l);
              if (n && 0 !== n.xoffsets.length) {
                var o, h = l.width;
                (r.polar || r.spider) && (h = 2 * (o = this._getPolarAxisCoords(e, l)).r);
                var d = this._getGroupGradientType(e);
                i || (i = "to");
                for (let V = 0; V < r.series.length; V++) {
                  var u = this._getSerieSettings(e, V), g = r.series[V];
                  if (!g.customDraw) {
                    var f = g.dataField, p = "function" == typeof g.colorFunction, c = this._getColors(e, V, NaN, d), m = NaN, y = NaN;
                    if (s)
                      for (let t2 = n.xoffsets.first; t2 <= n.xoffsets.last; t2++) {
                        var _ = this._getDataValueAsNumber(t2, g.radiusDataField || g.sizeDataField, e);
                        "number" != typeof _ && this.error(this.localize("invalidRadiusDataField", { index: t2 })), isNaN(_) || ((isNaN(m) || _ < m) && (m = _), (isNaN(y) || _ > y) && (y = _));
                      }
                    var x = g.minRadius || g.minSymbolSize;
                    isNaN(x) && (x = h / 50);
                    var v = g.maxRadius || g.maxSymbolSize;
                    isNaN(v) && (v = h / 25), x > v && (v = x);
                    var b = g.radius;
                    b = isNaN(b) && !isNaN(g.symbolSize) ? "circle" === g.symbolType ? g.symbolSize / 2 : g.symbolSize : 5;
                    var N = this._getAnimProps(e, V), M = N.enabled && !this._isToggleRefresh && n.xoffsets.length < 5e3 ? N.duration : 0, A = { groupIndex: e, seriesIndex: V, symbolType: g.symbolType, symbolSize: g.symbolSize, "fill-opacity": u.opacity, "stroke-opacity": u.opacity, "stroke-width": u.stroke, "stroke-width-symbol": u.strokeSymbol, "stroke-dasharray": u.dashStyle, items: [], polarAxisCoords: o }, w = void 0;
                    for (let r2 = n.xoffsets.first; r2 <= n.xoffsets.last; r2++)
                      if ("number" == typeof this._getDataValueAsNumber(r2, f, e)) {
                        var S = n.xoffsets.data[r2], C = n.xoffsets.xvalues[r2], k = n.offsets[V][r2][i];
                        if (!(k < l.y || k > l.y + l.height || isNaN(S) || isNaN(k))) {
                          if (a) {
                            var D = S;
                            S = k, k = D + t.y;
                          } else
                            S += t.x;
                          if (!(!p && w && this.enableSampling && this.renderer._ptdist(w.x, w.y, S, k) < 1)) {
                            w = { x: S, y: k };
                            var T = b;
                            if (s) {
                              var F = this._getDataValueAsNumber(r2, g.radiusDataField || g.sizeDataField, e);
                              if ("number" != typeof F)
                                continue;
                              T = x + (v - x) * (F - m) / Math.max(1, y - m), isNaN(T) && (T = x);
                            }
                            n.offsets[V][r2].radius = T;
                            var O = NaN, I = NaN, P = 0, R = this._elementRenderInfo;
                            if (null != C && R && R.length > e && R[e].series.length > V) {
                              var L = R[e].series[V][C];
                              if (L && !isNaN(L.to)) {
                                if (O = L.to, I = L.xoffset, P = b, a) {
                                  let e2 = I;
                                  I = O, O = e2 + t.y;
                                } else
                                  I += t.x;
                                s && (P = x + (v - x) * (L.valueRadius - m) / Math.max(1, y - m), isNaN(P) && (P = x));
                              }
                            }
                            p && (c = this._getColors(e, V, r2, d)), A.items.push({ from: P, to: T, itemIndex: r2, fill: c.fillColor, stroke: c.lineColor, x: S, y: k, xFrom: I, yFrom: O });
                          }
                        }
                      }
                    this._animR(A, 0);
                    var G = this;
                    this._enqueueAnimation("series", void 0, void 0, M, function(e2, t2, i2) {
                      G._animR(t2, i2, e2);
                    }, A);
                  }
                }
              }
            }
          }
          _animR(e, t) {
            let i = e.items, r = e.symbolType || "circle", s = e.symbolSize;
            for (let a = 0; a < i.length; a++) {
              let l = i[a], n = l.x, o = l.y, h = Math.round((l.to - l.from) * t + l.from);
              if (isNaN(l.yFrom) || (o = l.yFrom + (o - l.yFrom) * t), isNaN(l.xFrom) || (n = l.xFrom + (n - l.xFrom) * t), e.polarAxisCoords) {
                let t2 = this._toPolarCoord(e.polarAxisCoords, this._plotRect, n, o);
                n = t2.x, o = t2.y;
              }
              n = this.renderer._ptrnd(n), o = this.renderer._ptrnd(o), h = this.renderer._ptrnd(h);
              let d = this._getRenderInfo(e.groupIndex, e.seriesIndex, i[a].itemIndex), u = d.element, g = d.labelElement;
              "circle" === r ? (u || (u = this.renderer.circle(n, o, h), this.renderer.attr(u, { fill: l.fill, "fill-opacity": e["fill-opacity"], "stroke-opacity": e["fill-opacity"], stroke: l.stroke, "stroke-width": e["stroke-width"], "stroke-dasharray": e["stroke-dasharray"] })), this.renderer.attr(u, { r: h, cy: o, cx: n })) : (u && this.renderer.removeElement(u), u = this._drawSymbol(r, n, o, l.fill, e["fill-opacity"], l.stroke, e["stroke-opacity"] || e["fill-opacity"], e["stroke-width-symbol"], e["stroke-dasharray"], s || h)), g && this.renderer.removeElement(g), g = this._showLabel(e.groupIndex, e.seriesIndex, l.itemIndex, { x: n - h, y: o - h, width: 2 * h, height: 2 * h }), t >= 1 && this._installHandlers(u, "circle", e.groupIndex, e.seriesIndex, l.itemIndex), this._setRenderInfo(e.groupIndex, e.seriesIndex, i[a].itemIndex, { element: u, labelElement: g });
            }
          }
          _showMultiSeriesToolTip(e) {
            let t = this, i = "<div style='text-align:left'>", r = "";
            for (let s2 = 0; s2 < t.seriesGroups.length; s2++) {
              if (t._isPieGroup(s2))
                continue;
              let a2 = t._getXAxis(s2), l2 = t._getValueAxis(s2), n2 = t.seriesGroups[s2], o2 = this._getAxisSettings(a2), h = this._getFormatSettings(o2, "toolTipFormatSettings"), d = o2.toolTipFormatFunction, u = t._getDataValue(e, a2.dataField, s2);
              void 0 !== a2.dataField && null !== a2.dataField && "" !== a2.dataField || (u = e), "date" === a2.type && (u = t._castAsDate(u, (h ? h.dateFormat : void 0) || a2.dateFormat)), d || h || "date" !== a2.type || (d = this._getDefaultDTFormatFn(a2.baseUnit || "day"));
              let g = a2.displayText || a2.dataField || "";
              "" !== g && (g += ": ");
              let f = g + t._formatValue(u, h, d, s2, void 0, e);
              r !== f && ("" !== r && (i += "<br />"), i += f + "<br /><br />", r = f);
              for (let r2 = 0; r2 < n2.series.length; r2++) {
                let a3 = n2.series[r2];
                if (false === n2.showToolTips || false === a3.showToolTips)
                  continue;
                if (!t._isSerieVisible(s2, r2))
                  continue;
                let o3 = t._get([t._getFormatSettings(a3, "toolTipFormatSettings"), t._getFormatSettings(n2, "toolTipFormatSettings"), t._getFormatSettings(l2, "toolTipFormatSettings"), t._getFormatSettings(t, "toolTipFormatSettings")]), h2 = t._get([a3.toolTipFormatFunction, n2.toolTipFormatFunction, l2.toolTipFormatFunction, t.toolTipFormatFunction]), d2 = t._getFormattedValue(s2, r2, e, o3, h2);
                i += '<span style="color:' + t._getColors(s2, r2, e).lineColor + ';">' + d2 + "</span><br />\n";
              }
            }
            let s = this._get([t.toolTipClass, "smart-chart-tooltip-text"]), a = this._get([t.toolTipBackground, t._getThemeColor("background")]), l = this._get([t.toolTipLineColor, t._getThemeColor("line")]), n = this._get([t.toolTipOpacity, 1]);
            i += "</div>";
            let o = this.getItemCoord(t._ttEl.gidx, t._ttEl.sidx, t._ttEl.iidx);
            o.x += window.pageXOffset, o.y += window.pageYOffset, t._createTooltip(o, t.seriesGroups[t._ttEl.gidx], i, { css: s, fill: a, stroke: l, fillOpacity: n, symbolSize: 3 });
          }
          _showToolTip(e, t, i, r, s) {
            let a = this, l = a._getXAxis(i), n = a._getValueAxis(i);
            if (a._ttEl && i === a._ttEl.gidx && r === a._ttEl.sidx && s === a._ttEl.iidx)
              return;
            let o = a.seriesGroups[i], h = o.series[r], d = a.enableCrosshairs;
            a._pointMarker ? (e = parseInt(a._pointMarker.x + 5), t = parseInt(a._pointMarker.y - 5)) : d = false;
            let u = d && false === a.showToolTips;
            if (e = this.renderer._ptrnd(e), t = this.renderer._ptrnd(t), false === o.showToolTips || false === h.showToolTips)
              return;
            a._ttEl || (a._ttEl = {}), a._ttEl.sidx = r, a._ttEl.gidx = i, a._ttEl.iidx = s;
            let g = 0;
            for (let e2 = 0; e2 < a.seriesGroups.length; e2++)
              for (let t2 = 0; t2 < a.seriesGroups[e2].series.length; t2++)
                g++;
            if (d) {
              let e2 = this.renderer._ptrnd(a._pointMarker.x), t2 = this.renderer._ptrnd(a._pointMarker.y), r2 = a.crosshairsColor || a._getThemeColor("line");
              if (o.polar || o.spider) {
                let s2 = this._getPolarAxisCoords(i, this._plotRect);
                if (this.renderer._ptdist(e2, t2, s2.x, s2.y) > s2.r)
                  return;
                let l2 = Math.atan2(t2 - s2.y, e2 - s2.x), n2 = Math.cos(l2) * s2.r + s2.x, o2 = Math.sin(l2) * s2.r + s2.y;
                a._ttEl.vLine ? a.renderer.attr(a._ttEl.vLine, { x1: s2.x, y1: s2.y, x2: n2, y2: o2 }) : a._ttEl.vLine = a.renderer.line(s2.x, s2.y, n2, o2, { stroke: r2, "stroke-width": a.crosshairsLineWidth || 1, "stroke-dasharray": a.crosshairsDashStyle || "" });
              } else
                a._ttEl.vLine && a._ttEl.hLine ? (a.renderer.attr(a._ttEl.vLine, { x1: e2, x2: e2 }), a.renderer.attr(a._ttEl.hLine, { y1: t2, y2: t2 })) : (a._ttEl.vLine = a.renderer.line(e2, a._plotRect.y, e2, a._plotRect.y + a._plotRect.height, { stroke: r2, "stroke-width": a.crosshairsLineWidth || 1, "stroke-dasharray": a.crosshairsDashStyle || "" }), a._ttEl.hLine = a.renderer.line(a._plotRect.x, t2, a._plotRect.x + a._plotRect.width, t2, { stroke: r2, "stroke-width": a.crosshairsLineWidth || 1, "stroke-dasharray": a.crosshairsDashStyle || "" }));
            }
            if (a.showToolTipsOnAllSeries && !a._isPieGroup(i) && g > 1)
              return void a._showMultiSeriesToolTip(s);
            let f = a._get([a._getFormatSettings(h, "toolTipFormatSettings"), a._getFormatSettings(o, "toolTipFormatSettings"), a._getFormatSettings(n, "toolTipFormatSettings"), a._getFormatSettings(a, "toolTipFormatSettings")]), p = a._get([h.toolTipFormatFunction, o.toolTipFormatFunction, n.toolTipFormatFunction, a.toolTipFormatFunction]), c = a._getColors(i, r, s), m = a._getDataValue(s, l.dataField, i);
            void 0 !== l.dataField && null !== l.dataField && "" !== l.dataField || (m = s), "date" === l.type && (m = a._castAsDate(m, (f ? f.dateFormat : void 0) || l.dateFormat));
            let y = "";
            if ("function" == typeof p) {
              let e2 = {}, t2 = 0;
              for (let r2 in h)
                0 === r2.indexOf("dataField") && (e2[r2.substring(9, r2.length).toLowerCase()] = a._getDataValue(s, h[r2], i), t2++);
              0 === t2 ? e2 = a._getDataValue(s, void 0, i) : 1 === t2 && (e2 = e2[""]), y = p(e2, s, h, o, m, l);
            } else {
              y = a._getFormattedValue(i, r, s, f, p);
              let e2 = this._getAxisSettings(l), t2 = a._getFormatSettings(e2, "toolTipFormatSettings"), n2 = e2.toolTipFormatFunction;
              n2 || t2 || "date" !== l.type || (n2 = this._getDefaultDTFormatFn(l.baseUnit || "day"));
              let o2 = a._formatValue(m, t2, n2, i, r, s);
              if (a._isPieGroup(i))
                m = a._getDataValue(s, h.displayText || h.dataField, i), o2 = a._formatValue(m, t2, n2, i, r, s), y = o2 + ": " + y;
              else {
                let e3 = l.displayText || l.dataField || "";
                y = e3.length > 0 ? e3 + ": " + o2 + "<br>" + y : o2 + "<br>" + y;
              }
            }
            if (!u && false !== a.showToolTips) {
              let e2 = this._get([h.toolTipClass, o.toolTipClass, a.toolTipClass, "smart-chart-tooltip-text"]), t2 = this._get([h.toolTipBackground, o.toolTipBackground, a.toolTipBackground, a._getThemeColor("background")]), l2 = this._get([h.toolTipLineColor, o.toolTipLineColor, a.toolTipLineColor, c.lineColor, a._getThemeColor("line")]), n2 = this._get([h.toolTipOpacity, o.toolTipOpacity, a.toolTipOpacity, 1]), d2 = this.getItemCoord(i, r, s);
              d2.y = Math.min(Math.max(d2.y, this._plotRect.y), this._plotRect.y + this._plotRect.y + this._plotRect.height);
              let u2 = 0;
              a._pointMarker && a._pointMarker.element && (u2 = h.symbolSizeSelected, isNaN(u2) && (u2 = h.symbolSize), (isNaN(u2) || u2 > 50 || u2 < 0) && (u2 = o.symbolSize), (isNaN(u2) || u2 > 50 || u2 < 0) && (u2 = 8)), a._createTooltip(d2, o, y, { css: e2, fill: t2, stroke: l2, fillOpacity: n2, symbolSize: u2 });
            }
          }
          _fitTooltip(e, t, i, r, s) {
            let a = {}, l = 2 + s / 2;
            if (t.x - i.width - 7 - l > e.x && t.y + t.height / 2 - i.height / 2 > e.y && t.y + t.height / 2 + i.height / 2 < e.y + e.height && (a.left = { arrowLocation: "right", x: t.x - i.width - 7 - l, y: t.y + t.height / 2 - i.height / 2, width: i.width + 7, height: i.height }), t.x + t.width + i.width + 7 + l < e.x + e.width && t.y + t.height / 2 - i.height / 2 > e.y && t.y + t.height / 2 + i.height / 2 < e.y + e.height && (a.right = { arrowLocation: "left", x: t.x + t.width + l, y: t.y + t.height / 2 - i.height / 2, width: i.width + 7, height: i.height }), t.y - i.height - l - 7 > e.y && t.x + t.width / 2 - i.width / 2 > e.x && t.x + t.width / 2 + i.width / 2 < e.x + e.width && (a.top = { arrowLocation: "bottom", x: t.x + t.width / 2 - i.width / 2, y: t.y - i.height - l - 7, width: i.width, height: i.height + 7 }), t.y + t.height + i.height + 7 + l < e.y + e.height && t.x + t.width / 2 - i.width / 2 > e.x && t.x + t.width / 2 + i.width / 2 < e.x + e.width && (a.bottom = { arrowLocation: "top", x: t.x + t.width / 2 - i.width / 2, y: t.y + t.height + l, width: i.width, height: i.height + 7 }), t.width > t.height || (-1 !== r.type.indexOf("stackedcolumn") || -1 !== r.type.indexOf("stackedwaterfall")) && "horizontal" !== r.orientation) {
              if (a.left)
                return a.left;
              if (a.right)
                return a.right;
            } else {
              if (a.top)
                return a.top;
              if (a.bottom)
                return a.bottom;
            }
            for (let e2 in a)
              if (a[e2])
                return a[e2];
            return { arrowLocation: "" };
          }
          _createTooltip(e, t, i, r) {
            const s = this, a = t.type;
            let l = s._ttEl.box;
            if (!l) {
              l = s._ttEl.box = document.createElement("div"), l.id = s.id + "Tooltip", l.className = "smart-chart-tooltip", l.setAttribute("animation", s.animation), l.setAttribute("theme", s.theme), l.setAttribute("role", "tooltip");
              const e2 = document.createElement("div"), t2 = document.createElement("div"), i2 = document.createElement("div");
              if (e2.className = "smart-chart-tooltip-arrow-outer", e2.setAttribute("role", "presentation"), t2.className = "smart-chart-tooltip-arrow-inner", t2.setAttribute("role", "presentation"), i2.className = "smart-chart-tooltip-content", i2.setAttribute("role", "presentation"), l.appendChild(i2), l.appendChild(e2), l.appendChild(t2), s.getRootNode().host ? s.getShadowRootOrBody().appendChild(l) : document.body.appendChild(l), s.hasAttribute("aria-owns")) {
                const e3 = s.getAttribute("aria-owns");
                s.setAttribute("aria-owns", e3 + " " + l.id);
              } else
                s.setAttribute("aria-owns", l.id);
            }
            if (!i || 0 === i.length)
              return void l.classList.add("smart-visibility-hidden");
            s.rightToLeft ? l.setAttribute("right-to-left", "") : l.removeAttribute("right-to-left"), l.classList.add("smart-visibility-hidden");
            const n = l.firstElementChild, o = l.children[1], h = l.children[2];
            h.style.opacity = o.style.opacity = r.fillOpacity, n.style.backgroundColor = r.fill, n.style.borderColor = r.stroke, n.style.opacity = r.fillOpacity;
            const d = '<span class="' + r.css + '" role="presentation">' + i + "</span>";
            n.innerHTML = d;
            const u = s._measureHtml(d), g = s._plotRect;
            if (u.width > g.width || u.height > g.height)
              return;
            let f = { width: u.width, height: u.height }, p = "", c = s._isColumnType(a), m = Math.max(e.x, g.x), y = Math.max(e.y, g.y);
            if (-1 !== a.indexOf("pie") || -1 !== a.indexOf("donut")) {
              let t2 = (e.fromAngle + e.toAngle) / 2;
              t2 *= Math.PI / 180;
              let i2 = !isNaN(e.innerRadius) && e.innerRadius > 0 ? (e.innerRadius + e.outerRadius) / 2 : 0.75 * e.outerRadius;
              m = e.x = e.center.x + Math.cos(t2) * i2, y = e.y = e.center.y - Math.sin(t2) * i2, e.width = e.height = 1;
            } else
              c && (t.polar || t.spider) && (e.width = e.height = 1);
            let _ = this._fitTooltip(this._plotRect, e, f, t, r.symbolSize);
            "" !== _.arrowLocation && (p = _.arrowLocation, m = _.x, y = _.y, f.width = _.width, f.height = _.height), "top" === p || "bottom" === p ? (f.height += 7, m -= 3.5, "bottom" === p && (y -= 7)) : "left" !== p && "right" !== p || (f.width += 7, y -= 3.5, "right" === p && (m -= 7)), m + f.width > g.x + g.width && (p = "", m = g.x + g.width - f.width), y + f.height > g.y + g.height && (p = "", y = g.y + g.height - f.height);
            let x = { x: 0, y: 0 }, v = { x: 0, y: 0 };
            n.style.width = u.width + "px", n.style.height = u.height + "px", o.style["margin-top"] = o.style["margin-left"] = 0, h.style["margin-top"] = h.style["margin-left"] = 0, n.style["margin-top"] = n.style["margin-left"] = 0;
            let b = "7px solid transparent";
            switch (p) {
              case "left":
                x = { x: 0, y: (u.height - 7) / 2 }, v = { x: 7, y: 0 }, n.style["margin-left"] = "7px", o.style["margin-left"] = "0px", o.style["margin-top"] = x.y + "px", o.style["border-left"] = "", o.style["border-right"] = "7px solid " + r.stroke, o.style["border-top"] = b, o.style["border-bottom"] = b, h.style["margin-left"] = "1px", h.style["margin-top"] = x.y + "px", h.style["border-left"] = "", h.style["border-right"] = "7px solid " + r.fill, h.style["border-top"] = b, h.style["border-bottom"] = b;
                break;
              case "right":
                x = { x: f.width - 7, y: (u.height - 7) / 2 }, v = { x: 0, y: 0 }, o.style["margin-left"] = x.x + "px", o.style["margin-top"] = x.y + "px", o.style["border-left"] = "7px solid " + r.stroke, o.style["border-right"] = "", o.style["border-top"] = b, o.style["border-bottom"] = b, h.style["margin-left"] = x.x - 1 + "px", h.style["margin-top"] = x.y + "px", h.style["border-left"] = "7px solid " + r.fill, h.style["border-right"] = "", h.style["border-top"] = b, h.style["border-bottom"] = b;
                break;
              case "top":
                x = { x: f.width / 2 - 3.5, y: 0 }, v = { x: 0, y: 7 }, n.style["margin-top"] = v.y + "px", o.style["margin-left"] = x.x + "px", o.style["border-top"] = "", o.style["border-bottom"] = "7px solid " + r.stroke, o.style["border-left"] = b, o.style["border-right"] = b, h.style["margin-left"] = x.x + "px", h.style["margin-top"] = "1px", h.style["border-top"] = "", h.style["border-bottom"] = "7px solid " + r.fill, h.style["border-left"] = b, h.style["border-right"] = b;
                break;
              case "bottom":
                x = { x: f.width / 2 - 3.5, y: f.height - 7 }, v = { x: 0, y: 0 }, o.style["margin-left"] = x.x + "px", o.style["margin-top"] = x.y + "px", o.style["border-top"] = "7px solid " + r.stroke, o.style["border-bottom"] = "", o.style["border-left"] = b, o.style["border-right"] = b, h.style["margin-left"] = x.x + "px", h.style["margin-top"] = x.y - 1 + "px", h.style["border-top"] = "7px solid " + r.fill, h.style["border-bottom"] = "", h.style["border-left"] = b, h.style["border-right"] = b;
            }
            "" === p ? (o.classList.add("smart-hidden"), h.classList.add("smart-hidden")) : (o.classList.remove("smart-hidden"), h.classList.remove("smart-hidden")), l.style.width = f.width + "px", l.style.height = f.height + "px";
            const N = s.getBoundingClientRect();
            l.style.left = m + N.left + window.pageXOffset + "px", l.style.top = y + N.top + window.pageYOffset + "px", l.classList.remove("smart-visibility-hidden");
          }
          _measureHtml(e) {
            const t = this;
            let i = t._measureDiv;
            i || (t._measureDiv = i = document.createElement("div"), i.className = "smart-chart-tooltip", i.style.position = "absolute", i.style.visibility = "hidden", i.style.left = 0, i.style.top = 0, (t.shadowRoot || t).appendChild(i)), i.innerHTML = e;
            const r = { width: i.offsetWidth + 2, height: i.offsetHeight + 2 };
            return Smart.Utilities.Core.Browser.Firefox && (r.height += 3), r;
          }
          _hideToolTip() {
            this._ttEl && (this._ttEl.box && this._ttEl.box.classList.add("smart-visibility-hidden"), this._hideCrosshairs(), this._ttEl.gidx = void 0);
          }
          _hideCrosshairs() {
            this._ttEl && (this._ttEl.vLine && (this.renderer.removeElement(this._ttEl.vLine), this._ttEl.vLine = void 0), this._ttEl.hLine && (this.renderer.removeElement(this._ttEl.hLine), this._ttEl.hLine = void 0));
          }
          _get(e) {
            return this._draw.getByPriority(e);
          }
          _getAxisSettings(e) {
            if (!e)
              return {};
            let t = this, i = e.gridLines || {}, r = { visible: t._get([i.visible, true]), color: t._get([i.color, t._getThemeColor("line")]), unitInterval: i.unitInterval, step: i.step, dashStyle: i.dashStyle, width: t._get([i.lineWidth, 1]), offsets: [], alternatingBackgroundColor: e.alternatingBackgroundColor, alternatingBackgroundColor2: e.alternatingBackgroundColor2, alternatingBackgroundOpacity: e.alternatingBackgroundOpacity }, s = e.tickMarks || {}, a = { visible: t._get([s.visible, e.showTickMarks, true]), color: t._get([s.color, e.tickMarksColor, t._getThemeColor("line")]), unitInterval: t._get([s.unitInterval, s.interval, e.tickMarksInterval]), step: t._get([s.step, e.tickMarksStep]), dashStyle: t._get([s.dashStyle, e.tickMarksDashStyle]), width: t._get([s.lineWidth, 1]), size: t._get([s.size, 4]), offsets: [] }, l = e.title || {}, n = { visible: t._get([l.visible, true]), text: t._get([e.description, l.text]), style: t._get([e.descriptionClass, l.class, "smart-chart-axis-description"]), halign: t._get([e.horizontalDescriptionAlignment, l.horizontalAlignment, "center"]), valign: t._get([e.verticalDescriptionAlignment, l.verticalAlignment, "center"]), angle: 0, rotationPoint: t._get([l.rotationPoint, "centercenter"]), offset: t._get([l.offset, { x: 0, y: 0 }]) }, o = e.line || {}, h = { visible: t._get([o.visible, true]), color: t._get([o.color, r.color, t._getThemeColor("line")]), dashStyle: t._get([o.dashStyle, r.dashStyle, ""]), width: t._get([o.lineWidth, 1]), angle: t._get([o.angle, NaN]) }, d = e.padding || {};
            d = { left: d.left || 0, right: d.right || 0, top: d.top || 0, bottom: d.bottom || 0 };
            let u = this._getAxisLabelsSettings(e);
            return { visible: this._get([e.visible, true]), customDraw: this._get([e.customDraw, false]), gridLines: r, tickMarks: a, line: h, title: n, labels: u, padding: d, toolTipFormatFunction: this._get([e.toolTipFormatFunction, e.formatFunction, u.formatFunction]), toolTipFormatSettings: this._get([t._getFormatSettings(e, "toolTipFormatSettings"), t._getFormatSettings(e), t._getFormatSettings(u)]) };
          }
          _getAxisLabelsSettings(e) {
            let t = this, i = e.labels || {};
            return { visible: t._get([e.showLabels, i.visible, true]), unitInterval: t._get([i.unitInterval, i.interval, e.labelsInterval]), step: t._get([i.step, e.labelsStep]), angle: t._get([e.textRotationAngle, i.angle, 0]), style: t._get([e.class, i.class, "smart-chart-axis-text"]), halign: t._get([e.horizontalTextAlignment, i.horizontalAlignment, "center"]), valign: t._get([e.verticalTextAlignment, i.verticalAlignment, "center"]), textRotationPoint: t._get([e.textRotationPoint, i.rotationPoint, "auto"]), textOffset: t._get([e.textOffset, i.offset, { x: 0, y: 0 }]), autoRotate: t._get([e.labelsAutoRotate, i.autoRotate, false]), formatSettings: t._get([t._getFormatSettings(e), t._getFormatSettings(i), void 0]), formatFunction: t._get([e.formatFunction, i.formatFunction, void 0]) };
          }
          _getLabelsSettings(e, t, i, r) {
            let s = this.seriesGroups[e], a = s.series[t], l = isNaN(i) ? void 0 : this._getDataValue(i, a.dataField, e), n = r || ["Visible", "Offset", "Angle", "HorizontalAlignment", "VerticalAlignment", "Class", "BackgroundColor", "BorderColor", "BorderOpacity", "Padding", "Opacity", "BackgroundOpacity", "LinesAngles", "LinesEnabled", "AutoRotate", "Radius"], o = {};
            for (let e2 = 0; e2 < n.length; e2++) {
              let t2, r2 = n[e2], h2 = "labels" + r2, d = "label" + r2, u = r2.substring(0, 1).toLowerCase() + r2.substring(1);
              s.labels && "object" == typeof s.labels && (t2 = s.labels[u]), a.labels && "object" == typeof a.labels && void 0 !== a.labels[u] && null !== a.labels[u] && (t2 = a.labels[u]), t2 = this._get([a[h2], a[d], t2, s[h2], s[d]]), o[u] = "function" == typeof t2 ? t2(l, i, a, s) : t2;
            }
            o.class = o.class || "smart-chart-label-text", o.visible = this._get([o.visible, a.showLabels, s.showLabels, void 0 !== a.labels && null !== a.labels || void 0, void 0 !== s.labels && null !== s.labels || void 0]);
            let h = o.padding || 1;
            return o.padding = { left: this._get([h.left, isNaN(h) ? 1 : h]), right: this._get([h.right, isNaN(h) ? 1 : h]), top: this._get([h.top, isNaN(h) ? 1 : h]), bottom: this._get([h.bottom, isNaN(h) ? 1 : h]) }, o;
          }
          _showLabel(e, t, i, r, s, a, l, n, o, h, d) {
            let u = { width: 0, height: 0 };
            if (isNaN(i))
              return;
            let g = this._getLabelsSettings(e, t, i);
            if (!g.visible)
              return l ? u : void 0;
            if (r.width < 0 || r.height < 0)
              return l ? u : void 0;
            let f = g.angle;
            isNaN(h) || (f = h);
            let p = g.offset || {}, c = { x: p.x, y: p.y };
            isNaN(c.x) && (c.x = 0), isNaN(c.y) && (c.y = 0), s = s || g.horizontalAlignment || "center", a = a || g.verticalAlignment || "center";
            let m = this._getFormattedValue(e, t, i, void 0, void 0, true), y = r.width, _ = r.height;
            if (true === n && "center" !== s && (s = "right" === s ? "left" : "right"), true === o && "center" !== a && "middle" !== a && (a = "top" === a ? "bottom" : "top", c.y *= -1), u = this.renderer.measureText(m, f, { class: g.class }), l)
              return u;
            let x = 0, v = 0;
            y > 0 && ("" === s || "center" === s ? x += (y - u.width) / 2 : "right" === s && (x += y - u.width)), _ > 0 && ("" === a || "center" === a ? v += (_ - u.height) / 2 : "bottom" === a && (v += _ - u.height)), x += r.x + c.x, v += r.y + c.y;
            let b = this._plotRect;
            x <= b.x && (x = b.x + 2), v <= b.y && (v = b.y + 2);
            let N, M = Math.max(u.width, 1), A = Math.max(u.height, 1);
            v + A >= b.y + b.height && (v = b.y + b.height - A - 2), x + M >= b.x + b.width && (x = b.x + b.width - M - 2);
            let w = g.backgroundColor, S = g.borderColor, C = g.padding;
            (w || S) && (N = this.renderer.beginGroup(), this.renderer.rect(x - C.left, v - C.top, u.width + C.left + C.right, u.height + C.bottom + C.bottom, { fill: w || "transparent", "fill-opacity": g.backgroundOpacity || 1, stroke: S || "transparent", "stroke-opacity": g.borderOpacity, "stroke-width": 1 }));
            let k = this.renderer.text(m, x, v, u.width, u.height, f, { class: g.class, opacity: g.opacity || 1 }, false, "center", "center", void 0, arguments[11]);
            return d && (d.x = x - C.left, d.y = v - C.top, d.width = u.width + C.left + C.right, d.height = u.height + C.bottom + C.bottom), N && this.renderer.endGroup(), N || k;
          }
          _getAnimProps(e, t) {
            let i = this.seriesGroups[e], r = isNaN(t) ? void 0 : i.series[t], s = this.hasAnimation;
            i.animation && (s = "none" !== i.animation), r && r.animation && (s = "none" !== r.animation);
            let a = this.animationDuration;
            isNaN(a) && (a = 1e3);
            let l = i.animationDuration;
            if (isNaN(l) || (a = l), r) {
              let e2 = r.animationDuration;
              isNaN(e2) || (a = e2);
            }
            return a > 5e3 && (a = 1e3), { enabled: s, duration: a };
          }
          _isColorTransition(e, t, i, r) {
            if (r - 1 < i.xoffsets.first)
              return false;
            let s = this._getColors(e, t, r, this._getGroupGradientType(e)), a = this._getColors(e, t, r - 1, this._getGroupGradientType(e));
            return s.fillColor !== a.fillColor;
          }
          _renderLineSeries(e, t) {
            var i = this.seriesGroups[e];
            if (i.series && 0 !== i.series.length) {
              var r = -1 !== i.type.indexOf("area"), s = -1 !== i.type.indexOf("stacked"), a = s && -1 !== i.type.indexOf("100"), l = -1 !== i.type.indexOf("spline"), n = -1 !== i.type.indexOf("step"), o = -1 !== i.type.indexOf("range"), h = true === i.polar || true === i.spider;
              if (h && (n = false), !n || !l) {
                var d = "horizontal" === i.orientation, u = true === this._getXAxis(e).flip, g = t;
                d && (g = { x: t.y, y: t.x, width: t.height, height: t.width });
                var f = this._calcGroupOffsets(e, g);
                if (f && 0 !== f.xoffsets.length) {
                  this._linesRenderInfo || (this._linesRenderInfo = {}), this._linesRenderInfo[e] = {};
                  for (let t2 = i.series.length - 1; t2 >= 0; t2--) {
                    var p = this._getSerieSettings(e, t2), c = { groupIndex: e, rect: g, serieIndex: t2, swapXY: d, isArea: r, isSpline: l, isRange: o, isPolar: h, settings: p, segments: [], pointsLength: 0 };
                    if (this._isSerieVisible(e, t2)) {
                      var m = i.series[t2];
                      if (!m.customDraw) {
                        var y, _ = "function" == typeof m.colorFunction, x = f.xoffsets.first, v = x, b = this._getColors(e, t2, NaN, this._getGroupGradientType(e));
                        do {
                          var N = [], M = [], A = [], w = 0, S = 0, C = NaN, k = NaN, D = NaN;
                          if (!(f.xoffsets.length < 1)) {
                            var T = this._getAnimProps(e, t2), F = T.enabled && !this._isToggleRefresh && f.xoffsets.length < 1e4 && T.duration, O = x;
                            y = false;
                            var I = void 0;
                            for (let s2 = x; s2 <= f.xoffsets.last; s2++) {
                              x = s2;
                              var P = f.xoffsets.data[s2], R = f.xoffsets.xvalues[s2];
                              if (!(isNaN(P) || (w = P = Math.max(P, 1), S = f.offsets[t2][s2].to, !_ && I && this.enableSampling && this.renderer._ptdist(I.x, I.y, w, S) < 1))) {
                                I = { x: w, y: S };
                                var L = f.offsets[t2][s2].from;
                                if (isNaN(S) || isNaN(L)) {
                                  if ("connect" === m.emptyPointsDisplay)
                                    continue;
                                  if ("zero" !== m.emptyPointsDisplay) {
                                    y = true;
                                    break;
                                  }
                                  isNaN(S) && (S = f.baseOffset), isNaN(L) && (L = f.baseOffset);
                                }
                                if (_ && this._isColorTransition(e, t2, f, x) && N.length > 1) {
                                  x--;
                                  break;
                                }
                                var G = this._elementRenderInfo;
                                if (G && G.length > e && G[e].series.length > t2) {
                                  var V = G[e].series[t2][R];
                                  let i2 = this.renderer._ptrnd(V ? V.to : void 0), r2 = this.renderer._ptrnd(g.x + (V ? V.xoffset : void 0));
                                  A.push(d ? { y: r2, x: i2, index: s2 } : { x: r2, y: i2, index: s2 });
                                }
                                v = s2, p.stroke < 2 && (S - g.y <= 1 && (S = g.y + 1), L - g.y <= 1 && (L = g.y + 1), g.y + g.height - S <= 1 && (S = g.y + g.height - 1), g.y + g.height - L <= 1 && (L = g.y + g.height - 1)), !r && a && (S <= g.y && (S = g.y + 1), S >= g.y + g.height && (S = g.y + g.height - 1), L <= g.y && (L = g.y + 1), L >= g.y + g.height && (L = g.y + g.height - 1)), w = (P = Math.max(P, 1)) + g.x, true === i.skipOverlappingPoints && !isNaN(C) && Math.abs(C - w) <= 1 || (!n || isNaN(C) || isNaN(k) || k !== S && N.push(d ? { y: w, x: this.renderer._ptrnd(k) } : { x: w, y: this.renderer._ptrnd(k) }), N.push(d ? { y: w, x: this.renderer._ptrnd(S), index: s2 } : { x: w, y: this.renderer._ptrnd(S), index: s2 }), M.push(d ? { y: w, x: this.renderer._ptrnd(L), index: s2 } : { x: w, y: this.renderer._ptrnd(L), index: s2 }), C = w, k = S, isNaN(D) && (D = S));
                              }
                            }
                            if (0 !== N.length) {
                              var E = N[N.length - 1].index;
                              _ && (b = this._getColors(e, t2, E, this._getGroupGradientType(e)));
                              var B = g.x + f.xoffsets.data[O], H = g.x + f.xoffsets.data[v];
                              if (r && true === i.alignEndPointsWithIntervals && (B > g.x && (B = g.x), H < g.x + g.width && (H = g.x + g.width), u)) {
                                var z = B;
                                B = H, H = z;
                              }
                              H = this.renderer._ptrnd(H), B = this.renderer._ptrnd(B);
                              var W = f.baseOffset;
                              D = this.renderer._ptrnd(D);
                              var j = this.renderer._ptrnd(S) || W;
                              o && (N = N.concat(M.reverse())), c.pointsLength += N.length;
                              var X = { lastItemIndex: E, colorSettings: b, pointsArray: N, pointsStart: A, left: B, right: H, pyStart: D, pyEnd: j, yBase: W, labelElements: [], symbolElements: [] };
                              c.segments.push(X);
                            } else
                              x++;
                          }
                        } while (x < f.xoffsets.first + f.xoffsets.length - 1 || y);
                        this._linesRenderInfo[e][t2] = c;
                      }
                    } else
                      this._linesRenderInfo[e][t2] = c;
                  }
                  var U = this._linesRenderInfo[e], Y = [];
                  for (let e2 in U)
                    Y.push(U[e2]);
                  Y = Y.sort(function(e2, t2) {
                    return e2.serieIndex - t2.serieIndex;
                  }), r && s && Y.reverse();
                  for (let e2 = 0; e2 < Y.length; e2++) {
                    let t2 = Y[e2];
                    this._animateLine(t2, 0 === F ? 1 : 0);
                    var q = this;
                    this._enqueueAnimation("series", void 0, void 0, F, function(e3, t3, i2) {
                      q._animateLine(t3, i2);
                    }, t2);
                  }
                }
              }
            }
          }
          _animateLine(e, t) {
            let i = e.settings, r = e.groupIndex, s = e.serieIndex, a = this.seriesGroups[r], l = a.series[s], n = this._getSymbol(r, s), o = this._getLabelsSettings(r, s, NaN, ["Visible"]).visible, h = true;
            e.isPolar && (isNaN(a.endAngle) || 360 === Math.round(Math.abs((isNaN(a.startAngle) ? 0 : a.startAngle) - a.endAngle)) || (h = false)), false === l.endPointsConnect && (h = false);
            let d = 0;
            for (let a2 = 0; a2 < e.segments.length; a2++) {
              let u = e.segments[a2], g = this._calculateLine(r, e.pointsLength, d, u.pointsArray, u.pointsStart, u.yBase, t, e.isArea, e.swapXY);
              if (d += u.pointsArray.length, "" === g)
                continue;
              let f = g.split(" "), p = g;
              p = "" !== p ? this._buildLineCmd(g, e.isRange, u.left, u.right, u.pyStart, u.pyEnd, u.yBase, e.isArea, e.isPolar, h, e.isSpline, e.swapXY) : "M 0 0";
              let c = u.colorSettings;
              if (u.pathElement ? this.renderer.attr(u.pathElement, { d: p }) : (u.pathElement = this.renderer.path(p, { "stroke-width": i.stroke, stroke: c.lineColor, "stroke-opacity": i.opacity, "fill-opacity": i.opacity, "stroke-dasharray": i.dashStyle, fill: e.isArea ? c.fillColor : "none" }), this._installHandlers(u.pathElement, "path", r, s, u.lastItemIndex)), u.labelElements) {
                for (let e2 = 0; e2 < u.labelElements.length; e2++)
                  this.renderer.removeElement(u.labelElements[e2]);
                u.labelElements = [];
              }
              if (u.symbolElements) {
                for (let e2 = 0; e2 < u.symbolElements.length; e2++)
                  this.renderer.removeElement(u.symbolElements[e2]);
                u.symbolElements = [];
              }
              if (u.pointsArray.length === f.length && ("none" !== n || o)) {
                let e2 = l.symbolSize, t2 = this._plotRect;
                for (let a3 = 0; a3 < f.length; a3++) {
                  let l2 = f[a3].split(",");
                  if (l2 = { x: parseFloat(l2[0]), y: parseFloat(l2[1]) }, !(l2.x < t2.x || l2.x > t2.x + t2.width || l2.y < t2.y || l2.y > t2.y + t2.height)) {
                    if ("none" !== n) {
                      let t3 = this._getColors(r, s, u.pointsArray[a3].index, this._getGroupGradientType(r)), o2 = this._drawSymbol(n, l2.x, l2.y, t3.fillColorSymbol, i.opacity, t3.lineColorSymbol, i.opacity, i.strokeSymbol, void 0, e2);
                      u.symbolElements.push(o2);
                    }
                    if (o && (l2 = this._adjustLineLabelPosition(r, s, u.pointsArray[a3].index, l2), l2)) {
                      let e3 = this._showLabel(r, s, u.pointsArray[a3].index, { x: l2.x, y: l2.y, width: 0, height: 0 });
                      u.labelElements.push(e3);
                    }
                  }
                }
              }
              if (1 === t && "none" !== n)
                for (let e2 = 0; e2 < u.symbolElements.length; e2++)
                  isNaN(u.pointsArray[e2].index) || this._installHandlers(u.symbolElements[e2], "symbol", r, s, u.pointsArray[e2].index);
            }
          }
          _adjustLineLabelPosition(e, t, i, r) {
            let s = this._showLabel(e, t, i, { width: 0, height: 0 }, "", "", true);
            if (!s)
              return;
            let a = { x: r.x - s.width / 2, y: 0 };
            return a.y = r.y - 1.5 * s.height, a;
          }
          _calculateLine(e, t, i, r, s, a, l, n, o) {
            let h, d = this.seriesGroups[e];
            true !== d.polar && true !== d.spider || (h = this._getPolarAxisCoords(e, this._plotRect));
            let u = "", g = r.length;
            n || 0 !== s.length || (g = t * l - i);
            for (let e2 = 0; e2 < g + 1 && e2 < r.length; e2++) {
              e2 > 0 && (u += " ");
              let t2 = r[e2].y, i2 = r[e2].x, d2 = n ? a : t2, f = i2;
              if (s && s.length > e2 && (d2 = s[e2].y, f = s[e2].x, (isNaN(d2) || isNaN(f)) && (d2 = t2, f = i2)), g <= r.length && e2 > 0 && e2 === g && (f = r[e2 - 1].x, d2 = r[e2 - 1].y), o ? (i2 = this.renderer._ptrnd((i2 - d2) * (n ? l : 1) + d2), t2 = this.renderer._ptrnd(t2)) : (i2 = this.renderer._ptrnd((i2 - f) * l + f), t2 = this.renderer._ptrnd((t2 - d2) * l + d2)), h) {
                let e3 = this._toPolarCoord(h, this._plotRect, i2, t2);
                i2 = e3.x, t2 = e3.y;
              }
              u += i2 + "," + t2;
            }
            return u;
          }
          _buildLineCmd(e, t, i, r, s, a, l, n, o, h, d, u) {
            let g = e, f = u ? l + "," + i : i + "," + l;
            !n || o || t || (g = f + " " + e + " " + (u ? l + "," + r : r + "," + l)), d && (g = this._getBezierPoints(g));
            let p = g.split(" ");
            if (0 === p.length)
              return "";
            if (1 === p.length) {
              let e2 = p[0].split(",");
              return "M " + p[0] + " L" + (parseFloat(e2[0]) + 1) + "," + (parseFloat(e2[1]) + 1);
            }
            let c = p[0].replace("M", "");
            return n && !o ? g = t ? "M " + c + " L " + c + (d ? "" : " L " + c + " ") + g : "M " + f + " L " + c + " " + g : d || (g = "M " + c + " L " + c + " " + g), (o && h || t) && (g += " Z"), g;
          }
          _getSerieSettings(e, t) {
            let i = this.seriesGroups[e], r = -1 !== i.type.indexOf("area"), s = -1 !== i.type.indexOf("line"), a = i.series[t], l = a.dashStyle || i.dashStyle || "", n = a.opacity || i.opacity;
            (isNaN(n) || n < 0 || n > 1) && (n = 1);
            let o = a.lineWidth;
            isNaN(o) && "auto" !== o && (o = i.lineWidth), ("auto" === o || isNaN(o) || o < 0 || o > 15) && (o = r ? 2 : s ? 3 : 1);
            let h = a.lineWidthSymbol;
            return isNaN(h) && (h = 1), { stroke: o, strokeSymbol: h, opacity: n, dashStyle: l };
          }
          _getColors(e, t, i, r, s) {
            let a = this.seriesGroups[e], l = a.series[t], n = this._get([l.useGradientColors, a.useGradientColors, false]), o = this._getSeriesColors(e, t, i), h = [[0, 1.4], [100, 1]], d = [[0, 1], [25, 1.1], [50, 1.4], [100, 1]], u = [[0, 1.3], [90, 1.2], [100, 1]], g = NaN;
            if (isNaN(s) || (g = 2 === s ? h : d), n) {
              let s2 = {};
              for (let e2 in o)
                s2[e2] = o[e2];
              if (o = s2, "verticalLinearGradient" === r || "horizontalLinearGradient" === r) {
                let e2 = "verticalLinearGradient" === r ? g || h : g || d, t2 = ["fillColor", "fillColorSelected", "fillColorAlt", "fillColorAltSelected"];
                for (let i2 in t2) {
                  let s3 = o[t2[i2]];
                  s3 && (o[t2[i2]] = this.renderer._toLinearGradient(s3, "verticalLinearGradient" === r, e2));
                }
              } else if ("radialGradient" === r) {
                let r2, s3 = h;
                ("pie" === a.type || "donut" === a.type || a.polar) && null != i && this._renderData[e] && this._renderData[e].offsets[t] && (r2 = this._renderData[e].offsets[t][i], s3 = u), o.fillColor = this.renderer._toRadialGradient(o.fillColor, s3, r2), o.fillColorSelected = this.renderer._toRadialGradient(o.fillColorSelected, s3, r2);
              }
            }
            return o;
          }
          _installHandlers(e, t, i, r, s) {
            if (!this.enableEvents)
              return false;
            var a = this, l = this.seriesGroups[i], n = this.seriesGroups[i].series[r], o = -1 !== l.type.indexOf("line") || -1 !== l.type.indexOf("area");
            o || false === l.enableSelection || false === n.enableSelection || this.renderer.addHandler(e, "mousemove", function() {
              var e2 = a._selected;
              e2 && e2.isLineType && "click" === e2.linesUnselectMode && (e2.group !== i || e2.series !== r) || a._ttEl && a._ttEl.gidx === i && a._ttEl.sidx === r && a._ttEl.iidx === s || a._startTooltipTimer(i, r, s);
            }), false !== l.enableSelection && false !== n.enableSelection && this.renderer.addHandler(e, "mouseover", function() {
              var l2 = a._selected;
              l2 && l2.isLineType && "click" === l2.linesUnselectMode && (l2.group !== i || l2.series !== r) || a._select(e, t, i, r, s, s);
            }), this.renderer.addHandler(e, "click", function(e2) {
              clearTimeout(a._hostClickTimer), a._lastClickTs = (/* @__PURE__ */ new Date()).valueOf(), o && "symbol" !== t && "pointMarker" !== t || (a._isColumnType(l.type) && a._unselect(), isNaN(s) || (e2.stopImmediatePropagation(), a._raiseItemEvent("click", l, n, s)));
            });
          }
          _getHorizontalOffset(e, t, i, r) {
            let s = this._plotRect;
            if (0 === this._getDataLen(e))
              return { index: void 0, value: i };
            let a = this._calcGroupOffsets(e, this._plotRect);
            if (0 === a.xoffsets.length)
              return { index: void 0, value: void 0 };
            let l, n, o, h, d, u = i, g = r, f = this.seriesGroups[e];
            (f.polar || f.spider) && (l = this._getPolarAxisCoords(e, s));
            for (let e2 = a.xoffsets.first; e2 <= a.xoffsets.last; e2++) {
              let i2 = a.xoffsets.data[e2], r2 = a.offsets[t][e2].to, p = 0;
              if (l) {
                let e3 = this._toPolarCoord(l, s, i2 + s.x, r2);
                i2 = e3.x, r2 = e3.y, p = this.renderer._ptdist(u, g, i2, r2);
              } else if ("horizontal" === f.orientation) {
                i2 += s.y;
                let e3 = r2;
                r2 = i2, i2 = e3, p = this.renderer._ptdist(u, g, i2, r2);
              } else
                i2 += s.x, p = Math.abs(u - i2);
              (isNaN(n) || n > p) && (n = p, o = e2, h = i2, d = r2);
            }
            return { index: o, value: a.xoffsets.data[o], polarAxisCoords: l, x: h, y: d };
          }
          onmousemove(e, t) {
            if (this._mouseX === e && this._mouseY === t)
              return;
            if (this._mouseX = e, this._mouseY = t, !this._selected)
              return;
            let i = this._selected.group, r = this._selected.series, s = this.seriesGroups[i], a = s.series[r], l = this._plotRect;
            if (this.renderer && (l = this.renderer.getRect(), l.x += 5, l.y += 5, l.width -= 10, l.height -= 10), e < l.x + window.scrollX || e > l.x + l.width + window.scrollX || t < l.y + window.scrollY || t > l.y + l.height + window.scrollY)
              return this._hideToolTip(), void this._unselect();
            let n = "horizontal" === s.orientation;
            if (l = this._plotRect, -1 !== s.type.indexOf("line") || -1 !== s.type.indexOf("area")) {
              let o = this._getHorizontalOffset(i, this._selected.series, e, t), h = o.index;
              if (null == h)
                return;
              if (this._selected.item !== h) {
                let e2 = this._linesRenderInfo[i][r].segments, t2 = 0;
                for (; h > e2[t2].lastItemIndex; )
                  if (t2++, t2 >= e2.length)
                    return;
                let s2 = e2[t2].pathElement, a2 = e2[t2].lastItemIndex;
                this._unselect(false), this._select(s2, "path", i, r, h, a2);
              }
              let d = this._getSymbol(this._selected.group, this._selected.series);
              "none" === d && (d = "circle");
              let u = this._calcGroupOffsets(i, l), g = u.offsets[this._selected.series][h].to, f = g;
              -1 !== s.type.indexOf("range") && (f = u.offsets[this._selected.series][h].from);
              let p = n ? e : t;
              if (t = !isNaN(f) && Math.abs(p - f) < Math.abs(p - g) ? f : g, isNaN(t))
                return;
              if (e = o.value, n) {
                let i2 = e;
                e = t, t = i2 + l.y;
              } else
                e += l.x;
              if (o.polarAxisCoords && (e = o.x, t = o.y), t = this.renderer._ptrnd(t), e = this.renderer._ptrnd(e), this._pointMarker && this._pointMarker.element && (this.renderer.removeElement(this._pointMarker.element), this._pointMarker.element = void 0), isNaN(e) || isNaN(t))
                return;
              let c = this._getSeriesColors(i, r, h), m = this._getSerieSettings(i, r), y = a.symbolSizeSelected;
              isNaN(y) && (y = a.symbolSize), (isNaN(y) || y > 50 || y < 0) && (y = s.symbolSize), (isNaN(y) || y > 50 || y < 0) && (y = 8), (this.showToolTips || this.enableCrosshairs) && (this._pointMarker = { type: d, x: e, y: t, gidx: i, sidx: r, iidx: h }, this._pointMarker.element = this._drawSymbol(d, e, t, c.fillColorSymbolSelected, m.opacity, c.lineColorSymbolSelected, m.opacity, m.strokeSymbol, m.dashStyle, y), this._installHandlers(this._pointMarker.element, "pointMarker", i, r, h)), this._startTooltipTimer(i, this._selected.series, h);
            }
          }
          _drawSymbol(e, t, i, r, s, a, l, n, o, h) {
            let d, u, g = h || 6, f = g / 2;
            switch (e) {
              case "none":
                return;
              case "circle":
                d = this.renderer.circle(t, i, g / 2);
                break;
              case "square":
                g -= 1, f = g / 2, d = this.renderer.rect(t - f, i - f, g, g);
                break;
              case "diamond":
                u = "M " + (t - f) + "," + i + " L" + t + "," + (i - f) + " L" + (t + f) + "," + i + " L" + t + "," + (i + f) + " Z", d = this.renderer.path(u);
                break;
              case "triangle_up":
              case "triangle":
                u = "M " + (t - f) + "," + (i + f) + " L " + (t + f) + "," + (i + f) + " L " + t + "," + (i - f) + " Z", d = this.renderer.path(u);
                break;
              case "triangle_down":
                u = "M " + (t - f) + "," + (i - f) + " L " + t + "," + (i + f) + " L " + (t + f) + "," + (i - f) + " Z", d = this.renderer.path(u);
                break;
              case "triangle_left":
                u = "M " + (t - f) + "," + i + " L " + (t + f) + "," + (i + f) + " L " + (t + f) + "," + (i - f) + " Z", d = this.renderer.path(u);
                break;
              case "triangle_right":
                u = "M " + (t - f) + "," + (i - f) + " L " + (t - f) + "," + (i + f) + " L " + (t + f) + "," + i + " Z", d = this.renderer.path(u);
                break;
              default:
                d = this.renderer.circle(t, i, g);
            }
            return this.renderer.attr(d, { fill: r, "fill-opacity": s, stroke: a, "stroke-width": n, "stroke-opacity": l, "stroke-dasharray": o || "" }), "circle" !== e && (this.renderer.attr(d, { r: g / 2 }), "square" !== e && this.renderer.attr(d, { x: t, y: i })), d;
          }
          _getSymbol(e, t) {
            let i, r = ["circle", "square", "diamond", "triangle_up", "triangle_down", "triangle_left", "triangle_right"], s = this.seriesGroups[e], a = s.series[t];
            return void 0 !== a.symbolType && null !== a.symbolType && (i = a.symbolType), null == i && (i = s.symbolType), "default" === i ? r[t % r.length] : null != i ? i : "none";
          }
          _startTooltipTimer(e, t, i, r, s, a, l) {
            this._cancelTooltipTimer();
            let n = this, o = this.toolTipShowDelay;
            (isNaN(o) || o > 1e4 || o < 0) && (o = 500), (this._ttEl || true === this.enableCrosshairs && false === this.showToolTips) && (o = 0), isNaN(a) || (o = a), clearTimeout(this._tttimerHide), isNaN(r) && (r = n._mouseX), isNaN(s) && (s = n._mouseY - 3), 0 === o && n._showToolTip(r, s, e, t, i), this._tttimer = setTimeout(function() {
              0 !== o && n._showToolTip(r, s, e, t, i);
              let a2 = n.toolTipHideDelay;
              isNaN(l) || (a2 = l), isNaN(a2) && (a2 = 4e3), n._tttimerHide = setTimeout(function() {
                n._hideToolTip(), n._unselect();
              }, a2);
            }, o);
          }
          _cancelTooltipTimer() {
            clearTimeout(this._tttimer);
          }
          _getGroupGradientType(e) {
            let t = this.seriesGroups[e];
            return -1 !== t.type.indexOf("area") ? "horizontal" === t.orientation ? "horizontalLinearGradient" : "verticalLinearGradient" : this._isColumnType(t.type) || -1 !== t.type.indexOf("candle") ? t.polar ? "radialGradient" : "horizontal" === t.orientation ? "verticalLinearGradient" : "horizontalLinearGradient" : -1 !== t.type.indexOf("scatter") || -1 !== t.type.indexOf("bubble") || this._isPieGroup(e) ? "radialGradient" : void 0;
          }
          _select(e, t, i, r, s, a) {
            if (this._selected) {
              if (this._selected.item === s && this._selected.series === r && this._selected.group === i)
                return;
              this._unselect();
            }
            let l = this.seriesGroups[i], n = l.series[r];
            if (false === l.enableSelection || false === n.enableSelection)
              return;
            let o = -1 !== l.type.indexOf("line") && -1 === l.type.indexOf("area");
            this._selected = { element: e, type: t, group: i, series: r, item: s, iidxBase: a, isLineType: o, linesUnselectMode: n.linesUnselectMode || l.linesUnselectMode };
            let h = this._getColors(i, r, a || s, this._getGroupGradientType(i)), d = h.fillColorSelected;
            o && (d = "none");
            let u = this._getSerieSettings(i, r), g = "symbol" === t ? h.lineColorSymbolSelected : h.lineColorSelected;
            d = "symbol" === t ? h.fillColorSymbolSelected : d;
            let f = "symbol" === t ? 1 : u.stroke;
            "symbol" !== t && this.renderer.getAttr(e, "fill") === h.fillColorAlt && (d = h.fillColorAltSelected), this.renderer.attr(e, { stroke: g, fill: d, "stroke-width": f }), -1 === l.type.indexOf("pie") && -1 === l.type.indexOf("donut") || this._applyPieSelect(), this._raiseItemEvent("mouseover", l, n, s), this._isTouchDevice && this._startTooltipTimer(i, r, s);
          }
          _applyPieSelect() {
            var e = this;
            e._createAnimationGroup("animPieSlice");
            var t = this._selected;
            if (t) {
              var i = this.getItemCoord(t.group, t.series, t.item);
              if (i) {
                var r = { element: this._getRenderInfo(t.group, t.series, t.item), coord: i };
                this._enqueueAnimation("animPieSlice", void 0, void 0, 300, function(i2, r2, s) {
                  var a = r2.coord, l = a.selectedRadiusChange * s, n = e.renderer.pieSlicePath(a.center.x, a.center.y, 0 === a.innerRadius ? 0 : a.innerRadius + l, a.outerRadius + l, a.fromAngle, a.toAngle, a.centerOffset);
                  e.renderer.attr(r2.element.element, { d: n }), e._showPieLabel(t.group, t.series, t.item, void 0, l, r2.element.colors.lineColor);
                }, r), e._startAnimation("animPieSlice");
              }
            }
          }
          _applyPieUnselect() {
            this._stopAnimations();
            let e = this._selected;
            if (!e)
              return;
            let t = this.getItemCoord(e.group, e.series, e.item);
            if (!t || !t.center)
              return;
            let i = this.renderer.pieSlicePath(t.center.x, t.center.y, t.innerRadius, t.outerRadius, t.fromAngle, t.toAngle, t.centerOffset);
            this.renderer.attr(e.element, { d: i }), this._showPieLabel(e.group, e.series, e.item, void 0, 0, this._getRenderInfo(e.group, e.series, e.item).colors.lineColor);
          }
          _unselect() {
            let e = this;
            if (e._selected) {
              let t = e._selected.group, i = e._selected.series, r = e._selected.item, s = e._selected.iidxBase, a = e._selected.type, l = e.seriesGroups[t], n = l.series[i], o = -1 !== l.type.indexOf("line") && -1 === l.type.indexOf("area"), h = e._getColors(t, i, s || r, e._getGroupGradientType(t)), d = h.fillColor;
              o && (d = "none");
              let u = e._getSerieSettings(t, i), g = "symbol" === a ? h.lineColorSymbol : h.lineColor;
              d = "symbol" === a ? h.fillColorSymbol : d, "symbol" !== a && this.renderer.getAttr(e._selected.element, "fill") === h.fillColorAltSelected && (d = h.fillColorAlt);
              let f = "symbol" === a ? 1 : u.stroke;
              e.renderer.attr(e._selected.element, { stroke: g, fill: d, "stroke-width": f }), -1 === l.type.indexOf("pie") && -1 === l.type.indexOf("donut") || this._applyPieUnselect(), e._selected = void 0, isNaN(r) || e._raiseItemEvent("mouseout", l, n, r);
            }
            e._pointMarker && (e._pointMarker.element && (e.renderer.removeElement(e._pointMarker.element), e._pointMarker.element = void 0), e._pointMarker = void 0, e._hideCrosshairs());
          }
          _raiseItemEvent(e, t, i, r) {
            let s = i[e] || t[e], a = 0;
            for (; a < this.seriesGroups.length && this.seriesGroups[a] !== t; a++)
              ;
            if (a === this.seriesGroups.length)
              return;
            let l = { event: e, seriesGroup: t, serie: i, elementIndex: r, elementValue: this._getDataValue(r, i.dataField, a) };
            s && "function" == typeof s && s(l), this.$.fireEvent(e, l);
          }
          _calcInterval(e, t, i) {
            let r = Math.abs(t - e) / i, s = 0.1, a = [1, 2, 3, 4, 5, 10, 15, 20, 25, 50, 100];
            r < 1 && (a = [0.5, 0.25, 0.125, 0.1], s = 10);
            let l = 0;
            do {
              l = 0, r >= 1 ? s *= 10 : s /= 10;
              for (let e2 = 1; e2 < a.length && Math.abs(a[l] * s - r) > Math.abs(a[e2] * s - r); e2++)
                l = e2;
            } while (l === a.length - 1);
            return a[l] * s;
          }
          _renderDataClone() {
            if (!this._renderData || this._isToggleRefresh)
              return;
            let e = this._elementRenderInfo = [];
            if (!this._isSelectorRefresh)
              for (let t = 0; t < this._renderData.length; t++) {
                for (; e.length <= t; )
                  e.push({});
                let i = e[t], r = this._renderData[t];
                if (!r.offsets)
                  continue;
                if (r.valueAxis) {
                  i.valueAxis = { itemOffsets: {} };
                  for (let e2 in r.valueAxis.itemOffsets)
                    i.valueAxis.itemOffsets[e2] = r.valueAxis.itemOffsets[e2];
                }
                if (r.xAxis) {
                  i.xAxis = { itemOffsets: {} };
                  for (let e2 in r.xAxis.itemOffsets)
                    i.xAxis.itemOffsets[e2] = r.xAxis.itemOffsets[e2];
                }
                i.series = [];
                let s = i.series, a = this._isPieGroup(t);
                for (let e2 = 0; e2 < r.offsets.length; e2++) {
                  s.push({});
                  for (let i2 = 0; i2 < r.offsets[e2].length; i2++)
                    if (a) {
                      let t2 = r.offsets[e2][i2];
                      s[e2][t2.displayValue] = { value: t2.value, x: t2.x, y: t2.y, fromAngle: t2.fromAngle, toAngle: t2.toAngle };
                    } else
                      r.xoffsets ? s[e2][r.xoffsets.xvalues[i2]] = { value: r.offsets[e2][i2].value, valueRadius: r.offsets[e2][i2].valueRadius, xoffset: r.xoffsets.data[i2], from: r.offsets[e2][i2].from, to: r.offsets[e2][i2].to } : (r.xoffsets = this._calculateXOffsets(t, this._plotRect.width), r.xoffsets && (s[e2][r.xoffsets.xvalues[i2]] = { value: r.offsets[e2][i2].value, valueRadius: r.offsets[e2][i2].valueRadius, xoffset: r.xoffsets.data[i2], from: r.offsets[e2][i2].from, to: r.offsets[e2][i2].to }));
                }
              }
          }
          getPolarDataPointOffset(e, t, i) {
            let r = this._renderData[i];
            if (!r)
              return { x: NaN, y: NaN };
            let s = this.getValueAxisDataPointOffset(t, i), a = this.getXAxisDataPointOffset(e, i), l = this._toPolarCoord(r.polarCoords, r.xAxis.rect, a, s);
            return { x: l.x, y: l.y };
          }
          _getDataPointOffsetDiff(e, t, i, r, s, a, l) {
            let n = this._getDataPointOffset(e, i, r, s, a, l), o = this._getDataPointOffset(t, i, r, s, a, l);
            return Math.abs(n - o);
          }
          _getXAxisRenderData(e) {
            if (e >= this._renderData.length)
              return;
            let t = this.seriesGroups[e], i = this._renderData[e].xAxis;
            if (i) {
              if (void 0 === t.xAxis || null === t.xAxis) {
                for (let t2 = 0; t2 <= e; t2++)
                  if (void 0 === this.seriesGroups[t2].xAxis || null === this.seriesGroups[t2].xAxis) {
                    i = this._renderData[t2].xAxis;
                    break;
                  }
              }
              return i;
            }
          }
          getXAxisDataPointOffset(e, t) {
            let i = this.seriesGroups[t];
            if (isNaN(e))
              return NaN;
            const r = this._getXAxisRenderData(t);
            if (!r)
              return NaN;
            let s = r.data.axisStats, a = s.min.valueOf(), l = s.max.valueOf(), n = l - a;
            if (0 === n && (n = 1), e.valueOf() > l || e.valueOf() < a)
              return NaN;
            let o = this._getXAxis(t), h = "horizontal" === i.orientation ? "height" : "width", d = "horizontal" === i.orientation ? "y" : "x", u = (e.valueOf() - a) / n, g = r.rect[h] - r.data.padding.left - r.data.padding.right;
            return (i.polar || i.spider) && this._renderData[t].polarCoords.isClosedCircle && (g = r.data.axisSize), this._plotRect[d] + r.data.padding.left + g * (o.flip ? 1 - u : u);
          }
          getValueAxisDataPointOffset(e, t) {
            let i = this._getValueAxis(t);
            if (!i)
              return NaN;
            let r = this._renderData[t];
            if (!r)
              return NaN;
            let s = true === i.flip, a = r.logBase, l = r.scale, n = r.gbase, o = r.baseOffset;
            return this._getDataPointOffset(e, n, a, l, o, s);
          }
          _getDataPointOffset(e, t, i, r, s, a) {
            let l;
            return isNaN(e) && (e = t), l = isNaN(i) ? (e - t) * r : (this._draw.log(e, i) - this._draw.log(t, i)) * r, l = a ? s + l : s - l, l;
          }
          _calcGroupOffsets(e, t) {
            let i = this.seriesGroups[e];
            for (; this._renderData.length < e + 1; )
              this._renderData.push({});
            if (null !== this._renderData[e] && void 0 !== this._renderData[e].offsets)
              return this._renderData[e];
            if (this._isPieGroup(e))
              return this._calcPieSeriesGroupOffsets(e, t);
            let r = this._getValueAxis(e);
            if (!r || !i.series || 0 === i.series.length)
              return this._renderData[e];
            let s = true === r.flip, a = true === r.logarithmicScale, l = r.logarithmicScaleBase || 10, n = [], o = -1 !== i.type.indexOf("stacked"), h = o && -1 !== i.type.indexOf("100"), d = -1 !== i.type.indexOf("range"), u = this._isColumnType(i.type), g = -1 !== i.type.indexOf("waterfall"), f = this._getDataLen(e), p = i.baselineValue || r.baselineValue || 0;
            h && (p = 0);
            let c = this._stats.seriesGroups[e];
            if (!c || !c.isValid)
              return;
            let m = c.hasStackValueReversal;
            if (m && (p = 0), g && o) {
              if (m)
                return;
              p = c.base;
            }
            p > c.max && (p = c.max), p < c.min && (p = c.min);
            let y = h || a ? c.maxRange : c.max - c.min, _ = c.min, x = c.max, v = t.height / (a ? c.intervals : y), b = 0;
            h ? _ * x < 0 ? (y /= 2, b = -(y + p) * v) : b = -p * v : b = -(p - _) * v, s ? b = t.y - b : b += t.y + t.height;
            let N, M = [], A = [], w = [];
            a && (N = this._draw.log(x, l) - this._draw.log(p, l), o && (N = c.intervals, p = h ? 0 : _), s || (b = t.y + N / c.intervals * t.height)), b = this.renderer._ptrnd(b);
            let S = _ * x < 0 ? t.height / 2 : t.height, C = [], k = [], D = o && (u || a), T = [];
            n = new Array(i.series.length);
            for (let e2 = 0; e2 < i.series.length; e2++)
              n[e2] = new Array(f);
            for (let t2 = 0; t2 < f; t2++) {
              !g && o && (k = []);
              for (let r2 = 0; r2 < i.series.length; r2++) {
                !o && a && (C = []);
                let u2 = i.series[r2], g2 = u2.dataField, f2 = u2.dataFieldFrom, m2 = u2.dataFieldTo, y2 = u2.radiusDataField || u2.sizeDataField;
                n[r2][t2] = {};
                let _2 = this._isSerieVisible(e, r2);
                if (-1 !== i.type.indexOf("candle") || -1 !== i.type.indexOf("ohlc")) {
                  let i2 = ["Open", "Close", "High", "Low"];
                  for (let o2 in i2) {
                    let h2 = "dataField" + i2[o2];
                    u2[h2] && (n[r2][t2][i2[o2]] = this._getDataPointOffset(this._getDataValueAsNumber(t2, u2[h2], e), p, a ? l : NaN, v, b, s));
                  }
                  continue;
                }
                if (o)
                  for (; k.length <= t2; )
                    k.push(0);
                let x2 = NaN;
                d && (x2 = this._getDataValueAsNumber(t2, f2, e), isNaN(x2) && (x2 = p));
                let N2 = NaN;
                N2 = d ? this._getDataValueAsNumber(t2, m2, e) : this._getDataValueAsNumber(t2, g2, e);
                let F2, O = this._getDataValueAsNumber(t2, y2, e);
                if (o && (k[t2] += _2 ? N2 : 0), _2 || (N2 = NaN), isNaN(N2) || a && N2 <= 0) {
                  n[r2][t2] = { from: void 0, to: void 0 };
                  continue;
                }
                o && (D ? F2 = N2 >= p ? M : A : N2 = k[t2]);
                let I = v * (N2 - p);
                if (d && (I = v * (N2 - x2)), o && D && (T[t2] ? I = v * N2 : (T[t2] = true, I = v * (N2 - p))), a) {
                  for (; C.length <= t2; )
                    C.push({ p: { value: 0, height: 0 }, n: { value: 0, height: 0 } });
                  let e2 = d || d ? x2 : p, i2 = N2 > e2 ? C[t2].p : C[t2].n;
                  i2.value += N2, h ? (N2 = i2.value / (c.psums[t2] + c.nsums[t2]) * 100, I = (this._draw.log(N2, l) - c.minPow) * v) : (I = this._draw.log(i2.value, l) - this._draw.log(e2, l), I *= v), I -= i2.height, i2.height += I;
                }
                let P = b;
                if (d) {
                  let e2 = 0;
                  e2 = a ? (this._draw.log(x2, l) - this._draw.log(p, l)) * v : (x2 - p) * v, P += s ? e2 : -e2;
                }
                if (o) {
                  if (h && !a) {
                    let e2 = c.psums[t2] - c.nsums[t2];
                    N2 > p ? (I = c.psums[t2] / e2 * S, 0 !== c.psums[t2] && (I *= N2 / c.psums[t2])) : (I = c.nsums[t2] / e2 * S, 0 !== c.nsums[t2] && (I *= N2 / c.nsums[t2]));
                  }
                  D && (isNaN(F2[t2]) && (F2[t2] = P), P = F2[t2]);
                }
                isNaN(w[t2]) && (w[t2] = 0);
                let R = w[t2];
                I = Math.abs(I);
                let L = I;
                if (I >= 1) {
                  const e2 = this.renderer._ptrnd(I) - 1;
                  I = Math.abs(I - e2) > 0.5 ? Math.round(I) : e2;
                }
                if (R += I - L, o || (R = 0), Math.abs(R) > 0.5 && (R > 0 ? (I -= 1, R -= 1) : (I += 1, R += 1)), w[t2] = R, r2 === i.series.length - 1 && h) {
                  let e2 = 0;
                  for (let i2 = 0; i2 < r2; i2++)
                    e2 += Math.abs(n[i2][t2].to - n[i2][t2].from);
                  if (e2 += I, e2 < S)
                    if (I > 0.5)
                      I = this.renderer._ptrnd(I + S - e2);
                    else {
                      let i2 = r2 - 1;
                      for (; i2 >= 0; ) {
                        if (Math.abs(n[i2][t2].to - n[i2][t2].from) > 1) {
                          n[i2][t2].from > n[i2][t2].to && (n[i2][t2].from += S - e2);
                          break;
                        }
                        i2--;
                      }
                    }
                }
                s && (I *= -1);
                let G = N2 < p;
                d && (G = x2 > N2);
                let V = isNaN(x2) ? N2 : { from: x2, to: N2 };
                G ? (D && (F2[t2] += I), n[r2][t2] = { from: P, to: P + I, value: V, valueRadius: O }) : (D && (F2[t2] -= I), n[r2][t2] = { from: P, to: P - I, value: V, valueRadius: O });
              }
            }
            let F = this._renderData[e];
            return F.baseOffset = b, F.gbase = p, F.logBase = a ? l : NaN, F.scale = v, F.offsets = g ? this._applyWaterfall(n, f, e, b, p, a ? l : NaN, v, s, o) : n, F.xoffsets = this._calculateXOffsets(e, t.width), this._renderData[e];
          }
          _isPercent(e) {
            return "string" == typeof e && e.length > 0 && e.indexOf("%") === e.length - 1;
          }
          _calcPieSeriesGroupOffsets(e, t) {
            var i = this, r = this._getDataLen(e), s = this.seriesGroups[e], a = this._renderData[e] = {}, l = a.offsets = [];
            for (let a2 = 0; a2 < s.series.length; a2++) {
              var n = s.series[a2], o = this._get([n.minAngle, n.startAngle]);
              (isNaN(o) || o < 0 || o > 360) && (o = 0);
              var h = this._get([n.maxAngle, n.endAngle]);
              (isNaN(h) || h < 0 || h > 360) && (h = 360);
              var d = h - o, u = n.initialAngle || 0;
              u < o && (u = o), u > h && (u = h);
              var g = n.centerOffset || 0, f = this._draw.getNum([n.offsetX, s.offsetX, t.width / 2]), p = this._draw.getNum([n.offsetY, s.offsetY, t.height / 2]), c = Math.min(t.width, t.height) / 2, m = u, y = n.radius;
              i._isPercent(y) && (y = parseFloat(y) / 100 * c), isNaN(y) && (y = 0.4 * c);
              var _ = n.innerRadius;
              i._isPercent(_) && (_ = parseFloat(_) / 100 * c), (isNaN(_) || _ >= y) && (_ = 0);
              var x = n.selectedRadiusChange;
              i._isPercent(x) && (x = parseFloat(x) / 100 * (y - _)), isNaN(x) && (x = 0.1 * (y - _)), l.push([]);
              var v = 0, b = 0;
              for (let t2 = 0; t2 < r; t2++) {
                var N = this._getDataValueAsNumber(t2, n.dataField, e);
                isNaN(N) || (this._isSerieVisible(e, a2, t2) || true === n.hiddenPointsDisplay) && (N > 0 ? v += N : b += N);
              }
              var M = v - b;
              0 === M && (M = 1);
              for (let i2 = 0; i2 < r; i2++) {
                let r2 = this._getDataValueAsNumber(i2, n.dataField, e);
                if (isNaN(r2))
                  l[a2].push({});
                else {
                  var A = n.displayText || n.displayField, w = this._getDataValue(i2, A, e);
                  null == w && (w = i2);
                  var S = 0, C = this._isSerieVisible(e, a2, i2);
                  (C || true === n.hiddenPointsDisplay) && (S = Math.abs(r2) / M * d);
                  var k = t.x + f, D = t.y + p, T = g;
                  "function" == typeof g && (T = g({ seriesIndex: a2, seriesGroupIndex: e, itemIndex: i2 })), isNaN(T) && (T = 0);
                  var F = { key: e + "_" + a2 + "_" + i2, value: r2, displayValue: w, x: k, y: D, fromAngle: m, toAngle: m + S, centerOffset: T, innerRadius: _, outerRadius: y, selectedRadiusChange: x, visible: C };
                  l[a2].push(F), m += S;
                }
              }
            }
            return a;
          }
          _isPointSeriesOnly() {
            for (let e = 0; e < this.seriesGroups.length; e++) {
              let t = this.seriesGroups[e];
              if (-1 === t.type.indexOf("line") && -1 === t.type.indexOf("area") && -1 === t.type.indexOf("scatter") && -1 === t.type.indexOf("bubble"))
                return false;
            }
            return true;
          }
          _hasColumnSeries() {
            let e = ["column", "ohlc", "candlestick", "waterfall"];
            for (let t = 0; t < this.seriesGroups.length; t++) {
              let i = this.seriesGroups[t];
              for (let t2 in e)
                if (-1 !== i.type.indexOf(e[t2]))
                  return true;
            }
            return false;
          }
          _alignValuesWithTicks(e) {
            let t = this._isPointSeriesOnly(), i = this.seriesGroups[e], r = this._getXAxis(e), s = void 0 === r.valuesOnTicks || null === r.valuesOnTicks ? t : false !== r.valuesOnTicks;
            return r.logarithmicScale && (s = true), null == e || void 0 === i.valuesOnTicks || null === i.valuesOnTicks ? s : i.valuesOnTicks;
          }
          _getYearsDiff(e, t) {
            return t.getFullYear() - e.getFullYear();
          }
          _getMonthsDiff(e, t) {
            return 12 * (t.getFullYear() - e.getFullYear()) + t.getMonth() - e.getMonth();
          }
          _getDateDiff(e, t, i, r) {
            let s = 0;
            switch ("year" !== i && "month" !== i && (s = t.valueOf() - e.valueOf()), i) {
              case "year":
                s = this._getYearsDiff(e, t);
                break;
              case "month":
                s = this._getMonthsDiff(e, t);
                break;
              case "day":
                s /= 864e5;
                break;
              case "hour":
                s /= 36e5;
                break;
              case "minute":
                s /= 6e4;
                break;
              case "second":
                s /= 1e3;
            }
            return "year" !== i && "month" !== i && false !== r && (s = this.renderer._rnd(s, 1, true)), s;
          }
          _getBestDTUnit(e, t, i, r, s) {
            let a = "day", l = t.valueOf() - e.valueOf();
            a = l < 1e3 ? "second" : l < 36e5 ? "minute" : l < 864e5 ? "hour" : l < 2592e6 ? "day" : l < 31104e6 ? "month" : "year";
            let n = [{ key: "year", cnt: l / 31536e6 }, { key: "month", cnt: l / 2592e6 }, { key: "day", cnt: l / 864e5 }, { key: "hour", cnt: l / 36e5 }, { key: "minute", cnt: l / 6e4 }, { key: "second", cnt: l / 1e3 }, { key: "millisecond", cnt: l }], o = -1;
            for (let e2 = 0; e2 < n.length; e2++)
              if (n[e2].key === a) {
                o = e2;
                break;
              }
            let h = -1, d = -1;
            for (; o < n.length && !(n[o].cnt / 100 > r); o++) {
              let a2 = this._estAxisInterval(e, t, i, r, n[o].key, s), l2 = this._getDTIntCnt(e, t, a2, n[o].key);
              (-1 === h || h < l2) && (h = l2, d = o);
            }
            return a = n[d].key, a;
          }
          _getXAxisStats(e, t, i) {
            let r = this._getDataLen(e), s = "date" === t.type || "time" === t.type;
            if (s && !this._autoDateFormats) {
              this._autoDateFormats || (this._autoDateFormats = []);
              let e2 = this._testXAxisDateFormat();
              e2 && this._autoDateFormats.push(e2);
            }
            let a = s ? this._castAsDate(t.minValue, t.dateFormat) : this._castAsNumber(t.minValue), l = s ? this._castAsDate(t.maxValue, t.dateFormat) : this._castAsNumber(t.maxValue);
            if (this._selectorRange && this._selectorRange[e]) {
              let i2 = this._selectorRange[e].min;
              isNaN(i2) || (a = s ? this._castAsDate(i2, t.dateFormat) : this._castAsNumber(i2));
              let r2 = this._selectorRange[e].max;
              isNaN(r2) || (l = s ? this._castAsDate(r2, t.dateFormat) : this._castAsNumber(r2));
            }
            let n, o, h = a, d = l, u = void 0 === t.type || null === t.type || "auto" === t.type, g = u || "basic" === t.type, f = 0, p = 0;
            for (let i2 = 0; i2 < r && t.dataField; i2++) {
              let r2 = this._getDataValue(i2, t.dataField, e);
              r2 = s ? this._castAsDate(r2, t.dateFormat) : this._castAsNumber(r2), isNaN(r2) || (s ? f++ : p++, (isNaN(n) || r2 < n) && (n = r2), (isNaN(o) || r2 >= o) && (o = r2));
            }
            u && (!s && p === r || s && f === r) && (g = false), g && (n = 0, o = Math.max(0, r - 1)), isNaN(h) && (h = n), isNaN(d) && (d = o), s ? (this._isDate(h) || (h = this._isDate(d) ? d : /* @__PURE__ */ new Date()), this._isDate(d) || (d = this._isDate(h) ? h : /* @__PURE__ */ new Date())) : (isNaN(h) && (h = 0), isNaN(d) && (d = g ? Math.max(0, r - 1) : h)), null == n && (n = h), null == o && (o = d);
            let c, m, y = t.rangeSelector && t.rangeSelector.visible;
            if (y) {
              let e2 = y.minValue || h;
              e2 && s && (e2 = this._castAsDate(e2, y.dateFormat || t.dateFormat));
              let i2 = y.maxValue || d;
              i2 && s && (i2 = this._castAsDate(i2, y.dateFormat || t.rangeSelector)), h < e2 && (h = e2), d < e2 && (d = i2), h > i2 && (h = e2), d > i2 && (d = i2);
            }
            s && (c = t.baseUnit, c || (c = this._getBestDTUnit(h, d, e, i)), m = "hour" === c || "minute" === c || "second" === c || "millisecond" === c);
            let _ = true === t.logarithmicScale, x = t.logarithmicScaleBase;
            (isNaN(x) || x <= 1) && (x = 10);
            let v = t.unitInterval;
            _ ? v = 1 : (isNaN(v) || v <= 0) && (v = this._estAxisInterval(h, d, e, i, c));
            let b, N, M = { min: h, max: d }, A = this.seriesGroups[e];
            return _ ? (h || (h = 1, d && h > d && (h = d)), d || (d = h), M = { min: h, max: d }, b = this.renderer._rnd(this._draw.log(h, x), 1, false), N = this.renderer._rnd(this._draw.log(d, x), 1, true), d = Math.pow(x, N), h = Math.pow(x, b)) : s || !A.polar && !A.spider || (h = this.renderer._rnd(h, v, false), d = this.renderer._rnd(d, v, true)), { min: h, max: d, logAxis: { enabled: _, base: x, minPow: b, maxPow: N }, dsRange: { min: n, max: o }, filterRange: M, useIndeces: g, isDateTime: s, isTimeUnit: m, dateTimeUnit: c, interval: v };
          }
          _getDefaultDTFormatFn(e) {
            let t, i = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            return t = "year" === e || "month" === e || "day" === e ? function(e2) {
              return e2.getDate() + "-" + i[e2.getMonth()] + "-" + e2.getFullYear();
            } : function(e2) {
              return e2.getDate() + "-" + i[e2.getMonth()] + "-" + e2.getFullYear() + "<br>" + e2.getHours() + ":" + e2.getMinutes() + ":" + e2.getSeconds();
            }, t;
          }
          _getDTIntCnt(e, t, i, r) {
            let s = 0, a = new Date(e), l = new Date(t);
            if (l = l.valueOf(), i <= 0)
              return 1;
            for (; a.valueOf() < l; )
              "millisecond" === r ? a = new Date(a.valueOf() + i) : "second" === r ? a = new Date(a.valueOf() + 1e3 * i) : "minute" === r ? a = new Date(a.valueOf() + 6e4 * i) : "hour" === r ? a = new Date(a.valueOf() + 6e4 * i * 24) : "day" === r ? a.setDate(a.getDate() + i) : "month" === r ? a.setMonth(a.getMonth() + i) : "year" === r && a.setFullYear(a.getFullYear() + i), s++;
            return s;
          }
          _estAxisInterval(e, t, i, r, s, a) {
            if (isNaN(e) || isNaN(t))
              return NaN;
            let l = [1, 2, 5, 10, 15, 20, 50, 100, 200, 500], n = 0, o = r / (!isNaN(a) && a > 0 ? a : 50);
            if (this._renderData && this._renderData.length > i && this._renderData[i].xAxis && !isNaN(this._renderData[i].xAxis.avgWidth)) {
              let e2 = Math.max(1, this._renderData[i].xAxis.avgWidth);
              0 !== e2 && isNaN(a) && (o = 0.9 * r / e2);
            }
            if (o <= 1)
              return Math.abs(t - e);
            let h, d = 0;
            for (; h = n >= l.length ? Math.pow(10, 3 + n - l.length) : l[n], d = this._isDate(e) && this._isDate(t) ? this._getDTIntCnt(e, t, h, s) : (t - e) / h, !(d <= o); )
              n++;
            let u = this.seriesGroups[i];
            return (u.spider || u.polar) && 2 * h > t - e && (h = t - e), h;
          }
          _getPaddingSize(e, t, i, r, s, a, l) {
            var n = e.min, o = e.max;
            e.logAxis.enabled && (n = e.logAxis.minPow, o = e.logAxis.maxPow);
            var h = e.interval, d = e.dateTimeUnit;
            if (s) {
              var u = r / Math.max(1, o - n + h) * h;
              return a ? { left: 0, right: u } : i ? { left: 0, right: 0 } : { left: u / 2, right: u / 2 };
            }
            if (i && !l)
              return { left: 0, right: 0 };
            if (this._isDate(n) && this._isDate(o)) {
              let e2 = this._getDTIntCnt(n, o, Math.min(h, o - n), d), t2 = r / Math.max(2, e2);
              return { left: t2 / 2, right: t2 / 2 };
            }
            let g = Math.max(1, o - n);
            if (1 === g) {
              const e2 = r / 4;
              return { left: e2, right: e2 };
            }
            let f = r / (g + 1);
            return { left: f / 2, right: f / 2 };
          }
          _calculateXOffsets(e, t) {
            var i = this.seriesGroups[e], r = this._getXAxis(e), s = [], a = [], l = this._getDataLen(e), n = this._getXAxisStats(e, r, t), o = n.min, h = n.max, d = n.isDateTime, u = n.isTimeUnit, g = this._hasColumnSeries(), f = i.polar || i.spider, p = this._get([i.startAngle, i.minAngle, 0]), c = this._get([i.endAngle, i.maxAngle, 360]), m = f && !(Math.abs(Math.abs(c - p) - 360) > 1e-4), y = this._alignValuesWithTicks(e), _ = this._getPaddingSize(n, r, y, t, f, m, g), x = h - o, v = n.filterRange;
            0 === x && (x = 1);
            var b = t - _.left - _.right;
            f && y && !m && (_.left = _.right = 0);
            var N = -1, M = -1;
            for (let t2 = 0; t2 < l; t2++) {
              var A = void 0 === r.dataField ? t2 : this._getDataValue(t2, r.dataField, e);
              if (n.useIndeces) {
                if (t2 < v.min || t2 > v.max) {
                  s.push(NaN), a.push(void 0);
                  continue;
                }
                if (S = _.left + (t2 - o) / x * b, true === n.logAxis.enabled) {
                  var w = n.logAxis.base;
                  S = this._smartPlot.scale(A, { min: o.valueOf(), max: h.valueOf(), type: "logarithmic", base: w }, { min: 0, max: b, flip: false });
                }
                s.push(this.renderer._ptrnd(S)), a.push(A), -1 === N && (N = t2), (-1 === M || M < t2) && (M = t2);
              } else if (A = d ? this._castAsDate(A, r.dateFormat) : this._castAsNumber(A), isNaN(A) || A < v.min || A > v.max)
                s.push(NaN), a.push(void 0);
              else {
                var S = 0;
                if (true === n.logAxis.enabled) {
                  let e2 = n.logAxis.base;
                  S = this._smartPlot.scale(A, { min: o.valueOf(), max: h.valueOf(), type: "logarithmic", base: e2 }, { min: 0, max: b, flip: false });
                } else
                  S = !d || d && u ? (A - o) * b / x : (A.valueOf() - o.valueOf()) / (h.valueOf() - o.valueOf()) * b;
                S = this.renderer._ptrnd(_.left + S), s.push(S), a.push(A), -1 === N && (N = t2), (-1 === M || M < t2) && (M = t2);
              }
            }
            if (true === r.flip)
              for (let e2 = 0; e2 < s.length; e2++)
                isNaN(s[e2]) || (s[e2] = t - s[e2]);
            (u || d) && (x = this._getDateDiff(o, h, r.baseUnit), x = this.renderer._rnd(x, 1, false));
            var C = Math.max(1, x), k = b / C;
            return N === M && 1 === C && (s[N] = _.left + b / 2), { axisStats: n, data: s, xvalues: a, first: N, last: M, length: -1 === M ? 0 : M - N + 1, itemWidth: k, intervalWidth: k * n.interval, rangeLength: x, useIndeces: n.useIndeces, padding: _, axisSize: b };
          }
          _getXAxis(e) {
            return null == e || this.seriesGroups.length <= e ? this.xAxis : this.seriesGroups[e].xAxis || this.xAxis;
          }
          _isGreyScale(e, t) {
            let i = this.seriesGroups[e], r = i.series[t];
            return true === r.greyScale || false !== r.greyScale && (true === i.greyScale || false !== i.greyScale && true === this.greyScale);
          }
          _getSeriesColors(e, t, i) {
            let r = this._getSeriesColorsInternal(e, t, i);
            if (this._isGreyScale(e, t))
              for (let e2 in r)
                r[e2] = this._draw.toGreyScale(r[e2]);
            return r;
          }
          _getColorFromScheme(e, t, i) {
            let r = "#000000", s = this.seriesGroups[e], a = s.series[t];
            if (this._isPieGroup(e)) {
              let l = this._getDataLen(e);
              r = this._getItemColorFromScheme(a.colorScheme || s.colorScheme || this.colorScheme, t * l + i, e, t);
            } else {
              let i2 = 0;
              for (let r2 = 0; r2 <= e; r2++)
                for (let s2 = 0; s2 < this.seriesGroups[r2].series.length && (r2 !== e || parseInt(s2) !== t); s2++)
                  i2++;
              let a2 = this.colorScheme;
              if (s.colorScheme && (a2 = s.colorScheme), null != a2 && "" !== a2 || (a2 = this.colorSchemes[0].name), !a2)
                return r;
              for (let e2 = 0; e2 < this.colorSchemes.length; e2++) {
                let t2 = this.colorSchemes[e2];
                if (t2.name === a2) {
                  for (; i2 > t2.colors.length; )
                    i2 -= t2.colors.length, ++e2 >= this.colorSchemes.length && (e2 = 0), t2 = this.colorSchemes[e2];
                  r = t2.colors[i2 % t2.colors.length];
                }
              }
            }
            return r;
          }
          _createColorsCache() {
            this._colorsCache = { get: function(e) {
              if (this._store[e])
                return this._store[e];
            }, set: function(e, t) {
              this._size < 1e4 && (this._store[e] = t, this._size++);
            }, clear: function() {
              this._store = {}, this._size = 0;
            }, _size: 0, _store: {} };
          }
          _getSeriesColorsInternal(e, t, i) {
            let r = this.seriesGroups[e], s = r.series[t];
            "function" === (s.colorFunction, false) && "pie" !== r.type && "donut" !== r.type && (i = NaN);
            let a = e + "_" + t + "_" + (isNaN(i) ? "NaN" : i);
            if (this._colorsCache.get(a))
              return this._colorsCache.get(a);
            let l, n = { lineColor: "#222222", lineColorSelected: "#151515", lineColorSymbol: "#222222", lineColorSymbolSelected: "#151515", fillColor: "#222222", fillColorSelected: "#333333", fillColorSymbol: "#222222", fillColorSymbolSelected: "#333333", fillColorAlt: "#222222", fillColorAltSelected: "#333333" };
            if ("function" == typeof s.colorFunction) {
              let t2 = isNaN(i) ? NaN : this._getDataValue(i, s.dataField, e);
              if (-1 === r.type.indexOf("range") || isNaN(i) || (t2 = { from: this._getDataValue(i, s.dataFieldFrom, e), to: this._getDataValue(i, s.dataFieldTo, e) }), l = s.colorFunction(t2, i, s, r), "object" == typeof l)
                for (let e2 in l)
                  n[e2] = l[e2];
              else
                n.fillColor = l;
            } else {
              for (let e2 in n)
                s[e2] && (n[e2] = s[e2]);
              s.fillColor || s.color ? s.fillColor = s.fillColor || s.color : n.fillColor = this._getColorFromScheme(e, t, i);
            }
            let o = { fillColor: { baseColor: "fillColor", adjust: 1 }, fillColorSelected: { baseColor: "fillColor", adjust: 1.1 }, fillColorSymbol: { baseColor: "fillColor", adjust: 1 }, fillColorSymbolSelected: { baseColor: "fillColorSymbol", adjust: 2 }, fillColorAlt: { baseColor: "fillColor", adjust: 4 }, fillColorAltSelected: { baseColor: "fillColor", adjust: 3 }, lineColor: { baseColor: "fillColor", adjust: 0.95 }, lineColorSelected: { baseColor: "lineColor", adjust: 0.95 }, lineColorSymbol: { baseColor: "lineColor", adjust: 1 }, lineColorSymbolSelected: { baseColor: "lineColorSelected", adjust: 1 } };
            for (let e2 in n)
              "object" == typeof l && l[e2] || s[e2] && (n[e2] = s[e2]);
            for (let e2 in n)
              "object" == typeof l && l[e2] || s[e2] || (n[e2] = this.renderer.adjustColor(n[o[e2].baseColor], o[e2].adjust));
            return this._colorsCache.set(a, n), n;
          }
          _getItemColorFromScheme(e, t, i, r) {
            let s;
            for (void 0 !== e && "" !== e || (e = this.colorSchemes[0].name), s = 0; s < this.colorSchemes.length && e !== this.colorSchemes[s].name; s++)
              ;
            let a = 0;
            for (; a <= t; ) {
              s === this.colorSchemes.length && (s = 0);
              let e2 = this.colorSchemes[s].colors.length;
              if (!(a + e2 <= t)) {
                let e3 = this.colorSchemes[s].colors[t - a];
                return this._isGreyScale(i, r) && 0 === e3.indexOf("#") && (e3 = this._draw.toGreyScale(e3)), e3;
              }
              a += e2, s++;
            }
          }
          getColorScheme(e) {
            for (let t = 0; t < this.colorSchemes.length; t++)
              if (this.colorSchemes[t].name === e)
                return this.colorSchemes[t].colors;
          }
          addColorScheme(e, t) {
            for (let i = 0; i < this.colorSchemes.length; i++)
              if (this.colorSchemes[i].name === e)
                return void (this.colorSchemes[i].colors = t);
            this.colorSchemes.push({ name: e, colors: t });
          }
          removeColorScheme(e) {
            for (let t = 0; t < this.colorSchemes.length; t++)
              if (this.colorSchemes[t].name === e) {
                this.colorSchemes.splice(t, 1);
                break;
              }
          }
          _formatValue(e, t, i, r, s, a) {
            if (null == e)
              return "";
            if (this._isObject(e) && !this._isDate(e) && !i)
              return "";
            if (i) {
              if ("function" != typeof i)
                return e.toString();
              try {
                return i(e, a, s, r);
              } catch (e2) {
                return e2.message;
              }
            }
            return this._isNumber(e) ? this._formatNumber(e, t) : this._isDate(e) ? this._formatDate(e, t) : t ? (t.prefix || "") + e.toString() + (t.sufix || "") : e.toString();
          }
          _getFormattedValue(e, t, i, r, s, a) {
            let l = this.seriesGroups[e], n = l.series[t], o = "", h = r, d = s;
            n.labels && (h = h || this._getFormatSettings(n.labels), d = d || n.labels.formatFunction), h || d || (h = this._getFormatSettings(n), d = n.formatFunction, h || d || (h = this._getFormatSettings(l), d = l.formatFunction));
            let u = {}, g = 0;
            for (let t2 in n)
              0 === t2.indexOf("dataField") && (u[t2.substring(9).toLowerCase()] = this._getDataValue(i, n[t2], e), g++);
            if (0 === g && (u = this._getDataValue(i, void 0, e)), -1 !== l.type.indexOf("waterfall") && this._isSummary(e, i) && (u = this._renderData[e].offsets[t][i].value, g = 0), d && "function" == typeof d)
              try {
                return d(1 === g ? u[""] : u, i, n, l);
              } catch (e2) {
                return e2.message;
              }
            if (1 === g && this._isPieGroup(e))
              return this._formatValue(u[""], h, d, e, t, i);
            if (g > 0) {
              let r2 = 0;
              for (let s2 in u) {
                r2 > 0 && "" !== o && (o += "<br>");
                let l2 = "dataField" + (s2.length > 0 ? s2.substring(0, 1).toUpperCase() + s2.substring(1) : ""), g2 = n["displayText" + (s2.length > 0 ? s2.substring(0, 1).toUpperCase() + s2.substring(1) : "")] || n[l2], f = u[s2];
                void 0 !== f && (f = this._formatValue(f, h, d, e, t, i), o += true === a ? f : g2 + ": " + f, r2++);
              }
            } else
              null != u && (o = this._formatValue(u, h, d, e, t, i));
            return o || "";
          }
          _isNumberAsString(e) {
            if ("string" != typeof e)
              return false;
            e = e.trim();
            for (let t = 0; t < e.length; t++) {
              let i = e.charAt(t);
              if (!(i >= "0" && i <= "9" || "," === i || "." === i || "-" === i && 0 === t || "(" === i && 0 === t || ")" === i && t === e.length - 1))
                return false;
            }
            return true;
          }
          _castAsDate(e, t) {
            if (e instanceof Date && !isNaN(e))
              return e;
            if ("string" == typeof e) {
              let i = new Date(e);
              if (this._isDate(i))
                return -1 === e.indexOf(":") && i.setHours(0, 0, 0, 0), i;
              try {
                if (t && (i = Smart.Utilities.DateTime.parseDateString(e, void 0, t).toDate(), this._isDate(i)))
                  return i;
                if (this._autoDateFormats) {
                  for (let t2 = 0; t2 < this._autoDateFormats.length; t2++)
                    if (i = Smart.Utilities.DateTime.parseDateString(e, void 0, this._autoDateFormats[t2]).toDate(), this._isDate(i))
                      return i;
                }
                let r = this._detectDateFormat(e);
                if (r && (i = Smart.Utilities.DateTime.parseDateString(e, void 0, r).toDate(), this._isDate(i)))
                  return this._autoDateFormats.push(r), i;
              } catch (e2) {
              }
            }
          }
          _castAsNumber(e) {
            if (e instanceof Date && !isNaN(e))
              return e.valueOf();
            if ("string" == typeof e) {
              if (this._isNumber(e))
                e = parseFloat(e);
              else if (!/[a-zA-Z]/.test(e)) {
                let t = new Date(e);
                null != t && (e = t.valueOf());
              }
            }
            return isNaN(e) ? void 0 : e;
          }
          _isNumber(e) {
            return "string" == typeof e && this._isNumberAsString(e) && (e = parseFloat(e)), "number" == typeof e && isFinite(e);
          }
          _isDate(e) {
            return e instanceof Date && !isNaN(e.getDate());
          }
          _isBoolean(e) {
            return "boolean" == typeof e;
          }
          _isObject(e) {
            return e && ("object" == typeof e || "function" == typeof e) || false;
          }
          _formatDate(e, t) {
            let i = e.toString();
            return t && (t.dateFormat && (i = new Smart.Utilities.DateTime(e).toString(t.dateFormat)), i = (t.prefix || "") + i + (t.sufix || "")), i;
          }
          _formatNumber(e, t) {
            if (!this._isNumber(e))
              return e;
            t = t || {};
            let i = this.localization.decimalSeparator, r = this.localization.thousandsSeparator;
            t.decimalSeparator && (i = t.decimalSeparator), t.thousandsSeparator && (r = t.thousandsSeparator);
            let s = t.prefix || "", a = t.sufix || "", l = t.decimalPlaces;
            isNaN(l) && (l = this._getDecimalPlaces([e], void 0, 3));
            let n = t.negativeWithBrackets || false, o = e < 0;
            o && n && (e *= -1);
            let h, d = e.toString(), u = Math.pow(10, l);
            if (d = (Math.round(e * u) / u).toString(), isNaN(d) && (d = ""), h = d.lastIndexOf("."), l > 0)
              for (h < 0 ? (d += i, h = d.length - 1) : "." !== i && (d = d.replace(".", i)); d.length - 1 - h < l; )
                d += "0";
            h = d.lastIndexOf(i), h = h > -1 ? h : d.length;
            let g = d.substring(h), f = 0;
            for (let e2 = h; e2 > 0; e2--, f++)
              f % 3 == 0 && e2 !== h && (!o || e2 > 1 || o && n) && (g = r + g), g = d.charAt(e2 - 1) + g;
            return d = g, o && n && (d = "(" + d + ")"), s + d + a;
          }
          _calculateControlPoints(e, t) {
            let i = e[t], r = e[t + 1], s = e[t + 2], a = e[t + 3], l = e[t + 4], n = e[t + 5], o = Math.sqrt(Math.pow(s - i, 2) + Math.pow(a - r, 2)), h = o + Math.sqrt(Math.pow(l - s, 2) + Math.pow(n - a, 2));
            0 === h && (h = 1);
            let d = 0.4 * o / h, u = 0.4 - d;
            return [s + d * (i - l), a + d * (r - n), s - u * (i - l), a - u * (r - n)];
          }
          _getBezierPoints(e) {
            let t = "", i = [], r = [], s = e.split(" ");
            for (let e2 = 0; e2 < s.length; e2++) {
              let t2 = s[e2].split(",");
              i.push(parseFloat(t2[0])), i.push(parseFloat(t2[1])), !isNaN(i[i.length - 1]) && isNaN(i[i.length - 2]);
            }
            let a = i.length;
            if (a <= 1)
              return "";
            if (2 === a)
              return t = "M" + this.renderer._ptrnd(i[0]) + "," + this.renderer._ptrnd(i[1]) + " L" + this.renderer._ptrnd(i[0] + 1) + "," + this.renderer._ptrnd(i[1] + 1) + " ", t;
            for (let e2 = 0; e2 < a - 4; e2 += 2)
              r = r.concat(this._calculateControlPoints(i, e2));
            for (let e2 = 2; e2 < a - 5; e2 += 2)
              t += " C" + this.renderer._ptrnd(r[2 * e2 - 2]) + "," + this.renderer._ptrnd(r[2 * e2 - 1]) + " " + this.renderer._ptrnd(r[2 * e2]) + "," + this.renderer._ptrnd(r[2 * e2 + 1]) + " " + this.renderer._ptrnd(i[e2 + 2]) + "," + this.renderer._ptrnd(i[e2 + 3]) + " ";
            return t = a <= 4 || Math.abs(i[0] - i[2]) < 3 || Math.abs(i[1] - i[3]) < 3 ? "M" + this.renderer._ptrnd(i[0]) + "," + this.renderer._ptrnd(i[1]) + " L" + this.renderer._ptrnd(i[2]) + "," + this.renderer._ptrnd(i[3]) + " " + t : "M" + this.renderer._ptrnd(i[0]) + "," + this.renderer._ptrnd(i[1]) + " Q" + this.renderer._ptrnd(r[0]) + "," + this.renderer._ptrnd(r[1]) + " " + this.renderer._ptrnd(i[2]) + "," + this.renderer._ptrnd(i[3]) + " " + t, a >= 4 && (Math.abs(i[a - 2] - i[a - 4]) < 3 || Math.abs(i[a - 1] - i[a - 3]) < 3) ? t += " L" + this.renderer._ptrnd(i[a - 2]) + "," + this.renderer._ptrnd(i[a - 1]) + " " : a >= 5 && (t += " Q" + this.renderer._ptrnd(r[2 * a - 10]) + "," + this.renderer._ptrnd(r[2 * a - 9]) + " " + this.renderer._ptrnd(i[a - 2]) + "," + this.renderer._ptrnd(i[a - 1]) + " "), t;
          }
          _createAnimationGroup(e) {
            this._animGroups || (this._animGroups = {}), this._animGroups[e] = { animations: [], startTick: NaN };
          }
          _startAnimation(e) {
            let t = (/* @__PURE__ */ new Date()).getTime();
            this._animGroups[e].startTick = t, this._runAnimation(), this._enableAnimTimer();
          }
          _enqueueAnimation(e, t, i, r, s, a, l) {
            r < 0 && (r = 0), void 0 === l && (l = "easeInOutSine"), this._animGroups[e].animations.push({ key: t, properties: i, duration: r, fn: s, context: a, easing: l });
          }
          _stopAnimations() {
            clearTimeout(this._animtimer), this._animtimer = void 0, this._animGroups = void 0;
          }
          _enableAnimTimer() {
            if (!this._animtimer) {
              let e = this;
              this._animtimer = setTimeout(function() {
                e._runAnimation();
              }, this._animTickInt);
            }
          }
          _runAnimation() {
            if (this._animGroups) {
              let e = (/* @__PURE__ */ new Date()).getTime(), t = {};
              for (let i in this._animGroups) {
                let r = this._animGroups[i].animations, s = this._animGroups[i].startTick, a = 0;
                for (let t2 = 0; t2 < r.length; t2++) {
                  let i2 = r[t2], l = e - s;
                  i2.duration > a && (a = i2.duration);
                  let n = i2.duration > 0 ? l / i2.duration : 1, o = n;
                  if (i2.easing && 0 !== i2.duration && false !== i2.duration && (o = Smart.Utilities.Animation.Easings[i2.easing](l, 0, 1, i2.duration)), n > 1 && (n = 1, o = 1), i2.fn) {
                    i2.fn(i2.key, i2.context, o);
                    continue;
                  }
                  let h = {};
                  for (let e2 = 0; e2 < i2.properties.length; e2++) {
                    let t3 = i2.properties[e2], r2 = 0;
                    r2 = 1 === n ? t3.to : o * (t3.to - t3.from) + t3.from, h[t3.key] = r2;
                  }
                  this.renderer.attr(i2.key, h);
                }
                s + a > e && (t[i] = { startTick: s, animations: r });
              }
              this._animGroups = t, this.renderer instanceof Smart.Utilities.HTML5Renderer && this.renderer.refresh();
            }
            this._animtimer = null, Object.values(this._animGroups).length > 0 && this._enableAnimTimer();
          }
          _fixCoords(e, t) {
            if ("horizontal" !== this.seriesGroups[t].orientation)
              return e;
            var i = e.x;
            return e.x = e.y, e.y = i + this._plotRect.y - this._plotRect.x, i = e.width, e.width = e.height, e.height = i, e;
          }
          getItemCoord(e, t, i) {
            var r = this;
            if (r._isPieGroup(e) && (!r._isSerieVisible(e, t, i) || !r._renderData || r._renderData.length <= e))
              return { x: NaN, y: NaN };
            if (!r._isSerieVisible(e, t) || !r._renderData || r._renderData.length <= e)
              return { x: NaN, y: NaN };
            var s = r.seriesGroups[e], a = s.series[t], l = r._getItemCoord(e, t, i);
            if (r._isPieGroup(e)) {
              if (isNaN(l.x) || isNaN(l.y) || isNaN(l.fromAngle) || isNaN(l.toAngle))
                return { x: NaN, y: NaN };
              var n = this._plotRect, o = l.fromAngle * (Math.PI / 180), h = l.toAngle * (Math.PI / 180);
              const e2 = n.x + l.center.x + Math.cos(o) * l.outerRadius, t2 = n.x + l.center.x + Math.cos(h) * l.outerRadius, i2 = n.y + l.center.y - Math.sin(o) * l.outerRadius, r2 = n.y + l.center.y - Math.sin(h) * l.outerRadius;
              var d = Math.min(e2, t2), u = Math.abs(t2 - e2);
              return l = { x: d, y: Math.min(i2, r2), width: u, height: Math.abs(r2 - i2), center: l.center, centerOffset: l.centerOffset, innerRadius: l.innerRadius, outerRadius: l.outerRadius, selectedRadiusChange: l.selectedRadiusChange, fromAngle: l.fromAngle, toAngle: l.toAngle };
            }
            if (-1 !== s.type.indexOf("column") || -1 !== s.type.indexOf("waterfall")) {
              var g = this._getColumnSerieWidthAndOffset(e, t);
              l.height = Math.abs(l.y.to - l.y.from), l.y = Math.min(l.y.to, l.y.from), l.x += g.offset, l.width = g.width;
            } else if (-1 !== s.type.indexOf("ohlc") || -1 !== s.type.indexOf("candlestick")) {
              let i2 = this._getColumnSerieWidthAndOffset(e, t), r2 = l.y;
              var f = Math.min(r2.Open, r2.Close, r2.Low, r2.High), p = Math.max(r2.Open, r2.Close, r2.Low, r2.High);
              l.height = Math.abs(p - f), l.y = f, l.x += i2.offset, l.width = i2.width;
            } else if (-1 !== s.type.indexOf("line") || -1 !== s.type.indexOf("area"))
              l.width = l.height = 0, l.y = l.y.to;
            else if (-1 !== s.type.indexOf("bubble") || -1 !== s.type.indexOf("scatter")) {
              l.center = { x: l.x, y: l.y.to };
              var c = l.y.radius;
              "circle" !== a.symbolType && void 0 !== a.symbolType && null !== a.symbolType && (c /= 2), l.y = l.y.to, l.radius = c, l.width = 2 * c, l.height = 2 * c;
            }
            if (l = this._fixCoords(l, e), s.polar || s.spider) {
              var m = this._toPolarCoord(this._renderData[e].polarCoords, this._plotRect, l.x, l.y);
              l.x = m.x, l.y = m.y, l.center && (l.center = this._toPolarCoord(this._renderData[e].polarCoords, this._plotRect, l.center.x, l.center.y));
            }
            return -1 === s.type.indexOf("bubble") && -1 === s.type.indexOf("scatter") || (l.x -= c, l.y -= c), l;
          }
          _getItemCoord(e, t, i) {
            let r, s, a = this.seriesGroups[e];
            if (!a || !this._renderData)
              return { x: NaN, y: NaN };
            if (!a.series[t])
              return { x: NaN, y: NaN };
            let l = this._plotRect;
            if (this._isPieGroup(e)) {
              let a2 = this._renderData[e].offsets[t][i];
              if (!a2)
                return { x: NaN, y: NaN };
              let n2 = (a2.fromAngle + a2.toAngle) / 2 * (Math.PI / 180);
              return r = l.x + a2.x + Math.cos(n2) * a2.outerRadius, s = l.y + a2.y - Math.sin(n2) * a2.outerRadius, { x: r, y: s, center: { x: a2.x, y: a2.y }, centerOffset: a2.centerOffset, innerRadius: a2.innerRadius, outerRadius: a2.outerRadius, selectedRadiusChange: a2.selectedRadiusChange, fromAngle: a2.fromAngle, toAngle: a2.toAngle };
            }
            if (r = l.x + this._renderData[e].xoffsets.data[i], s = this._renderData[e].offsets[t][i], isNaN(r) || !s)
              return { x: NaN, y: NaN };
            let n = {};
            for (let e2 in s)
              n[e2] = s[e2];
            return { x: r, y: n };
          }
          getXAxisValue(e, t) {
            var i = this.seriesGroups[t];
            if (i) {
              var r = this._getXAxis(t), s = this._plotRect, a = 0, l = NaN, n = this._renderData[0].xoffsets.axisStats, o = 0, h = 0;
              if (i.polar || i.spider) {
                if (isNaN(e.x) || isNaN(e.y))
                  return NaN;
                var d = this._getPolarAxisCoords(t, s);
                if (this.renderer._ptdist(e.x, e.y, d.x, d.y) > d.r)
                  return NaN;
                var u = Math.atan2(d.y - e.y, e.x - d.x);
                (u = Math.PI / 2 - u) < 0 && (u = 2 * Math.PI + u), l = u * d.r;
                var g = d.startAngle + Math.PI / 2, f = d.endAngle + Math.PI / 2;
                o = g * d.r, h = f * d.r, a = (f - g) * d.r;
                var p = this._getPaddingSize(n, r, r.valuesOnTicks, a, true, d.isClosedCircle, this._hasColumnSeries());
                d.isClosedCircle ? (a -= p.left + p.right, h -= p.left + p.right) : r.valuesOnTicks || (o += p.left, h -= p.right);
              } else {
                if ("horizontal" !== i.orientation) {
                  if (e < s.x || e > s.x + s.width)
                    return NaN;
                  l = e - s.x, a = s.width;
                } else {
                  if (e < s.y || e > s.y + s.height)
                    return NaN;
                  l = e - s.y, a = s.height;
                }
                if (this._renderData[t] && this._renderData[t].xoffsets) {
                  let e2 = this._renderData[t].xoffsets.padding;
                  a -= e2.left + e2.right, l -= e2.left;
                }
                h = a;
              }
              return this._smartPlot.scale(l, { min: o, max: h }, { min: n.min.valueOf(), max: n.max.valueOf(), type: n.logAxis.enabled ? "logarithmic" : "linear", base: n.logAxis.base, flip: r.flip });
            }
          }
          getValueAxisValue(e, t) {
            let i = this.seriesGroups[t];
            if (!i)
              return;
            let r = this._getValueAxis(t), s = this._plotRect, a = 0, l = NaN;
            if (i.polar || i.spider) {
              if (isNaN(e.x) || isNaN(e.y))
                return NaN;
              let i2 = this._getPolarAxisCoords(t, s);
              l = this.renderer._ptdist(e.x, e.y, i2.x, i2.y), a = i2.r, l = a - l;
            } else if ("horizontal" === i.orientation) {
              if (e < s.x || e > s.x + s.width)
                return NaN;
              l = e - s.x, a = s.width;
            } else {
              if (e < s.y || e > s.y + s.height)
                return NaN;
              l = e - s.y, a = s.height;
            }
            let n = this._stats.seriesGroups[t];
            return this._smartPlot.scale(l, { min: 0, max: a }, { min: n.min.valueOf(), max: n.max.valueOf(), type: n.logarithmic ? "logarithmic" : "linear", base: n.logBase, flip: !r.flip });
          }
          _detectDateFormat(e, t) {
            let i = { en_US_d: "M/d/yyyy", en_US_D: "dddd, MMMM dd, yyyy", en_US_t: "h:mm tt", en_US_T: "h:mm:ss tt", en_US_f: "dddd, MMMM dd, yyyy h:mm tt", en_US_F: "dddd, MMMM dd, yyyy h:mm:ss tt", en_US_M: "MMMM dd", en_US_Y: "yyyy MMMM", en_US_S: "yyyy'-'MM'-'dd'T'HH':'mm':'ss", en_CA_d: "dd/MM/yyyy", en_CA_D: "MMMM-dd-yy", en_CA_f: "MMMM-dd-yy h:mm tt", en_CA_F: "MMMM-dd-yy h:mm:ss tt", ISO: "yyyy-MM-dd hh:mm:ss", ISO2: "yyyy-MM-dd HH:mm:ss", d1: "dd.MM.yyyy", d2: "dd-MM-yyyy", zone1: "yyyy-MM-ddTHH:mm:ss-HH:mm", zone2: "yyyy-MM-ddTHH:mm:ss+HH:mm", custom: "yyyy-MM-ddTHH:mm:ss.fff", custom2: "yyyy-MM-dd HH:mm:ss.fff", de_DE_d: "dd.MM.yyyy", de_DE_D: "dddd, d. MMMM yyyy", de_DE_t: "HH:mm", de_DE_T: "HH:mm:ss", de_DE_f: "dddd, d. MMMM yyyy HH:mm", de_DE_F: "dddd, d. MMMM yyyy HH:mm:ss", de_DE_M: "dd MMMM", de_DE_Y: "MMMM yyyy", fr_FR_d: "dd/MM/yyyy", fr_FR_D: "dddd d MMMM yyyy", fr_FR_t: "HH:mm", fr_FR_T: "HH:mm:ss", fr_FR_f: "dddd d MMMM yyyy HH:mm", fr_FR_F: "dddd d MMMM yyyy HH:mm:ss", fr_FR_M: "d MMMM", fr_FR_Y: "MMMM yyyy", it_IT_d: "dd/MM/yyyy", it_IT_D: "dddd d MMMM yyyy", it_IT_t: "HH:mm", it_IT_T: "HH:mm:ss", it_IT_f: "dddd d MMMM yyyy HH:mm", it_IT_F: "dddd d MMMM yyyy HH:mm:ss", it_IT_M: "dd MMMM", it_IT_Y: "MMMM yyyy", ru_RU_d: "dd.MM.yyyy", ru_RU_D: "d MMMM yyyy '?.'", ru_RU_t: "H:mm", ru_RU_T: "H:mm:ss", ru_RU_f: "d MMMM yyyy '?.' H:mm", ru_RU_F: "d MMMM yyyy '?.' H:mm:ss", ru_RU_Y: "MMMM yyyy", cs_CZ_d: "d.M.yyyy", cs_CZ_D: "d. MMMM yyyy", cs_CZ_t: "H:mm", cs_CZ_T: "H:mm:ss", cs_CZ_f: "d. MMMM yyyy H:mm", cs_CZ_F: "d. MMMM yyyy H:mm:ss", cs_CZ_M: "dd MMMM", cs_CZ_Y: "MMMM yyyy", he_IL_d: "dd MMMM yyyy", he_IL_D: "dddd dd MMMM yyyy", he_IL_t: "HH:mm", he_IL_T: "HH:mm:ss", he_IL_f: "dddd dd MMMM yyyy HH:mm", he_IL_F: "dddd dd MMMM yyyy HH:mm:ss", he_IL_M: "dd MMMM", he_IL_Y: "MMMM yyyy", hr_HR_d: "d.M.yyyy.", hr_HR_D: "d. MMMM yyyy.", hr_HR_t: "H:mm", hr_HR_T: "H:mm:ss", hr_HR_f: "d. MMMM yyyy. H:mm", hr_HR_F: "d. MMMM yyyy. H:mm:ss", hr_HR_M: "d. MMMM", hu_HU_d: "yyyy.MM.dd.", hu_HU_D: "yyyy. MMMM d.", hu_HU_t: "H:mm", hu_HU_T: "H:mm:ss", hu_HU_f: "yyyy. MMMM d. H:mm", hu_HU_F: "yyyy. MMMM d. H:mm:ss", hu_HU_M: "MMMM d.", hu_HU_Y: "yyyy. MMMM", jp_JP_d: "gg y/M/d", jp_JP_D: "gg y'?'M'?'d'?'", jp_JP_t: "H:mm", jp_JP_T: "H:mm:ss", jp_JP_f: "gg y'?'M'?'d'?' H:mm", jp_JP_F: "gg y'?'M'?'d'?' H:mm:ss", jp_JP_M: "M'?'d'?'", jp_JP_Y: "gg y'?'M'?'", lt_LT_d: "yyyy.MM.dd", lt_LT_D: "yyyy 'm.' MMMM d 'd.'", lt_LT_t: "HH:mm", lt_LT_T: "HH:mm:ss", lt_LT_f: "yyyy 'm.' MMMM d 'd.' HH:mm", lt_LT_F: "yyyy 'm.' MMMM d 'd.' HH:mm:ss", lt_LT_M: "MMMM d 'd.'", lt_LT_Y: "yyyy 'm.' MMMM", sa_IN_d: "dd-MM-yyyy", sa_IN_D: "dd MMMM yyyy dddd", sa_IN_t: "HH:mm", sa_IN_T: "HH:mm:ss", sa_IN_f: "dd MMMM yyyy dddd HH:mm", sa_IN_F: "dd MMMM yyyy dddd HH:mm:ss", sa_IN_M: "dd MMMM", basic_y: "yyyy", basic_ym: "yyyy-MM", basic_d: "yyyy-MM-dd", basic_dhm: "yyyy-MM-dd hh:mm", basic_bhms: "yyyy-MM-dd hh:mm:ss", basic2_ym: "MM-yyyy", basic2_d: "MM-dd-yyyy", basic2_dhm: "MM-dd-yyyy hh:mm", basic2_dhms: "MM-dd-yyyy hh:mm:ss", basic3_ym: "yyyy/MM", basic3_d: "yyyy/MM/dd", basic3_dhm: "yyyy/MM/dd hh:mm", basic3_bhms: "yyyy/MM/dd hh:mm:ss", basic4_ym: "MM/yyyy", basic4_d: "MM/dd/yyyy", basic4_dhm: "MM/dd/yyyy hh:mm", basic4_dhms: "MM/dd/yyyy hh:mm:ss" };
            t && (i = Object.assign({}, i, t));
            let r = [];
            Array.isArray(e) ? r = e : r.push(e);
            for (let e2 in i)
              i[e2] = { format: i[e2], count: 0 };
            for (let e2 = 0; e2 < r.length; e2++) {
              const t2 = r[e2];
              if (null != t2)
                for (let e3 in i)
                  try {
                    (t2 instanceof Date || Smart.Utilities.DateTime.parseDateString(t2, void 0, i[e3].format)) && i[e3].count++;
                  } catch (e4) {
                  }
            }
            let s = { key: void 0, count: 0 };
            for (let e2 in i)
              i[e2].count > s.count && (s.key = e2, s.count = i[e2].count);
            return s.key ? i[s.key].format : "";
          }
          _testXAxisDateFormat(e) {
            let t = this, i = t._getXAxis(e), r = t._getDataLen(e), s = {};
            if (t.localization.patterns)
              for (let e2 in t.localization.patterns)
                s["local_" + e2] = t.localization.patterns[e2];
            let a = [];
            for (let s2 = 0; s2 < r && s2 < 10; s2++) {
              const r2 = t._getDataValue(s2, i.dataField, e);
              null != r2 && a.push(r2);
            }
            return t._detectDateFormat(a, s);
          }
          _getThemeColor(e) {
            if ("light" === this.theme)
              switch (e) {
                case "background":
                  return "#FFFFFF";
                case "line":
                  return "#BCBCBC";
                case "band":
                  return "#AAAAAA";
              }
            switch (e) {
              case "background":
                return "#2E2E2E";
              case "line":
                return "#707070";
              case "band":
                return "#565656";
            }
          }
        });
      }
    ),
    /***/
    2157: (
      /***/
      () => {
        Smart.Chart && (Smart.Chart.prototype._moduleRangeSelector = true, Smart.Chart.prototype._renderXAxisRangeSelector = function(e, t) {
          const i = this, r = i.seriesGroups[e], s = i._getXAxis(e), o = s ? s.rangeSelector : void 0;
          if (!i._isSelectorRefresh) {
            const e2 = (o && o.renderTo ? o.renderTo : i).getElementsByClassName("smart-chart-range-selector")[0];
            e2 && e2.parentElement.removeChild(e2);
          }
          if (!s || false === s.visible || "spider" === r.type)
            return false;
          if (!i._isGroupVisible(e))
            return false;
          if (!o)
            return false;
          let a = "horizontal" === r.orientation;
          o.renderTo && (a = false), i.rightToLeft && (s.flip = true);
          let l = a ? i.offsetHeight : i.offsetWidth;
          l -= 4;
          const n = this._getXAxisStats(e, s, l);
          let h = s.position;
          if (o.renderTo && o.position && (h = o.position), !this._isSelectorRefresh) {
            const i2 = o.renderTo, r2 = document.createElement("div");
            if (r2.className = "smart-chart-range-selector smart-unselectable", r2.style.position = "absolute", r2.style.backgroundColor = "transparent", r2.style.onselectstart = function() {
              return false;
            }, i2)
              i2.appendChild(r2), r2.style.width = i2.offsetWidth + "px", r2.style.height = i2.offsetHeight + "px", t.width = i2.offsetWidth, t.height = i2.offsetHeight;
            else {
              this.renderer.getContainer().appendChild(r2);
              const e2 = this._selectorGetSize(s);
              a ? (r2.style.left = 1 + t.x + ("right" !== h ? -e2 : t.width) + "px", r2.style.top = "0", r2.style.height = l + "px", r2.style.width = e2 + "px", t.height = e2) : (r2.style.left = "2px", r2.style.top = t.y + ("top" !== h ? t.height : -e2) + "px", r2.style.height = e2 + "px", r2.style.width = l - 1 + "px");
            }
            r2.parentDiv = r2.parentElement, this._refreshSelector(e, s, n, r2, t, a);
          }
          return this._isSelectorRefresh = false, true;
        }, Smart.Chart.prototype._refreshSelector = function(e, t, i, r, s, o) {
          const a = this, l = {}, n = t.rangeSelector;
          for (let e2 in n)
            l[e2] = n[e2];
          delete l.padding;
          let h = l.minValue, d = l.maxValue;
          isNaN(h) && (h = Math.min(i.min.valueOf(), i.dsRange.min.valueOf())), isNaN(d) && (d = Math.max(i.max.valueOf(), i.dsRange.max.valueOf())), this._isDate(i.min) && (h = new Date(h)), this._isDate(i.max) && (d = new Date(d));
          let p = t.position;
          n.renderTo && n.position && (p = n.position), l.dataField = t.dataField, delete l.rangeSelector, l.type = t.type, l.baseUnit = null !== n.baseUnit ? n.baseUnit : t.baseUnit, l.minValue = h, l.maxValue = d, l.flip = t.flip, l.position = p;
          let g = 2, u = 2, c = 2, f = 2;
          n.renderTo || (g = o ? 0 : s.x, u = o ? 0 : this._rect.width - s.x - s.width, c = o ? s.y : 5, f = o ? this._paddedRect.height - this._plotRect.height : 5);
          let m = n.padding;
          m = null != m || n.renderTo ? { left: m && m.left ? m.left : g, top: m && m.top ? m.top : c, right: m && m.right ? m.right : u, bottom: m && m.bottom ? m.bottom : f } : { left: g, top: c, right: u, bottom: f };
          let x = n.dataField;
          for (let e2 = 0; null == x && e2 < this.seriesGroups.length; e2++)
            for (let t2 = 0; null == x && t2 < this.seriesGroups[e2].series.length; t2++)
              x = this.seriesGroups[e2].series[t2].dataField;
          const y = { parentChart: this, padding: m, _isRangeSelectorInstance: true, theme: this.theme, caption: n.caption, description: n.description, titlePadding: n.titlePadding, colorScheme: n.colorScheme || this.colorScheme, backgroundColor: n.backgroundColor || this.backgroundColor || a._getThemeColor("background"), backgroundImage: n.backgroundImage, showBorderLine: null !== n.showBorderLine ? n.showBorderLine : !!n.renderTo, borderLineWidth: n.borderLineWidth || this.borderLineWidth, borderLineColor: n.borderLineColor || this.borderLineColor || a._getThemeColor("line"), rightToLeft: null !== n.rightToLeft ? n.rightToLeft : this.rightToLeft, greyScale: null !== n.greyScale ? n.greyScale : this.greyScale, renderEngine: this.renderEngine, showLegend: false, animation: "none", enableEvents: false, showToolTips: false, dataSource: this.dataSource, xAxis: l, seriesGroups: [{ orientation: o ? "horizontal" : "vertical", valueAxis: { visible: false }, type: n.serieType, skipOverlappingPoints: n.skipOverlappingPoints, columnSeriesOverlap: n.columnSeriesOverlap, columnsGapPercent: n.columnsGapPercent, seriesGapPercent: n.seriesGapPercent, series: [{ dataField: x, opacity: 0.8, lineWidth: 1 }] }] };
          n.seriesGroups && (y.seriesGroups = n.seriesGroups), n.valueAxis.visible && (y.valueAxis = n.valueAxis), y.showBorderLine || (y.borderLineWidth = 1, y.borderLineColor = a._get([this.backgroundColor, this.background, a._getThemeColor("background")]), y.showBorderLine = true), a._supressBindingRefresh = true, r.innerHTML = "";
          const _ = document.createElement("smart-chart");
          _.rightToLeft = a.rightToLeft, _.parentDiv = r;
          for (let e2 in y)
            _[e2] = y[e2];
          r.appendChild(_), a._rangeSelectorInstances[e] = _, a._supressBindingRefresh = false;
          const S = function() {
            if (!_._plotRect)
              return;
            const t2 = _._paddedRect;
            if (t2.height = _._plotRect.height, o || "top" !== p) {
              if (o) {
                const e2 = _._renderData[0].xAxis.rect.width;
                t2.width -= e2, "right" !== p && (t2.x += e2);
              }
            } else
              t2.y += _._renderData[0].xAxis.rect.height;
            if (a._createSliderElements(e, r, t2, n, { min: l.minValue, max: l.maxValue }), a._rangeSelectorEventData = { groupIndex: e, renderTo: r, swapXY: o }, a.hasAttribute("aria-owns")) {
              const e2 = a.getAttribute("aria-owns");
              a.setAttribute("aria-owns", e2 + " " + _.id);
            } else
              a.setAttribute("aria-owns", _.id);
          };
          _.isRendered ? S() : _.whenRendered(() => {
            S();
          });
        }, Smart.Chart.prototype._createSliderElements = function(e, t, i, r, s) {
          const o = this, a = t.getElementsByClassName("slider")[0];
          a && a.parentElement.removeChild(a);
          const l = r.selectedRangeColor || "blue", n = o._get([r.selectedRangeOpacity, 0.1]), h = o._get([r.unselectedRangeOpacity, 0.5]), d = r.unselectedRangeColor || "white", p = r.rangeLineColor || "grey", g = document.createElement("div");
          for (g.className = "slider", g.style.position = "absolute", g.style.background = l, g.style.opacity = n, g.style.left = i.x + "px", g.style.top = i.y + "px", g.style.width = i.width + "px", g.style.height = i.height + "px", t.appendChild(g); this._sliders.length < e + 1; )
            this._sliders.push({});
          function u(e2, t2) {
            const i2 = document.createElement("div");
            return i2.className = "slider", i2.style.position = "absolute", i2.style.background = e2, i2.style.opacity = t2, i2;
          }
          function c() {
            const e2 = document.createElement("div");
            return e2.className = "slider", e2.style.position = "absolute", e2.style.background = "#FFFFFF", e2.style.borderStyle = "solid", e2.style.borderWidth = "1px", e2.style.borderRadius = "3px", e2.style.borderColor = p, e2.setAttribute("role", "slider"), e2.setAttribute("aria-controls", o.id), e2;
          }
          const f = g.getBoundingClientRect(), m = t.getBoundingClientRect();
          this._sliders[e] = { element: g, host: t.firstElementChild, _sliderInitialAbsoluteRect: { x: f.left, y: f.top, width: i.width, height: i.height }, _hostInitialAbsolutePos: { x: m.left, y: m.top }, getRect: function() {
            const e2 = t.getBoundingClientRect();
            return { x: e2.left - this._hostInitialAbsolutePos.x + this._sliderInitialAbsoluteRect.x, y: e2.top - this._hostInitialAbsolutePos.y + this._sliderInitialAbsoluteRect.y, width: this._sliderInitialAbsoluteRect.width, height: this._sliderInitialAbsoluteRect.height };
          }, rect: i, left: u(d, h), right: u(d, h), leftTop: u(p, h), rightTop: u(p, h), leftBorder: u(p, h), leftBar: c(), rightBorder: u(p, h), rightBar: c() };
          const x = this._sliders[e];
          t.appendChild(x.left), t.appendChild(x.right), t.appendChild(x.leftTop), t.appendChild(x.rightTop), t.appendChild(x.leftBorder), t.appendChild(x.rightBorder), t.appendChild(x.leftBar), t.appendChild(x.rightBar);
          const y = this._renderData[e].xAxis.data.axisStats, _ = y.min.valueOf(), S = y.max.valueOf();
          "number" == typeof y.min ? (x.leftBar.setAttribute("aria-valuemin", s.min), x.leftBar.setAttribute("aria-valuemax", s.max), x.leftBar.setAttribute("aria-valuenow", _), x.rightBar.setAttribute("aria-valuemin", s.min), x.rightBar.setAttribute("aria-valuemax", s.max), x.rightBar.setAttribute("aria-valuenow", S)) : (x.leftBar.setAttribute("aria-valuemin", s.min.getTime()), x.leftBar.setAttribute("aria-valuemax", s.max.getTime()), x.leftBar.setAttribute("aria-valuenow", y.min.getTime()), x.leftBar.setAttribute("aria-valuetext", y.min.toLocaleString()), x.rightBar.setAttribute("aria-valuemin", s.min.getTime()), x.rightBar.setAttribute("aria-valuemax", s.max.getTime()), x.rightBar.setAttribute("aria-valuenow", y.max.getTime()), x.rightBar.setAttribute("aria-valuetext", y.max.toLocaleString()));
          let b = this._valueToOffset(e, _), v = this._valueToOffset(e, S);
          if (b > v) {
            const e2 = v;
            v = b, b = e2;
          }
          "horizontal" !== this.seriesGroups[e].orientation ? (g.style.left = Math.round(i.x + b) + "px", g.style.top = i.y + "px", g.style.width = Math.round(v - b) + "px", g.style.height = i.height + "px") : (g.style.left = i.x + "px", g.style.top = Math.round(i.y + b) + "px", g.style.width = i.width + "px", g.style.height = Math.round(v - b) + "px"), this._setSliderPositions(e, b, v);
        }, Smart.Chart.prototype._setSliderPositions = function(e, t, i) {
          const r = this.seriesGroups[e], s = this._getXAxis(e), o = s.rangeSelector;
          let a = "horizontal" === r.orientation;
          s.rangeSelector.renderTo && (a = false);
          let l = s.position;
          o.renderTo && o.position && (l = o.position);
          const n = this._sliders[e], h = a ? "top" : "left", d = a ? "left" : "top", p = a ? "height" : "width", g = a ? "width" : "height", u = a ? "y" : "x", c = a ? "x" : "y", f = n.rect;
          n.startOffset = t, n.endOffset = i, n.left.style[h] = f[u] + "px", n.left.style[d] = f[c] + "px", n.left.style[p] = t + "px", n.left.style[g] = f[g] + "px", n.right.style[h] = f[u] + i + "px", n.right.style[d] = f[c] + "px", n.right.style[p] = f[p] - i + 1 + "px", n.right.style[g] = f[g] + "px", n.leftTop.style[h] = f[u] + "px", n.leftTop.style[d] = f[c] + (a && "right" === l || !a && "top" !== l ? 0 : f[g]) + "px", n.leftTop.style[p] = t + "px", n.leftTop.style[g] = "1px", n.rightTop.style[h] = f[u] + i + "px", n.rightTop.style[d] = f[c] + (a && "right" === l || !a && "top" !== l ? 0 : f[g]) + "px", n.rightTop.style[p] = f[p] - i + 1 + "px", n.rightTop.style[g] = "1px", n.leftBorder.style[h] = f[u] + t + "px", n.leftBorder.style[d] = f[c] + "px", n.leftBorder.style[p] = "1px", n.leftBorder.style[g] = f[g] + "px";
          let m = f[g] / 4;
          m > 20 && (m = 20), m < 3 && (m = 3), n.leftBar.style[h] = f[u] + t - 3 + "px", n.leftBar.style[d] = f[c] + f[g] / 2 - m / 2 + "px", n.leftBar.style[p] = "5px", n.leftBar.style[g] = m + "px", n.rightBorder.style[h] = f[u] + i + "px", n.rightBorder.style[d] = f[c] + "px", n.rightBorder.style[p] = "1px", n.rightBorder.style[g] = f[g] + "px", n.rightBar.style[h] = f[u] + i - 3 + "px", n.rightBar.style[d] = f[c] + f[g] / 2 - m / 2 + "px", n.rightBar.style[p] = "5px", n.rightBar.style[g] = m + "px";
        }, Smart.Chart.prototype._resizeState = {}, Smart.Chart.prototype._onSliderMouseDown = function(e) {
          e.stopImmediatePropagation(), e.stopPropagation();
          const t = this;
          t._sliders[t._rangeSelectorEventData.groupIndex] && (void 0 !== t._resizeState.state && null !== t._resizeState.state || t._testAndSetReadyResize(e), "ready" === t._resizeState.state && (t._draggingRangeSelector = true, t._resizeState.state = "resizing"));
        }, Smart.Chart.prototype._valueToOffset = function(e, t) {
          const i = this.seriesGroups[e], r = this._sliders[e], s = r.host._renderData[0].xAxis.data.axisStats, o = s.min.valueOf();
          let a = s.max.valueOf() - o;
          0 === a && (a = 1);
          const l = this._getXAxis(e), n = "horizontal" === i.orientation ? "height" : "width", h = (t.valueOf() - o) / a;
          return r.getRect()[n] * (l.flip ? 1 - h : h);
        }, Smart.Chart.prototype._offsetToValue = function(e, t) {
          const i = this._sliders[e], r = this.seriesGroups[e], s = this._getXAxis(e), o = "horizontal" === r.orientation ? "height" : "width";
          let a = i.getRect()[o];
          0 === a && (a = 1);
          const l = i.host._renderData[0].xAxis.data.axisStats, n = l.min.valueOf(), h = l.max.valueOf();
          let d = t / a * (h - n) + n;
          return true === s.flip && (d = h - t / a * (h - n)), this._isDate(l.min) || this._isDate(l.max) ? d = new Date(d) : ((void 0 === s.dataField || null === s.dataField || l.useIndeces) && (d = Math.round(d)), d < l.min && (d = l.min), d > l.max && (d = l.max)), d;
        }, Smart.Chart.prototype._onSliderMouseUp = function(e) {
          const t = this, i = t._rangeSelectorEventData.groupIndex, r = t._rangeSelectorEventData.swapXY, s = t._sliders[i];
          if (delete t._draggingRangeSelector, !s)
            return;
          if ("resizing" !== t._resizeState.state)
            return;
          e.stopImmediatePropagation(), e.stopPropagation(), t._resizeState = {}, t.style.cursor = "default";
          const o = r ? "top" : "left", a = r ? "y" : "x", l = s.element.getBoundingClientRect()[o], n = l + (r ? s.element.offsetHeight : s.element.offsetWidth), h = s.getRect();
          let d = t._offsetToValue(i, l - h[a]), p = t._offsetToValue(i, n - h[a]);
          !s.host._renderData[0].xAxis.data.axisStats.isTimeUnit && p.valueOf() - d.valueOf() > 864e5 && (d.setHours(0, 0, 0, 0), p.setDate(p.getDate() + 1), p.setHours(0, 0, 0, 0));
          const g = t._getXAxis(i);
          if (g.flip) {
            const e2 = d;
            d = p, p = e2;
          }
          for (let e2 = 0; e2 < t.seriesGroups.length; e2++)
            t._getXAxis(e2) === g && (t._selectorRange[e2] = { min: d, max: p });
          t._isSelectorRefresh = true;
          const u = t.animation;
          t.$.fireEvent("rangeSelectionChanging", { instance: t, minValue: d, maxValue: p }), t.animation = "none", t.update(), t.animation = u, t.$.fireEvent("rangeSelectionChanged", { instance: t, minValue: d, maxValue: p }), "number" == typeof d ? (s.leftBar.setAttribute("aria-valuenow", d), s.rightBar.setAttribute("aria-valuenow", p)) : (s.leftBar.setAttribute("aria-valuenow", d.getTime()), s.leftBar.setAttribute("aria-valuetext", d.toLocaleString()), s.rightBar.setAttribute("aria-valuenow", p.getTime()), s.rightBar.setAttribute("aria-valuetext", p.toLocaleString()));
        }, Smart.Chart.prototype._onSliderMouseMove = function(e) {
          const t = this, i = t._rangeSelectorEventData.groupIndex, r = t._sliders[i], s = t._rangeSelectorEventData.swapXY;
          if (!r)
            return;
          const o = r.getRect(), a = r.element, l = { left: e.clientX, top: e.clientY }, n = a.getBoundingClientRect(), h = s ? "top" : "left", d = parseFloat(getComputedStyle(a)[h]), p = s ? "height" : "width", g = s ? "y" : "x";
          if ("resizing" === t._resizeState.state) {
            if (e.stopImmediatePropagation(), e.stopPropagation(), "left" === t._resizeState.side) {
              let e2 = Math.round(l[h] - n[h]), t2 = o[g];
              if (n[h] + e2 >= t2 && n[h] + e2 <= t2 + o[p]) {
                let t3 = parseInt(d), i2 = Math.max(2, (s ? a.offsetHeight : a.offsetWidth) - e2);
                a.style[p] = i2 + "px", a.style[h] = t3 + e2 + "px";
              }
            } else if ("right" === t._resizeState.side) {
              let e2 = s ? a.offsetHeight : a.offsetWidth, t2 = Math.round(l[h] - n[h] - e2), i2 = o[g];
              if (n[h] + e2 + t2 >= i2 && n[h] + t2 + e2 <= i2 + o[p]) {
                let i3 = Math.max(2, e2 + t2);
                a.style[p] = i3 + "px";
              }
            } else if ("move" === t._resizeState.side) {
              let e2 = s ? a.offsetHeight : a.offsetWidth, i2 = parseInt(d), r2 = Math.round(l[h] - t._resizeState.startPos);
              n[h] + r2 >= o[g] && n[h] + r2 + e2 <= o[g] + o[p] && (t._resizeState.startPos = l[h], a.style[h] = i2 + r2 + "px");
            }
            const u = parseInt(d) - r.rect[g], c = u + (s ? a.offsetHeight : a.offsetWidth);
            t._setSliderPositions(i, u, c);
          } else
            t._testAndSetReadyResize(e);
        }, Smart.Chart.prototype._testAndSetReadyResize = function(e) {
          const t = this, i = t._rangeSelectorEventData, r = i.renderTo, s = i.groupIndex, o = t._sliders[s], a = i.swapXY, l = o.getRect(), n = o.element, h = { left: e.clientX, top: e.clientY }, d = n.getBoundingClientRect(), p = a ? "left" : "top", g = a ? "top" : "left", u = a ? "width" : "height", c = t._isTouchDevice ? 30 : 5;
          h[p] >= d[p] && h[p] <= d[p] + l[u] ? Math.abs(h[g] - d[g]) <= c ? (r.style.cursor = a ? "row-resize" : "col-resize", t._resizeState = { state: "ready", side: "left" }) : Math.abs(h[g] - d[g] - (a ? n.offsetHeight : n.offsetWidth)) <= c ? (r.style.cursor = a ? "row-resize" : "col-resize", t._resizeState = { state: "ready", side: "right" }) : h[g] + c > d[g] && h[g] - c < d[g] + (a ? n.offsetHeight : n.offsetWidth) ? (r.style.cursor = "pointer", t._resizeState = { state: "ready", side: "move", startPos: h[g] }) : (r.style.cursor = "default", t._resizeState = {}) : (r.style.cursor = "default", t._resizeState = {});
        }, Smart.Chart.prototype._selectorGetSize = function(e) {
          return e.rangeSelector.renderTo ? 0 : e.rangeSelector.size || this._paddedRect.height / 3;
        });
      }
    ),
    /***/
    6541: (
      /***/
      () => {
        Smart.Chart && (Smart.Chart.prototype._moduleWaterfall = true, Smart.Chart.prototype._isSummary = function(t, e) {
          const a = this.seriesGroups[t];
          for (let i = 0; i < a.series.length; i++)
            if (void 0 !== a.series[i].summary && void 0 !== this._getDataValue(e, a.series[i].summary, t))
              return true;
          return false;
        }, Smart.Chart.prototype._applyWaterfall = function(t, e, a, i, s, r, o, l, u) {
          const f = this.seriesGroups[a];
          if (0 === t.length)
            return t;
          let n = i;
          const N = {}, h = [];
          let m;
          const v = [];
          for (let t2 = 0; t2 < f.series.length; t2++)
            v.push(this._isSerieVisible(a, t2));
          const c = {};
          for (let f2 = 0; f2 < e; f2++) {
            let e2 = i, p = 0;
            const _ = this._isSummary(a, f2);
            for (let a2 = 0; a2 < t.length; a2++) {
              if (!v[a2])
                continue;
              let g = 0;
              if (_) {
                g = e2 === i ? s : 0, t[a2][f2].value = N[a2], t[a2][f2].summary = true, m = t[a2][f2].value < g, l && (m = !m);
                let n2 = 0;
                n2 = isNaN(r) ? this._getDataPointOffsetDiff(t[a2][f2].value, g, g, NaN, o, i, l) : this._getDataPointOffsetDiff(t[a2][f2].value + p, 0 === p ? s : p, g || s, r, o, i, l), t[a2][f2].to = e2 + (m ? n2 : -n2), t[a2][f2].from = e2, u && (p += t[a2][f2].value, e2 = t[a2][f2].to);
                continue;
              }
              const y = u ? -1 : a2;
              if (isNaN(t[a2][f2].value))
                continue;
              void 0 === c[y] && (g = s, c[y] = true), m = t[a2][f2].value < g, l && (m = !m);
              let D = NaN;
              D = u ? n : 0 === f2 ? i : t[a2][h[a2]].to;
              let S = 0;
              S = isNaN(r) ? this._getDataPointOffsetDiff(t[a2][f2].value, g, g, NaN, o, i, l) : this._getDataPointOffsetDiff(t[a2][f2].value + (isNaN(N[y]) ? 0 : N[y]), isNaN(N[y]) ? s : N[y], g || s, r, o, D, l), t[a2][f2].to = n = D + (m ? S : -S), t[a2][f2].from = D, isNaN(N[y]) ? N[y] = t[a2][f2].value : N[y] += t[a2][f2].value, -1 === y && (isNaN(N[a2]) ? N[a2] = t[a2][f2].value : N[a2] += t[a2][f2].value), u || (h[a2] = f2);
            }
          }
          return t;
        });
      }
    ),
    /***/
    6057: (
      /***/
      () => {
        (() => {
          Smart.DataAdapter = window.smartDataAdapter = class {
            constructor(e2) {
              e2 || (e2 = {});
              const t = Object.assign(this, e2);
              t.key = (65536 * (1 + Math.random()) | 0).toString(16).substring(1), t.$document = Smart.Utilities.Extend(document), t.boundSource = false === t.observable || t.virtualDataSource ? [] : new Smart.ObservableArray(), t.dataItemById = [], void 0 === t.allowAdd && (t.allowAdd = true), void 0 === t.allowRemove && (t.allowRemove = true), void 0 === t.allowUpdate && (t.allowUpdate = true), void 0 === t.mapChar && (t.mapChar = "."), void 0 !== e2.observable || t.virtualDataSource ? t.observable = false : t.observable = true, void 0 === t.sanitizeHTML && (t.sanitizeHTML = "blackList"), t._expandedRowIds = [], e2.dataSource || (t.dataSource = []), e2.dataFields || (t.dataFields = []), e2.dataSourceType || (t.dataSourceType = "array"), e2.id || (t.id = null), e2.autoFetch || (t.autoFetch = true), void 0 === e2.skipFirstRow && (t.skipFirstRow = false), e2.dataFields && (t.dataFields = e2.dataFields), Object.defineProperty(t, "groupBy", { configurable: false, enumerable: true, get: () => t._groupBy ? t._groupBy : [], set(e3) {
                const a = () => {
                  t.boundHierarchy = null, t.refreshHierarchy(), t.onGroup && t.onGroup();
                };
                t._groupBy = new Smart.ObservableArray(e3), t._groupBy.notify(function() {
                  a();
                }), t.isInitialized && a();
              } }), e2.groupBy ? e2.groupBy.toArray ? t.groupBy = e2.groupBy.toArray() : t.groupBy = e2.groupBy : t.groupBy = [], e2 && false !== e2.autoBind && t.dataBind(), t.isInitialized = true;
            }
            beginUpdate() {
              this.isUpdating = true;
            }
            endUpdate() {
              const e2 = this;
              e2.isUpdating = false, e2.refreshIndexes(), e2.refreshHierarchy();
            }
            get expandHierarchy() {
              return void 0 === this._expandHierarchy && (this._expandHierarchy = false), this._expandHierarchy;
            }
            set expandHierarchy(e2) {
              const t = this;
              t._expandHierarchy = e2, t.isInitialized && t.refreshHierarchy();
            }
            _getDataField(e2) {
              switch (e2.name) {
                case "leaf":
                case "parent":
                case "expanded":
                case "checked":
                case "selected":
                case "level":
                case "icon":
                case "data":
                case "group":
                case "children":
                case "items":
                  e2.map ? e2.map = e2.map.replace(e2.name, "$" + e2.name) : e2.map = e2.name, e2.name = "$" + e2.name;
              }
            }
            get dataFields() {
              return this._dataFields;
            }
            set dataFields(e2) {
              const t = this;
              return t._dataFields = t._getDataFieldObjects(e2), t._dataFields;
            }
            _getDataFieldObjects(e2) {
              const t = this;
              let a = [];
              if ("number" == typeof e2) {
                const t2 = "A".charCodeAt(0);
                let n = "", r = 0;
                for (let i = 0; i < e2; i++) {
                  const e3 = String.fromCharCode(t2 + r);
                  r++;
                  const i2 = n + e3;
                  a.push({ name: i2, dataType: "string" }), r >= 26 && (r = 0, n += "A");
                }
              } else if (Array.isArray(e2) && e2.length > 0)
                for (let n = 0; n < e2.length; n++) {
                  const r = e2[n];
                  if ("string" == typeof r) {
                    const e3 = r.split(":"), t2 = e3[0].trim(), n2 = e3.length > 1 ? e3[1].trim() : "string";
                    a.push({ name: t2, dataType: n2 });
                  } else
                    a.push(r);
                  t._getDataField(a[a.length - 1]);
                }
              return a;
            }
            get dataSource() {
              const e2 = this;
              return e2._dataSource || (e2._dataSource = []), e2._dataSource;
            }
            set dataSource(e2) {
              const t = this;
              t._dataSource = e2, t.isInitialized && (t.boundSource = false === t.observable || t.virtualDataSource ? [] : new Smart.ObservableArray(), t.dataItemById = [], t.bindingCompleted = false, t.dataBind(), t.refreshIndexes());
            }
            get canNotify() {
              const e2 = this;
              return void 0 === e2._canNotify && (e2._canNotify = true), e2._canNotify;
            }
            set canNotify(e2) {
              this._canNotify = e2;
            }
            _notify(e2) {
              const t = this;
              t.canNotify && t.notifyFn && t.notifyFn(e2);
            }
            notify(e2) {
              e2 && (this.notifyFn = e2);
            }
            toArray() {
              const e2 = this;
              return false === e2.observable ? e2.boundSource : e2.boundSource.toArray();
            }
            forEach(e2) {
              const t = this;
              if (e2)
                if (t.boundHierarchy && t.boundHierarchy.length > 0) {
                  const a = ((e3) => {
                    let t2 = [];
                    for (; e3; ) {
                      t2 = t2.concat(e3);
                      for (let a2 = 0; a2 < e3.length; a2++)
                        e3[a2].children && (t2 = t2.concat(e3[a2].children));
                      e3 = e3.children;
                    }
                    return t2;
                  })(t.boundHierarchy);
                  for (let t2 = 0; t2 < a.length; t2++) {
                    e2(a[t2], t2);
                  }
                } else
                  for (let a = 0; a < t.boundSource.length; a++) {
                    e2(t.boundSource[a], a);
                  }
            }
            dataBind() {
              const t = this;
              t.bindingCompleted = false, t.clear();
              const a = () => {
                t.observable && (t.boundSource.notify || (t.boundSource = new Smart.ObservableArray()), t.boundSource.notify(function(e2) {
                  if ("update" === e2.action && e2.path && e2.path.indexOf(".") >= 0 && -1 === e2.path.indexOf("children") && -1 === e2.path.indexOf("parent") && -1 === e2.path.indexOf("loaded") && -1 === e2.path.indexOf("level") && -1 === e2.path.indexOf("leaf") && -1 === e2.path.indexOf("expanded")) {
                    let a2 = false;
                    for (let n = 0; n < t.dataFields.length; n++) {
                      const r = t.dataFields[n].name;
                      e2.path.indexOf(r) >= 0 && (a2 = true);
                    }
                    t._notify && a2 && t._notify({ action: "update", data: e2.target, index: e2.index });
                  }
                })), t._onBindingComplete();
              };
              if ("string" == typeof t.dataSource && (t.dataSource.indexOf(".json") >= 0 || "json" === t.dataSourceType))
                t.url = t.dataSource, t.dataSourceType = "json", new e(t, (e2) => {
                  t.dataSource = e2;
                });
              else if ("string" == typeof t.dataSource && t.dataSource.indexOf(".xml") >= 0)
                t.url = t.dataSource, t.dataSourceType = "xml", new e(t, (e2) => {
                  t.dataSource = e2;
                });
              else if ("string" == typeof t.dataSource && t.dataSource.indexOf(".xlsx") >= 0)
                t.url = t.dataSource, t.dataSourceType = "xlsx", new e(t, (e2) => {
                  if (!e2[0])
                    return e2 = [], t._bindToArray(), void a();
                  const n = Object.keys(e2[0]), r = {}, i = [];
                  if (false !== t.exportHeader) {
                    let a2 = 0;
                    for (let e3 in n) {
                      r[n[e3]] = t.dataFields[a2++].name;
                    }
                    for (let t2 = 1; t2 < e2.length; t2++) {
                      const a3 = e2[t2], o = {};
                      for (let e3 in n) {
                        const t3 = n[e3];
                        o[r[t3]] = a3[t3];
                      }
                      i.push(o);
                    }
                    t.dataSource = i;
                  }
                  t._bindToArray(), a();
                });
              else if ("string" == typeof t.dataSource && t.dataSource.indexOf(".csv") >= 0)
                t.url = t.dataSource, t.dataSourceType = "csv", new e(t, (e2) => {
                  t.dataSource = e2;
                });
              else if ("string" == typeof t.dataSource && t.dataSource.indexOf(".tsv") >= 0)
                t.url = t.dataSource, t.dataSourceType = "tsv", new e(t, (e2) => {
                  t.dataSource = e2;
                });
              else if ("string" == typeof t.dataSource && (t.dataSource.indexOf(".ics") >= 0 || t.dataSource.indexOf(".php") >= 0 && "ics" === t.dataSourceType || t.dataSource.indexOf(".txt") >= 0 && "ics" === t.dataSourceType))
                t.url = t.dataSource, t.dataSourceType = "ics", new e(t, (e2) => {
                  t.dataSource = e2;
                });
              else if ("string" == typeof t.dataSource && (t.dataSource.indexOf("BEGIN:VCALENDAR") >= 0 || "ics" === t.dataSourceType))
                t._bindToICS(), a();
              else if ("string" == typeof t.dataSource && (t.dataSource.indexOf("<?xml") >= 0 || "xml" === t.dataSourceType))
                t._bindToXML(), a();
              else if ("string" == typeof t.dataSource && (t.dataSource.indexOf("  ") >= 0 || t.dataSource.indexOf(",") >= 0 || "tsv" === t.dataSourceType || "csv" === t.dataSourceType || "tab" === t.dataSourceType))
                t._bindToCSV(), a();
              else if ("array" === t.dataSourceType)
                t._bindToArray(), a();
              else if ("json" === t.dataSourceType) {
                if (t.dataSource && t.dataSource.url)
                  return t.url = t.dataSource.url, t.dataSource.method && (t.type = t.dataSource.method), t.dataSource.type && (t.type = t.dataSource.type), t.dataSource.data && (t.data = t.dataSource.data), void new e(t, (e2) => {
                    t.dataSource = e2;
                  });
                t._bindToJSON(), a();
              }
            }
            _bindToXML() {
              const e2 = this;
              let t = null, a = null;
              window.DOMParser && (t = new DOMParser(), a = t.parseFromString(e2.dataSource, "text/xml")), void 0 === e2.root && (e2.root = ""), void 0 === e2.record && (e2.record = "");
              const n = a.querySelectorAll(e2.root + " " + e2.record), r = n.length, i = [];
              let o = e2.dataFields ? e2.dataFields.length : 0;
              if (0 === o) {
                const t2 = n[0], a2 = new Array();
                for (let e3 in t2) {
                  const t3 = e3;
                  a2[a2.length] = { name: t3 };
                }
                e2.dataFields = a2, o = a2.length;
              }
              for (let t2 = 0; t2 < r; t2++) {
                const a2 = n[t2], r2 = {};
                if (void 0 === a2)
                  break;
                if (e2.id) {
                  const t3 = a2.querySelector(e2.id);
                  r2[e2.id] = t3.textContent;
                }
                for (let t3 = 0; t3 < o; t3++) {
                  const n2 = e2.dataFields[t3], i2 = a2.querySelector(n2.map || n2.name);
                  r2[n2.name] = i2.textContent;
                }
                i[t2] = r2;
              }
              e2.canNotify = false, e2.dataSource = i, e2.canNotify = true, e2._bindToArray();
            }
            static BindToCSV(e2, t = false) {
              const a = "" + e2, n = -1 === a.indexOf(",") ? "	" : ",", r = a.split("\r"), i = new Array(), o = [];
              let d = a.split("\n"), l = d.length;
              1 === l && r.length > 1 && (d = r, l = d.length);
              const s = true === t;
              for (let e3 = 0; e3 < l; e3++) {
                const t2 = {}, a2 = d[e3].split(n);
                for (let n2 = 0; n2 < a2.length; n2++) {
                  let r2 = o[n2], i2 = a2[n2];
                  if (r2 || (o.push({ name: i2.trim() }), r2 = o[o.length - 1]), i2 = i2.trim(), 1 !== e3 || s)
                    switch (r2.dataType) {
                      case "boolean":
                        i2 = "false" !== i2;
                        break;
                      case "number":
                        i2 = parseFloat(i2);
                        break;
                      case "date":
                        i2 = new Date(i2);
                    }
                  else {
                    let e4 = "string";
                    "false" === i2 || "true" === i2 ? (e4 = "boolean", i2 = "false" !== i2) : isNaN(parseInt(i2) && -1 === i2.indexOf("/")) ? (i2.indexOf("-") >= 0 || i2.indexOf("/") >= 0 || i2.indexOf(":") >= 0) && "Invalid Date" !== new Date(i2).toString() && (e4 = "date", i2 = new Date(i2)) : (e4 = "number", i2 = parseFloat(i2)), r2.dataType || (r2.dataType = e4);
                  }
                  t2[r2.name] = i2;
                }
                (s || e3 > 0) && i.push(t2);
              }
              return i;
            }
            _bindToCSV() {
              const e2 = this, t = "" + e2.dataSource, a = -1 === t.indexOf(",") ? "	" : ",", n = t.split("\r"), r = new Array();
              let i = t.split("\n"), o = i.length;
              1 === o && n.length > 1 && (i = n, o = i.length);
              const d = e2.dataFields.length > 0;
              for (let t2 = 0; t2 < o; t2++) {
                const n2 = i[t2], o2 = {};
                let l = i[t2].split(a);
                if (t2 > 0) {
                  let e3 = [], a2 = 0, n3 = false, r2 = i[t2];
                  for (let t3 = 0; t3 < r2.length; t3++)
                    if ('"' === r2.charAt(t3))
                      n3 = !n3;
                    else if ("," === r2.charAt(t3) && !n3) {
                      let n4 = r2.substring(a2, t3);
                      n4 = n4.trim(), n4 = n4.replaceAll('"', ""), e3.push(n4), a2 = t3 + 1;
                    }
                  let o3 = r2.substring(a2);
                  o3 = o3.trim(), o3 = o3.replaceAll('"', ""), "," === o3 ? e3.push('""') : e3.push(o3), l = e3;
                }
                for (let a2 = 0; a2 < l.length; a2++) {
                  let r2 = e2.dataFields[a2], i2 = l[a2];
                  if (r2 || (e2.dataFields.push({ name: i2.trim() }), r2 = e2.dataFields[e2.dataFields.length - 1]), r2.map && (i2 = n2[r2.map]), i2 = i2.trim(), 1 !== t2 || d)
                    switch (r2.dataType) {
                      case "boolean":
                        i2 = "false" !== i2;
                        break;
                      case "number":
                        i2 = parseFloat(i2);
                        break;
                      case "date":
                        i2 = new Date(i2);
                    }
                  else {
                    let e3 = "string";
                    "false" === i2 || "true" === i2 ? (e3 = "boolean", i2 = "false" !== i2) : isNaN(parseInt(i2) && -1 === i2.indexOf("/") && -1 === i2.indexOf("-")) ? (i2.indexOf("-") >= 0 || i2.indexOf("/") >= 0 || i2.indexOf(":") >= 0) && "Invalid Date" !== new Date(i2).toString() && (e3 = "date", i2 = new Date(i2)) : i2.indexOf(".") >= 0 && i2.lastIndexOf(".") !== i2.indexOf(".") ? -1 === i2.indexOf(",") && (e3 = "date", i2 = new Date(i2)) : (e3 = "number", i2 = parseFloat(i2)), r2.dataType || (r2.dataType = e3);
                  }
                  o2[r2.map || r2.name || a2.toString()] = i2;
                }
                0 === t2 && e2.skipFirstRow || (d || t2 > 0) && r.push(o2);
              }
              e2.canNotify = false, e2.dataSource = r, e2.canNotify = true, e2._bindToArray();
            }
            _onBindingComplete() {
              const e2 = this;
              e2._buildHierarchy(), e2.onBindingComplete && e2.onBindingComplete({ data: e2.boundSource }), e2._notify && e2._notify({ action: "bindingComplete", data: e2.boundSource }), e2.bindingCompleted = true;
            }
            refreshHierarchy() {
              this.isUpdating || this._buildHierarchy();
            }
            find() {
              return this.boundSource.find.apply(this.boundSource, arguments);
            }
            onVirtualDataSourceRequested(e2, t) {
              const a = this;
              let n = t ? t.first : 1 / 0, r = t ? t.last : 1 / 0, i = t ? t.row : null;
              if (void 0 === n && (n = 1 / 0), void 0 === r && (r = 1 / 0), a.virtualFirstIndex = n, a.virtualLastIndex = r, a.virtualDataSource) {
                const o = function(r2) {
                  void 0 !== r2.virtualDataSourceLength && (a.virtualDataSourceLength = r2.virtualDataSourceLength), new Smart.DataAdapter({ dataSource: r2.dataSource, dataFields: r2.dataFields || a.dataFields, data: t, keyDataField: r2.keyDataField, parentDataField: r2.parentDataField, observable: false, id: r2.id || a.id, onBindingComplete(r3) {
                    if (void 0 === t.result && (t.result = true), t.data = r3.data, a.virtualDataSourceOnExpand && i)
                      return a.groupBy.length > 0 ? r3.data && r3.data.length > 0 && a.add(r3.data) : r3.data && r3.data.length > 0 ? a.add(r3.data, i.$.id) : i.leaf = true, a.onFilter && a.onFilter(), void e2(t);
                    n === 1 / 0 && "scroll" === t.action ? r3.data && r3.data.length && a.add(r3.data) : "filter" === t.action || "group" === t.action ? (a.canNotify = false, a.dataSource = r3.data, a.canNotify = true) : ("add" === t.action || "update" === t.action || t.action, a.canNotify = false, a.dataSource = r3.data, a.canNotify = true), a.onFilter && a.onFilter(), e2(t);
                  } });
                };
                let d = {};
                if (t.sorting && t.sorting.length > 0) {
                  let e3 = [];
                  for (let a3 in t.sorting)
                    e3.push(a3 + " " + t.sorting[a3].sortOrder.toUpperCase());
                  const a2 = " ORDER BY " + e3.join(", ");
                  d.orderBy = a2;
                } else
                  d.orderBy = "";
                if (void 0 === n || void 0 === r || 0 === n && 0 === r)
                  d.limit = "";
                else {
                  const e3 = r - n, t2 = " LIMIT " + e3 + " OFFSET " + n;
                  d.limit = t2, isNaN(e3) && (d.limit = "");
                }
                if (t.grouping && t.grouping.length > 0) {
                  const e3 = " GROUP BY " + t.grouping[0];
                  d.groupBy = e3;
                } else
                  d.groupBy = "";
                if (t.filtering && t.filtering.length > 0) {
                  const e3 = (e4, t2) => {
                    switch (t2.condition) {
                      case "EMPTY":
                        return e4 + " = ''";
                      case "NOT_EMPTY":
                        return e4 + " != ''";
                      case "EQUAL":
                        return e4 + " = '" + t2.value + "'";
                      case "NOT_EQUAL":
                        return e4 + " != '" + t2.value + "'";
                      case "CONTAINS_CASE_SENSITIVE":
                      case "CONTAINS":
                        return e4 + " LIKE '%" + t2.value + "%'";
                      case "DOES_NOT_CONTAIN_CASE_SENSITIVE":
                      case "DOES_NOT_CONTAIN":
                        return e4 + " NOT LIKE '%" + t2.value + "%'";
                      case "STARTS_WITH_CASE_SENSITIVE":
                      case "STARTS_WITH":
                        return e4 + " LIKE '" + t2.value + "%'";
                      case "ENDS_WITH_CASE_SENSITIVE":
                      case "ENDS_WITH":
                        return e4 + " LIKE '%" + t2.value + "'";
                      case "NULL":
                        return e4 + " IS NULL";
                      case "NOT_NULL":
                        return e4 + " IS NOT NULL";
                    }
                  }, a2 = (e4, t2) => {
                    let a3 = t2.value, n3 = t2.valueTo;
                    if (a3 && a3 instanceof Date) {
                      a3 = `'${new Smart.Utilities.DateTime(a3).toString("yyyy-MM-dd")}'`;
                    }
                    if (t2.valueTo && t2.valueTo instanceof Date) {
                      n3 = `'${new Smart.Utilities.DateTime(n3).toString("yyyy-MM-dd")}'`;
                    }
                    switch (t2.condition) {
                      case "EQUAL":
                        return e4 + " = " + a3;
                      case "NOT_EQUAL":
                        return e4 + " != " + a3;
                      case "GREATER_THAN":
                        return e4 + " > " + a3;
                      case "GREATER_THAN_OR_EQUAL":
                        return e4 + " >= " + a3;
                      case "LESS_THAN":
                        return e4 + " < " + a3;
                      case "LESS_THAN_OR_EQUAL":
                        return e4 + " <= " + a3;
                      case "NULL":
                        return e4 + " IS NULL";
                      case "NOT_NULL":
                        return e4 + " IS NOT NULL";
                      case "RANGE":
                        return "(" + e4 + " >= " + a3 + " and " + e4 + " <= " + n3 + ")";
                    }
                  }, n2 = (e4, t2, a3) => {
                    if (a3.operator) {
                      var n3 = e4(t2, a3.condition1), r3 = e4(t2, a3.condition2);
                      return "(" + n3 + " " + a3.operator + " " + r3 + ")";
                    }
                    return e4(t2, a3);
                  };
                  let r2 = [];
                  for (let i2 in t.filtering) {
                    const o2 = t.filtering[i2];
                    let d2 = o2.filters, l = [], s = " AND ";
                    for (let t2 = 0; t2 < d2.length; t2++) {
                      const r3 = d2[t2];
                      switch (r3.type) {
                        case "stringFilter":
                          l.push(n2(e3, i2, r3));
                          break;
                        case "numericFilter":
                        case "dateFilter":
                        case "booleanFilter":
                          l.push(n2(a2, i2, r3));
                      }
                      1 !== o2.logicalOperators[t2] && "or" !== o2.logicalOperators[t2] || (s = " OR ");
                    }
                    l.length && r2.push("(" + l.join(s) + ")");
                  }
                  if (r2.length > 0) {
                    let e4 = " AND ";
                    t.filterOperator && "or" === t.filterOperator.toLowerCase() && (e4 = " OR "), d.where = " WHERE " + r2.join(e4);
                  } else
                    d.where = "";
                } else
                  d.where = "";
                if ("dataBind" === t.action && a.virtualDataSourceOnExpand && a.keyDataField && a.parentDataField && (d.where ? d.where += " AND " + a.parentDataField + " IS NULL" : d.where = " WHERE " + a.parentDataField + " IS NULL"), "update" === t.action) {
                  const e3 = [];
                  for (let n2 in t.edit.row)
                    "$" !== n2 && n2 !== a.id && e3.push(n2 + "='" + t.edit.row[n2] + "'");
                  null === a.id ? d.update = " SET " + e3.join(", ") : d.update = " SET " + e3.join(", ") + " WHERE " + a.id + "=" + t.edit.row[a.id];
                }
                if ("remove" === t.action) {
                  const e3 = [];
                  for (let n2 in t.edit.row)
                    "$" !== n2 && n2 !== a.id && e3.push(n2 + " = '" + t.edit.row[n2] + "'");
                  d.remove = " WHERE " + a.id + "=" + t.edit.row[a.id];
                }
                if ("add" === t.action) {
                  const e3 = [], a2 = [];
                  for (let n2 in t.edit.row)
                    "$" !== n2 && (a2.push(n2), null !== t.edit.row[n2] ? e3.push("'" + t.edit.row[n2] + "'") : e3.push("null"));
                  d.add = " (" + a2.join(", ") + ")  VALUES (" + e3.join(", ") + ")";
                }
                "expand" === t.action ? (a.groupDataField ? d.where ? d.where += " AND " + a.groupDataField + " = '" + i[a.groupDataField] + "'" : d.where = " WHERE " + a.groupDataField + " = '" + i[a.groupDataField] + "'" : a.keyDataField && a.parentDataField ? d.where ? d.where += " AND " + a.parentDataField + " = " + i[a.keyDataField] : d.where = " WHERE " + a.parentDataField + " = " + i[a.keyDataField] : d.where ? d.where += " AND " + i.groupDataField + " = '" + i.label + "'" : d.where = " WHERE " + i.groupDataField + " = '" + i.label + "'", d.where.indexOf("undefined") >= 0 && (d.where = ""), d.limit = "", d.groupBy = "", a.virtualDataSourceOnExpand(o, { first: n, last: r, row: t.row, sorting: t.sorting, filtering: t.filtering, grouping: t.grouping, action: t.action, query: d })) : a.virtualDataSource(o, { first: n, last: r, sorting: t.sorting, edit: t.edit, filtering: t.filtering, filterOperator: t.filterOperator || "and", grouping: t.grouping, action: t.action, query: d });
              } else
                e2();
            }
            add(e2, t) {
              const a = this;
              if (!e2)
                return;
              let n = true;
              const r = function(e3) {
                const r2 = a._getDataItem(e3, a.boundSource.length);
                if (a.dataItemById[r2.$.id])
                  return void 0 !== t && (r2.$.parentId = t), null;
                a[a.boundSource.length] = r2, a.dataItemById[r2.$.id] = r2;
                const i = a.boundSource.push(r2);
                return void 0 !== t && (r2.$.parentId = t), i || (n = false), r2;
              };
              if (e2.length) {
                let t2 = [];
                for (let a2 = 0; a2 < e2.length; a2++) {
                  const n2 = r(e2[a2]);
                  n2 && t2.push(n2);
                }
                a._notify({ action: "add", data: t2 });
              } else {
                const t2 = r(e2);
                a._notify({ action: "add", data: t2 });
              }
              return a.refreshHierarchy(), n;
            }
            refreshIndexes() {
              const e2 = this;
              for (let t2 = 0; t2 < e2.boundSource.length; t2++)
                e2[t2] = e2.boundSource[t2], e2[t2].$.index = t2, e2.dataItemById[e2[t2].$.id] = e2[t2];
              let t = e2.boundSource.length;
              for (; e2[t]; )
                delete e2[t], t++;
            }
            removeLast() {
              const e2 = this;
              delete e2[e2.boundSource.length - 1];
              const t = e2.boundSource.pop();
              return delete e2.dataItemById[t.$.id], e2._notify({ action: "removeLast", data: t }), e2.refreshHierarchy(), t;
            }
            removeById(e2) {
              const t = this, a = t.indexOf(t.dataItemById[e2]);
              t.boundSource[a] && t.removeAt(a);
            }
            remove(e2) {
              const t = this;
              let a = t.indexOf(e2);
              -1 === a && e2 && e2.$ && (a = t.indexOf(t.dataItemById[e2.$.id]));
              t.boundSource[a] && t.removeAt(a);
            }
            removeAt(e2) {
              const t = this, a = t.boundSource[e2];
              if (!a)
                throw new Error("Invalid Item Index");
              t.boundSource.splice(e2, 1), delete t.dataItemById[a.$.id], t.refreshIndexes(), t._notify({ action: "remove", index: e2, data: a }), t.refreshHierarchy();
            }
            update(e2, t) {
              const a = this;
              if (Smart.Utilities.Types.isArray(e2) && Smart.Utilities.Types.isArray(t) && 0 === e2.length && 0 === t.length)
                return void a.refreshHierarchy();
              if (t.length && e2.length) {
                let n2 = [];
                for (let r2 = 0; r2 < e2.length; r2++) {
                  const i = a._getDataItem(t[r2], e2[r2]), o = e2[r2];
                  n2.push(i), a.boundSource[o] = i, a[o] = a.boundSource[o], a.dataItemById[i.$.id] = a[o];
                }
                return a._notify({ action: "update", index: e2, data: n2 }), void a.refreshHierarchy();
              }
              const n = a._getDataItem(t, e2), r = a.boundSource[e2].$.id;
              return n.$.id = r, a.boundSource[e2] = n, a[e2] = a.boundSource[e2], a.dataItemById[n.$.id] = a[e2], a._notify({ action: "update", index: e2, data: n }), a.refreshHierarchy(), n;
            }
            insert(e2, t) {
              const a = this;
              if (t.length) {
                const n2 = [];
                for (let r = 0; r < t.length; r++) {
                  const i = a._getDataItem(t[r], e2 + r);
                  n2.push(i);
                }
                t = n2;
              } else
                t = a._getDataItem(t, e2);
              const n = a.boundSource.splice(e2, 0, t);
              return a.refreshIndexes(), a._notify({ action: "insert", index: e2, data: t }), a.refreshHierarchy(), n;
            }
            move(e2, t) {
              if (t > e2 && t - e2 == 1 || e2 === t)
                return;
              const a = this, n = a.boundSource.splice(e2, 1)[0];
              t > e2 ? (t--, a.boundSource.splice(t, 0, n)) : a.boundSource.splice(t, 0, n), a.refreshIndexes(), a._notify({ action: "move", index: t, data: a.boundSource[t] }), a.refreshHierarchy();
            }
            indexOf(e2) {
              return this.boundSource.indexOf(e2);
            }
            get length() {
              const e2 = this;
              return void 0 !== e2.virtualDataSourceLength ? e2.virtualDataSourceLength : e2.dataSourceLength ? e2.dataSourceLength : "number" == typeof e2.dataSource ? e2.dataSource : e2.bindingCompleted ? e2.boundSource.length : e2.dataSource && "string" != typeof e2.dataSource && e2.dataSource.length ? e2.dataSource.length : e2.boundSource.length;
            }
            clear() {
              const e2 = this;
              if (!e2.isInitialized)
                return e2._cachedValues = [], void (e2.dataItemById = []);
              for (let t = 0; t < e2.boundSource.length; t++)
                delete e2[t];
              e2._expandedRowIds = [], e2._cachedValues = [], e2.boundSource = e2.observable ? new Smart.ObservableArray() : [], e2.dataItemById = [], e2.refreshHierarchy();
            }
            _getId(e2, t, a) {
              if (null === e2 || void 0 === e2.name || !e2.name || !t.getAttribute) {
                if (e2 && e2.toString().length > 0 && t.getAttribute) {
                  let a2 = t.getAttribute(e2);
                  if (null !== a2 && a2.toString().length > 0)
                    return a2.trim().split(" ").join("").replace(/([ #;?%&,.+*~\':'!^$[\]()=>|\/@])/g, "");
                  {
                    let a3 = e2.split(this.mapChar);
                    if (a3.length > 1) {
                      let e3 = t;
                      for (let t2 = 0; t2 < a3.length; t2++)
                        void 0 !== e3 && (e3 = e3[a3[t2]]);
                      if (void 0 !== e3)
                        return e3;
                    } else if (void 0 !== t[e2])
                      return t[e2];
                  }
                }
                return a;
              }
              {
                let n = t.getAttribute(e2.name);
                if (null !== n && n.toString().length > 0)
                  return n;
                if (e2.map)
                  try {
                    let a2 = t.getAttribute(e2.map);
                    if (null !== a2 && a2.toString().length > 0)
                      return a2;
                  } catch (e3) {
                    return a;
                  }
              }
            }
            _buildHierarchy() {
              const e2 = this;
              if (e2.reservedNames) {
                const t2 = e2.reservedNames;
                t2.leaf || (t2.leaf = "leaf"), t2.parent || (t2.parent = "parent"), t2.expanded || (t2.expanded = "expanded"), t2.checked || (t2.checked = "checked"), t2.selected || (t2.selected = "selected"), t2.level || (t2.level = "level"), t2.data || (t2.data = "data");
              } else
                e2.reservedNames = { leaf: "leaf", parent: "parent", expanded: "expanded", checked: "checked", selected: "selected", level: "level", icon: "icon", data: "data" };
              const t = e2.reservedNames;
              if (e2.childrenDataField) {
                const a = [];
                for (let n = 0; n < e2.boundSource.length; n++) {
                  const r = JSON.parse(JSON.stringify(e2.boundSource[n]));
                  if (!r)
                    continue;
                  a.push(r);
                  const i = function(a2) {
                    const n2 = e2.childrenDataField.split(e2.mapChar);
                    let r2 = null;
                    if (n2.length > 1) {
                      let e3 = a2;
                      for (let t2 = 0; t2 < n2.length; t2++)
                        void 0 !== e3 && (e3 = e3[n2[t2]]);
                      r2 = e3;
                    } else
                      r2 = a2.children;
                    a2.children = r2, (null === a2.children || void 0 === a2.children || a2.children && 0 === a2.children.length) && (a2[t.leaf] = true);
                  };
                  i(r), r[t.level] = 0, r.$ || (r.$ = {}), r[t.parent] = null, r[t.data] = r, void 0 === r[t.expanded] && (r[t.expanded] = false, e2.expandHierarchy && (r[t.expanded] = true));
                  const o = function(a2, n2) {
                    if (n2)
                      for (let r2 = 0; r2 < n2.length; r2++) {
                        let d = e2._getDataItem(n2[r2], r2);
                        if (d) {
                          if (i(d), !e2.id) {
                            const e3 = function() {
                              const e4 = function() {
                                return (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
                              };
                              return e4() + e4();
                            };
                            d.$.id = e3();
                          }
                          d[t.level] = a2[t.level] + 1, d[t.parent] = a2, d[t.data] = Object.assign({}, d), a2 && (a2.children[r2] = d), void 0 === d[t.expanded] && (d[t.expanded] = false, e2.expandHierarchy && (d[t.expanded] = true)), o(d, d.children);
                        }
                      }
                    else
                      a2.children = new Array();
                  };
                  o(r, r.children);
                }
                if (e2.boundHierarchy = a, !e2._boundSourceUpdate) {
                  for (let t2 = 0; t2 < e2.boundHierarchy.length; t2++) {
                    const a2 = e2.boundHierarchy[t2];
                    if (a2.children) {
                      const t3 = function(a3) {
                        if (e2.dataItemById[a3.$.id] || (e2.boundSource.canNotify = false, e2.dataItemById[a3.$.id] = a3, e2.boundSource.canNotify = true), a3.children)
                          for (let e3 = 0; e3 < a3.children.length; e3++) {
                            const n = a3.children[e3];
                            n.children && t3(n);
                          }
                      };
                      t3(a2);
                    }
                  }
                  e2._boundSourceUpdate = true;
                }
              }
              if (e2.xmlRoot && "xml" === e2.dataSourceType && (e2.boundHierarchy = this._getHierarchy("uid", "_parentuid", "children", null, e2.boundSource)), e2.keyDataField && e2.parentDataField)
                return ["keyDataField", "parentDataField"].forEach((t2) => {
                  switch (e2[t2]) {
                    case "parent":
                      e2[t2] = "$" + e2[t2];
                  }
                }), void (e2.boundHierarchy = this._getHierarchy(e2.keyDataField, e2.parentDataField, "children", null, e2.boundSource));
              e2.groupBy && e2.groupBy.length > 0 ? e2.boundHierarchy = this._getGroupHierarchy(e2.groupBy, "children", "label", null, "data", null, "parent", e2.boundSource) : e2.virtualDataSourceOnExpand && (e2.boundHierarchy = this._getHierarchy("id", "parentId", "children", null, e2.boundSource));
            }
            _getGroupHierarchy(e2, t, a, n, r, i, o, d, l) {
              let s = this;
              l || (l = 0);
              let c = s.reservedNames;
              const u = function() {
                function e3() {
                  return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
                }
                return e3() + e3() + "-" + e3() + "-" + e3() + "-" + e3() + "-" + e3() + e3() + e3();
              };
              let f = new Array();
              for (let t2 = 0; t2 < e2.length; t2++)
                f[t2] = u();
              t || (t = "children"), a || (a = "group"), r || (r = "item"), o || (o = "parent"), void 0 === i && (i = "value");
              const h = new Array(), p = new Array();
              let g = 0;
              const S = function(t2) {
                let a2 = t2;
                for (let n2 = 0; n2 < e2.length; n2++) {
                  if (void 0 === t2[e2[n2]]) {
                    a2 = s._getDataItem(t2, t2.$.index);
                    break;
                  }
                }
                if (n)
                  for (let e3 in n) {
                    const t3 = n[e3];
                    t3.name && t3.map && (a2[t3.map] = a2[t3.name]);
                  }
                return a2;
              };
              let y = false;
              for (let n2 = 0; n2 < d.length; n2++) {
                let m = Object.assign({}, S(d[n2]));
                m[c.leaf] = false;
                let T = new Array(), b = 0;
                for (let t2 = 0; t2 < e2.length; t2++) {
                  const a2 = e2[t2], n3 = m[a2];
                  null != n3 ? (("" === n3 || void 0 === n3 && 0 === t2) && (y = true), T[b++] = { value: n3, group: a2, hash: f[t2] }) : (T[b++] = { value: null, group: a2, hash: f[t2] }, 0 === t2 && (y = true));
                }
                if (T.length !== e2.length)
                  break;
                let x = null, v = "";
                for (let e3 = 0; e3 < T.length; e3++) {
                  const n3 = T[e3].value, d2 = T[e3].group;
                  if (v = v + "_" + T[e3].hash + "_" + n3, void 0 === p[v] || null === p[v]) {
                    if (null === x) {
                      x = { $: {} }, x[c.level] = 0, x[c.leaf] = false, x[o] = null, x[a] = n3, x[r] = m, x.groupDataField = d2, x[d2] || (x[d2] = x.data[d2]), void 0 !== m[c.expanded] ? x[c.expanded] = m[c.expanded] : (x[c.expanded] = false, s.expandHierarchy && (x[c.expanded] = true)), i && (x[i] = m[i]), x[t] = new Array();
                      let e4 = h.length + l;
                      this.id && "number" != typeof m.$.id && !isFinite(m.$.id) || (e4 = "Item" + e4), void 0 === x.$.id && (x.$.id = e4), s._expandedRowIds[x.$.id] && (x[c.expanded] = true), s.expandHierarchy && s._collapsedIds && s._collapsedIds[x.$.id] && (x[c.expanded] = false), h[g++] = x;
                    } else {
                      const e4 = { $: {} };
                      e4[c.level] = x[c.level] + 1, e4[o] = x, e4[a] = n3, e4[t] = new Array(), e4[r] = m, e4.groupDataField = d2, e4[c.leaf] = false, e4[d2] || (e4[d2] = e4.data[d2]), void 0 !== m[c.expanded] ? e4[c.expanded] = m[c.expanded] : (e4[c.expanded] = false, s.expandHierarchy && (e4[c.expanded] = true)), i && (e4[i] = m[i]), void 0 === e4.$.id && (e4.$.id = x.$.id + "_" + x[t].length), s.expandHierarchy && s._collapsedIds && s._collapsedIds[e4.$.id] && (e4[c.expanded] = false), s._expandedRowIds[e4.$.id] && (e4[c.expanded] = true), x[t][x[t].length] = e4, x = e4;
                    }
                    p[v] = x;
                  } else
                    x = p[v];
                }
                m && (m[c.leaf] = true), null !== x ? (null === this.id ? void 0 === m.$.id && (m.$.id = x.$.id + "_" + x[t].length) : void 0 === m.$.id && -1 === m.$.id.toString().indexOf(x.$.id) && (m.$.id = x.$.id + "_" + m.$.id), m[o] = x, m[c.level] = x[c.level] + 1, x[t][x[t].length] = m) : void 0 === m.$.id && (m.$.id = u());
              }
              if (y) {
                let e3 = null, t2 = false;
                for (let a2 = 0; a2 < h.length; a2++) {
                  const n2 = h[a2];
                  if (!n2[n2.groupDataField]) {
                    e3 = n2, e3.$.id.toString().startsWith("Item") && (t2 = true), h.splice(a2, 1);
                    break;
                  }
                }
                if (e3 && (h.push(e3), t2))
                  for (let e4 = 0; e4 < h.length; e4++) {
                    const t3 = h[e4];
                    t3.$.id = "Item" + e4, Object.keys(s._expandedRowIds).length > 0 && (s._expandedRowIds[t3.$.id] ? t3[c.expanded] = true : t3[c.expanded] = false, s.expandHierarchy && (t3[c.expanded] = true, s._collapsedIds && s._collapsedIds[t3.$.id] && (t3[c.expanded] = false)));
                  }
              }
              return h;
            }
            _getHierarchy(e2, t, a, n, r) {
              const i = this, o = new Array();
              let d = this.boundSource;
              if (r && (d = r), 0 === this.boundSource.length)
                return null;
              const l = null !== a ? a : "children";
              let s = new Array(), c = d, u = c.length, f = i.reservedNames;
              const h = function(e3) {
                let t2 = e3;
                if (n)
                  for (let e4 in n) {
                    const a2 = n[e4];
                    a2.name && a2.map && (t2[a2.map] = t2[a2.name]);
                  }
                return t2;
              };
              for (let a2 = 0; a2 < u; a2++) {
                let n2 = c[a2], r2 = n2[t], o2 = n2[e2];
                "parentId" === t && (r2 = n2.$.parentId), "id" === e2 && (o2 = n2.$.id), null === o2 && (o2 = n2[e2] = n2.$.id), n2[l] = new Array(), i.expandHierarchy && void 0 === n2[f.expanded] && (n2[f.expanded] = i.expandHierarchy), s[o2] = { parentId: r2, item: n2 };
              }
              for (let a2 = 0; a2 < u; a2++) {
                const n2 = c[a2];
                let r2 = n2[t], i2 = n2[e2];
                if ("parentId" === t && (r2 = n2.$.parentId), "id" === e2 && (i2 = n2.$.id), void 0 !== s[r2]) {
                  let e3 = { parentId: r2, item: s[i2].item }, t2 = s[r2].item;
                  t2[l] || (t2[l] = new Array());
                  let a3 = t2[l].length;
                  e3 = e3.item, f ? e3[f.parent] = t2 : e3.parent = t2;
                  const n3 = h(e3);
                  t2[l][a3] = n3, s[r2].item = t2, s[i2].item = e3;
                } else {
                  let e3 = s[i2].item;
                  f ? void 0 === e3[f.parent] && (e3[f.parent] = null) : void 0 === e3.parent && (e3.parent = null);
                  const t2 = h(e3);
                  f ? t2[f.level] = 0 : t2.level = 0, o[o.length] = t2;
                }
              }
              if (0 !== o.length) {
                let e3 = function(t2, a2) {
                  for (let n2 = 0; n2 < a2.length; n2++) {
                    const r2 = a2[n2];
                    f ? r2[f.level] = t2 : r2.level = t2;
                    const o2 = r2[l];
                    o2 && o2.length > 0 ? (r2.leaf = false, e3(t2 + 1, o2)) : i.virtualDataSourceOnExpand ? void 0 === r2.leaf && (r2.leaf = false) : f ? r2[f.leaf] = true : r2.leaf = true;
                  }
                };
                e3(0, o);
              }
              return o;
            }
            summarize(e2, t) {
              const a = this;
              Array.isArray(e2) || (e2 = [e2]);
              let n = [];
              for (let t2 = 0; t2 < e2.length; t2++) {
                const a2 = e2[t2];
                for (let e3 in a2) {
                  const t3 = a2[e3];
                  n.push({ dataField: e3, functions: t3 });
                }
              }
              e2 = n;
              let r = {}, i = new Array();
              t || (t = a.boundSource);
              let o = t.length, d = 0;
              if (0 !== o && void 0 !== o) {
                for (let a2 = 0; a2 < o; a2++) {
                  let n2 = t[a2];
                  if ((!n2 || !n2.$ || false !== n2.$.filtered) && n2) {
                    d++;
                    for (let t2 = 0; t2 < e2.length; t2++) {
                      const o2 = e2[t2];
                      let d2 = n2[o2.dataField];
                      if (void 0 !== d2 && "uncategorized" !== d2 || (d2 = ""), o2.functions && o2.functions.length > 0) {
                        r[o2.dataField] = r[o2.dataField] || {}, i[o2.dataField] = i[o2.dataField] || 0, i[o2.dataField]++;
                        const e3 = function(e4) {
                          for (let t4 in e4) {
                            let a3 = r[o2.dataField][t4];
                            null == a3 && (r[o2.dataField][t4] = 0, a3 = 0), "function" == typeof e4[t4] && (a3 = e4[t4](a3, d2, o2.dataField, n2)), r[o2.dataField][t4] = a3;
                          }
                        }, t3 = d2;
                        let l = parseFloat(d2);
                        l = !isNaN(l), t3 && t3.toDate && (l = false), "string" == typeof d2 && d2.startsWith("+") && (l = false), l && (d2 = parseFloat(d2)), "number" == typeof d2 && isFinite(d2) ? o2.functions.forEach(function(t4) {
                          let n3 = r[o2.dataField][t4];
                          if (null == n3 && (n3 = 0, "min" === t4 && (n3 = 9999999999999), "max" === t4 && (n3 = -9999999999999), "median" === t4 && (n3 = [])), "sum" === t4 || "avg" === t4 || "stdev" === t4 || "stdevp" === t4 || "var" === t4 || "varp" === t4)
                            n3 += parseFloat(d2);
                          else if ("product" === t4)
                            0 === a2 ? n3 = parseFloat(d2) : n3 *= parseFloat(d2);
                          else if ("min" === t4)
                            n3 = Math.min(n3, parseFloat(d2));
                          else if ("max" === t4)
                            n3 = Math.max(n3, parseFloat(d2));
                          else if ("count" === t4)
                            n3++;
                          else if ("median" === t4)
                            n3.push(parseFloat(d2));
                          else if ("blank" === t4)
                            n3 = r[o2.dataField][t4], null == n3 && (n3 = 0), d2 || n3++;
                          else if ("filled" === t4)
                            n3 = r[o2.dataField][t4], null == n3 && (n3 = 0), void 0 !== d2 && n3++;
                          else if ("unique" === t4)
                            n3 = r[o2.dataField][t4], null == n3 && (n3 = []), -1 === n3.indexOf(d2) && n3.push(d2);
                          else if ("status" === t4)
                            n3 = r[o2.dataField][t4], null == n3 && (n3 = []), n3[d2] || (n3[d2] = []), n3[d2].push(d2);
                          else if ("object" == typeof t4)
                            return void e3(t4);
                          r[o2.dataField][t4] = n3;
                        }) : o2.functions.forEach(function(t4) {
                          if ("min" === t4 || "max" === t4 || "count" === t4 || "product" === t4 || "sum" === t4 || "avg" === t4 || "stdev" === t4 || "stdevp" === t4 || "var" === t4 || "varp" === t4) {
                            if (null === d2 && "count" !== t4)
                              return true;
                            let e4 = r[o2.dataField][t4];
                            return null == e4 && (e4 = 0), r[o2.dataField][t4] = e4, true;
                          }
                          if ("blank" === t4) {
                            let e4 = r[o2.dataField][t4];
                            null == e4 && (e4 = 0), d2 || e4++, r[o2.dataField][t4] = e4;
                          } else if ("filled" === t4) {
                            let e4 = r[o2.dataField][t4];
                            null == e4 && (e4 = 0), d2 && e4++, r[o2.dataField][t4] = e4;
                          } else if ("unique" === t4) {
                            let e4 = r[o2.dataField][t4];
                            null == e4 && (e4 = []), -1 === e4.indexOf(d2) && e4.push(d2), r[o2.dataField][t4] = e4;
                          } else if ("status" === t4) {
                            let e4 = r[o2.dataField][t4];
                            null == e4 && (e4 = []), e4[d2] || (e4[d2] = []), e4[d2].push(d2), r[o2.dataField][t4] = e4;
                          }
                          "object" == typeof t4 && e3(t4);
                        });
                      }
                    }
                  }
                }
                for (let a2 = 0; a2 < e2.length; a2++) {
                  const n2 = e2[a2];
                  if (n2.functions && (!n2.functions || 0 !== n2.functions.length)) {
                    if (r[n2.dataField] || (r[n2.dataField] = {}, n2.functions.forEach(function(e3) {
                      r[n2.dataField][e3] = 0;
                    })), void 0 !== r[n2.dataField].avg) {
                      const e3 = r[n2.dataField].avg, t2 = i[n2.dataField];
                      r[n2.dataField].avg = 0 === t2 || void 0 === t2 ? 0 : e3 / t2;
                    } else
                      void 0 !== r[n2.dataField].count && (r[n2.dataField].count = d);
                    if (void 0 !== r[n2.dataField].unique) {
                      const e3 = r[n2.dataField].unique;
                      r[n2.dataField].unique = e3.length;
                    }
                    if (void 0 !== r[n2.dataField].status) {
                      const e3 = r[n2.dataField].status;
                      r[n2.dataField].status = e3;
                    }
                    if (void 0 !== r[n2.dataField].median) {
                      let e3 = r[n2.dataField].median;
                      e3.sort(function(e4, t2) {
                        return e4 - t2;
                      }), r[n2.dataField].median = 0.5 * (e3[Math.floor((e3.length + 1) / 2) - 1] + e3[Math.ceil((e3.length + 1) / 2) - 1]);
                    }
                    (r[n2.dataField].stdev || r[n2.dataField].stdevp || r[n2.dataField].var || r[n2.dataField].varp) && n2.functions.forEach(function(e3) {
                      if ("stdev" === e3 || "var" === e3 || "varp" === e3 || "stdevp" === e3) {
                        const a3 = r[n2.dataField][e3], i2 = o, d2 = a3 / o;
                        let l = 0;
                        for (let e4 = 0; e4 < o; e4++) {
                          let a4 = t[e4][n2.dataField];
                          l += (a4 - d2) * (a4 - d2);
                        }
                        let s = "stdevp" === e3 || "varp" === e3 ? i2 : i2 - 1;
                        0 === s && (s = 1), "var" === e3 || "varp" === e3 ? r[n2.dataField][e3] = l / s : "stdevp" !== e3 && "stdev" !== e3 || (r[n2.dataField][e3] = Math.sqrt(l / s));
                      }
                    });
                  }
                }
                return r;
              }
            }
            _getDataItem(e2, t) {
              const a = this, n = {}, r = "number" == typeof a.dataSource || a.dataSourceLength;
              if (!e2)
                return { $: { id: t, isEmpty: true, index: t } };
              if ("string" == typeof e2 && (e2 = { "": e2 }), r) {
                for (let e3 = 0; e3 < a.dataFields.length; e3++) {
                  n[(a.dataFields ? a.dataFields[e3] : {}).name] = "";
                }
                return n.$ = {}, n.$.id = t, n.$.index = t, n;
              }
              const i = e2;
              if (void 0 !== i.expanded && (n.expanded = i.expanded, "true" === i.expanded || true === i.expanded || 1 === i.expanded ? n.expanded = true : n.expanded = false), a.childrenDataField ? void 0 !== i[a.childrenDataField] && (n.children = i[a.childrenDataField]) : void 0 !== i.children ? n.children = i.children : void 0 !== i.items && (n.children = i.items), void 0 !== i.leaf && (n.leaf = i.leaf), void 0 !== i.level && (n.level = i.level), a.keyDataField && void 0 !== i[a.keyDataField] && (n[a.keyDataField] = i[a.keyDataField]), a.parentDataField && void 0 !== i[a.parentDataField] && (n[a.parentDataField] = i[a.parentDataField]), 0 === a.dataFields.length) {
                const t2 = Object.getOwnPropertyNames(e2);
                for (let e3 = 0; e3 < t2.length; e3++)
                  "$" !== t2[e3] && a.dataFields.push({ name: t2[e3], dataType: "string" });
              }
              for (let t2 = 0; t2 < a.dataFields.length; t2++) {
                const r2 = a.dataFields ? a.dataFields[t2] : {};
                let o2 = "";
                if (null == r2)
                  continue;
                if (e2.length && (o2 = e2[t2]), r2.map) {
                  let e3 = r2.map.split(a.mapChar);
                  if (e3.length > 0) {
                    let t3 = i;
                    for (let a2 = 0; a2 < e3.length; a2++)
                      i && t3 && (t3 = t3[e3[a2]]);
                    o2 = t3;
                  } else
                    o2 = i[r2.map];
                }
                null != o2 ? o2 = o2.toString() : void 0 === o2 && null !== o2 && (o2 = "");
                let d = false;
                if ("" === o2 && (d = true, o2 = e2[r2.name], void 0 === r2.dataType && (r2.dataType = "any"), null != o2 ? "array" !== r2.dataType && ("any" === r2.dataType ? o2 = Array.isArray(e2[r2.name]) ? [...e2[r2.name]] : "object" == typeof e2[r2.name] ? Object.assign({}, e2[r2.name]) : e2[r2.name] : "date" !== r2.dataType && (o2 = o2.toString())) : o2 = void 0 === o2 && "any" === r2.dataType ? null : ""), "[object Object]" === o2 && r2.map && d && (o2 = ""), a._cachedValues[o2 + "_" + r2.dataType])
                  o2 = a._cachedValues[o2 + "_" + r2.dataType];
                else {
                  if ("bool" === r2.dataType || "boolean" === r2.dataType)
                    "true" === o2 || "1" === o2 ? o2 = true : "false" !== o2 && "0" !== o2 || (o2 = false);
                  else if ("number" === r2.dataType)
                    -1 === o2.indexOf(".") && o2.indexOf(",") >= 0 && o2.substring(1 + o2.indexOf(",")).length < 3 && (o2 = o2.replace(",", ".")), o2 = a.$document.deserialize("" + o2, r2.dataType, true);
                  else if ("date" === r2.dataType) {
                    if (o2 && "string" == typeof o2 && o2.indexOf("[") >= 0) {
                      const e3 = JSON.parse(o2);
                      if (r2.formatString && Smart.Utilities.DateTime) {
                        const t3 = Smart.Utilities.DateTime.ParseDate(e3[0], r2.formatString), a2 = Smart.Utilities.DateTime.ParseDate(e3[1], r2.formatString);
                        e3[0] = t3, e3[1] = a2;
                      } else {
                        const t3 = a.$document.deserialize("" + e3[0], r2.dataType, true), n2 = a.$document.deserialize("" + e3[1], r2.dataType, true);
                        e3[0] = t3, e3[1] = n2;
                      }
                      o2 = e3, n[r2.name] = o2;
                      continue;
                    }
                    if (r2.formatString && Smart.Utilities.DateTime) {
                      o2 = Smart.Utilities.DateTime.ParseDate(o2, r2.formatString);
                    } else
                      o2 = a.$document.deserialize("" + o2, r2.dataType, true);
                  } else
                    "any" !== r2.dataType && (o2 = "string" === r2.dataType && "null" === o2 ? "null" : a.$document.deserialize("" + o2, r2.dataType, true));
                  "any" !== r2.dataType && (a._cachedValues[o2 + "_" + r2.dataType] = o2);
                }
                "string" !== r2.dataType && "boolean" !== r2.dataType && "bool" !== r2.dataType && "any" !== r2.dataType && (isNaN(o2) || o2 === -1 / 0 || o2 === 1 / 0) && (o2 = "date" === r2.dataType || "number" === r2.dataType ? null : 0), "parent" !== r2.name && "group" !== r2.name && "leaf" !== r2.name && "level" !== r2.name ? ("string" === r2.dataType && /<.+?>/.test(o2) && o2.replace && ("all" === a.sanitizeHTML ? o2 = o2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#39;").replace(/"/g, "&quot;") : "blackList" === a.sanitizeHTML && (o2 = window.Smart.Utilities.Core.sanitizeHTML(o2), o2.indexOf("<br") >= 0 && (o2 = o2.replaceAll("<br/>", "\n\r"), o2 = o2.replaceAll("<br>", "\n\r")))), n[r2.name] = o2) : n.$[r2.name] = o2;
              }
              let o = t;
              if (a.id) {
                if (o = i[a.id], void 0 === o) {
                  const e3 = function() {
                    return (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
                  };
                  o = e3() + e3();
                }
                "object" == typeof o && (o = t), i.$ && void 0 !== i.$.id && (o = i.$.id);
              } else if (!a.virtualDataSource && a.dataItemById && a.dataItemById[o])
                for (o = a.length; a.dataItemById[o]; )
                  o++;
              return n.$ || (n.$ = {}), n.$.id = o, n.$.index = t, new Object(n);
            }
            _bindToArray() {
              const e2 = this, t = "number" == typeof e2.dataSource || e2.dataSourceLength, a = [];
              e2.boundSource.canNotify = false;
              const n = t ? "number" == typeof e2.dataSource ? e2.dataSource : e2.dataSource.length : e2.observable ? e2.length : e2.dataSource.length;
              for (let r = 0; r < n; r++) {
                const n2 = t ? {} : e2.dataSource[r], i = e2._getDataItem(n2, r);
                a.push(i);
              }
              if (t && e2.dataSourceLength && e2.dataSource.length > 0)
                for (let t2 = 0; t2 < e2.dataSource.length; t2++) {
                  const n2 = e2.dataSource[t2].cell, r = e2.dataSource[t2].value, i = n2.replace(/[^0-9]/g, ""), o = n2.replace(/[0-9]/g, "");
                  a[i - 1][o] = r;
                }
              e2.boundSource = false === e2.observable || e2.virtualDataSource ? [] : new Smart.ObservableArray(a), e2.observable && (e2.boundSource = new Smart.ObservableArray(a));
              for (let t2 = 0; t2 < n; t2++)
                e2.observable ? e2[t2] = e2.boundSource[t2] : e2[t2] = a[t2], e2.dataItemById[e2[t2].$.id] = e2[t2];
              false === e2.observable && (e2.boundSource = a), e2.boundSource.canNotify = true;
            }
            _bindToICS() {
              const e2 = this, t = "" + e2.dataSource, a = e2.rowDelimiter || "\n", n = t.split("\r"), r = [];
              let i = t.split(a), o = i.length;
              1 === o && n.length > 1 && (i = n, o = i.length);
              const d = function(e3, t2) {
                var a2 = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z)?$/.exec(e3);
                if (!a2)
                  throw new Error("Invalid UNTIL value: " + e3);
                return t2 ? new Date(a2[1], a2[2] - 1, a2[3], 0, 0, 0, 0) : new Date(Date.UTC(a2[1], a2[2] - 1, a2[3], a2[5] || 0, a2[6] || 0, a2[7] || 0));
              };
              for (let e3 = 0; e3 < o; e3++) {
                const t2 = i[e3].trim();
                if (t2.indexOf("BEGIN:VEVENT") >= 0)
                  var l = {};
                else if (l)
                  if (t2.indexOf("BEGIN:VALARM") >= 0)
                    var s = {};
                  else {
                    if (s) {
                      if (t2.indexOf("ACTION") >= 0) {
                        s.ACTION = t2.substring(t2.indexOf("ACTION") + 7);
                        continue;
                      }
                      if (t2.indexOf("DESCRIPTION") >= 0) {
                        s.DESCRIPTION = t2.substring(t2.indexOf("DESCRIPTION") + 12);
                        continue;
                      }
                      if (t2.indexOf("TRIGGER") >= 0) {
                        s.TRIGGER = t2.substring(t2.indexOf("TRIGGER") + 8);
                        continue;
                      }
                      if (t2.indexOf("END:VALARM") >= 0) {
                        l.ALARM || (l.ALARM = []), l.ALARM.push(s), s = void 0;
                        continue;
                      }
                    }
                    if (t2.indexOf("SUMMARY") >= 0)
                      l.SUMMARY = t2.substring(t2.indexOf("SUMMARY") + 8);
                    else if (t2.indexOf("LOCATION") >= 0)
                      l.LOCATION = t2.substring(t2.indexOf("LOCATION") + 9);
                    else if (t2.indexOf("DESCRIPTION") >= 0)
                      l.DESCRIPTION = t2.substring(t2.indexOf("DESCRIPTION") + 12);
                    else if (t2.indexOf("RRULE") >= 0)
                      l.RRULE = t2.substring(t2.indexOf("RRULE") + 6);
                    else if (t2.indexOf("RECURRENCE-ID") >= 0)
                      l.RECURRENCEID = t2.substring(t2.indexOf("RECURRENCE-ID") + 14);
                    else if (t2.indexOf("RECURRENCE-ID;VALUE=DATE") >= 0)
                      l.RECURRENCEID = t2.substring(t2.indexOf("RECURRENCE-ID;VALUE=DATE") + 25);
                    else if (t2.indexOf("EXDATE;VALUE=DATE") >= 0) {
                      const e4 = t2.substring(t2.indexOf("EXDATE;VALUE=DATE") + 20);
                      l.EXDATE = e4;
                    } else if (t2.indexOf("EXDATE") >= 0) {
                      const e4 = t2.substring(t2.indexOf("EXDATE") + 7);
                      l.EXDATE = e4;
                    } else
                      t2.indexOf("DTEND;VALUE=DATE") >= 0 ? l.DTEND = d(t2.substring(t2.indexOf("DTEND;VALUE=DATE") + 17), true) : t2.indexOf("DTEND") >= 0 ? l.DTEND = d(t2.substring(t2.indexOf("DTEND") + 6)) : t2.indexOf("DTSTART;VALUE=DATE") >= 0 ? l.DTSTART = d(t2.substring(t2.indexOf("DTSTART;VALUE=DATE") + 19), true) : t2.indexOf("DTSTART") >= 0 ? l.DTSTART = d(t2.substring(t2.indexOf("DTSTART") + 8)) : t2.indexOf("UID") >= 0 ? l.uid = l.UID = t2.substring(t2.indexOf("UID") + 4) : t2.indexOf("STATUS") >= 0 ? l.STATUS = t2.substring(t2.indexOf("STATUS") + 7) : t2.indexOf("TITLE") >= 0 ? l.TITLE = t2.substring(t2.indexOf("TITLE") + 6) : t2.indexOf("CATEGORIES") >= 0 ? l.CATEGORIES = t2.substring(t2.indexOf("CATEGORIES") + 11) : t2.indexOf("END:VEVENT") >= 0 && (r.push(l), l.ALARM && (l.ALARM = JSON.stringify(l.ALARM)), s = void 0);
                  }
              }
              e2.canNotify = false, e2.dataSource = r, e2.canNotify = true, e2._bindToArray();
            }
            _bindToJSON() {
              const e2 = this, t = [], a = e2.dataSource.length ? e2.dataSource : Object.entries(e2.dataSource);
              e2.boundSource.canNotify = false;
              for (let n = 0; n < a.length; n++) {
                const r = a[n], i = e2._getDataItem(r, n);
                t.push(i);
              }
              e2.boundSource = false === e2.observable || e2.virtualDataSource ? [] : new Smart.ObservableArray(t);
              for (let t2 = 0; t2 < e2.length; t2++)
                e2[t2] = e2.boundSource[t2], e2.dataItemById[e2[t2].$.id] = e2[t2];
              false === e2.observable && (e2.boundSource = t), e2.boundSource.canNotify = true;
            }
            sortBy(e2, t, a) {
              const n = this;
              if (!t)
                for (let a2 = 0; a2 < n.dataFields.length; a2++) {
                  const r = n.dataFields[a2];
                  if (r.name === e2) {
                    t = r.dataType;
                    break;
                  }
                }
              if (n.boundHierarchy) {
                if ((!e2 || 0 === e2.length) && n.groupBy.length > 0)
                  return void n.refreshHierarchy();
                const r = ((e3) => {
                  let t2 = [];
                  for (; e3; ) {
                    t2 = t2.concat(e3);
                    for (let a2 = 0; a2 < e3.length; a2++)
                      e3[a2].children && (t2 = t2.concat(e3[a2].children));
                    e3 = e3.children;
                  }
                  return t2;
                })(n.boundHierarchy);
                if (r) {
                  r.find((e3) => {
                    if (e3.summaryRow)
                      return e3;
                  }) && n.refreshHierarchy();
                }
                const i = function(r2) {
                  n._sort(r2, e2, a, t);
                  for (let n2 = 0; n2 < r2.length; n2++) {
                    const o = r2[n2];
                    o.children && i(o.children, e2, a, t);
                  }
                };
                i(n.boundHierarchy);
              } else
                n._sort(n.boundSource, e2, a, t);
            }
            _createFilter(e2, t) {
              const a = { "=": "EQUAL", "<>": "NOT_EQUAL", "!=": "NOT_EQUAL", not_like: "DOES_NOT_CONTAIN", like: "CONTAINS", "<": "LESS_THAN", ">": "GREATER_THAN", "<=": "LESS_THAN_OR_EQUAL", ">=": "GREATER_THAN_OR_EQUAL", equal: "EQUAL", "not equal": "NOT_EQUAL", "less than": "LESS_THAN", "greater than": "GREATER_THAN", "greater than or equal": "GREATER_THAN_OR_EQUAL", "less than or equal": "LESS_THAN_OR_EQUAL", "starts with": "STARTS_WITH", "ends with": "ENDS_WITH", notEqual: "NOT_EQUAL", not_equal: "NOT_EQUAL", lessThan: "LESS_THAN", greaterThan: "GREATER_THAN", greaterThanOrEqual: "GREATER_THAN_OR_EQUAL", lessThanOrEqual: "LESS_THAN_OR_EQUAL", less_than: "LESS_THAN", greater_than: "GREATER_THAN", greater_than_or_equal: "GREATER_THAN_OR_EQUAL", less_than_or_equal: "LESS_THAN_OR_EQUAL", null: "null", "": "EMPTY", isblank: "EMPTY", isnotblank: "NOT_EMPTY", isBlank: "EMPTY", isNotBlank: "NOT_EMPTY", CONTAINS: "CONTAINS", DOES_NOT_CONTAIN: "DOES_NOT_CONTAIN", contains: "CONTAINS", does_not_contain: "DOES_NOT_CONTAIN", "not contains": "DOES_NOT_CONTAIN", notcontains: "DOES_NOT_CONTAIN", notContains: "DOES_NOT_CONTAIN", startswith: "STARTS_WITH", endswith: "ENDS_WITH", starts_with: "STARTS_WITH", ends_with: "ENDS_WITH", startsWith: "STARTS_WITH", endsWith: "ENDS_WITH", NULL: "NULL", NOT_NULL: "NOT_NULL" };
              let n = [];
              "string" == typeof t && (t = [t]);
              for (let e3 = 0; e3 < t.length; e3++) {
                const a2 = t[e3], r2 = -1 === a2.indexOf('"') ? a2.split(" ") : a2.split('"');
                let i2 = [];
                for (let e4 = 0; e4 < r2.length; e4++) {
                  const t2 = r2[e4];
                  if ("" !== t2 && " " !== t2) {
                    if ("true" === t2.trim()) {
                      i2.push(true);
                      continue;
                    }
                    if ("false" === t2.trim()) {
                      i2.push(false);
                      continue;
                    }
                    if (t2.indexOf("or ") >= 0 || t2.indexOf("and ") >= 0 || t2.indexOf("1 ") >= 0 || t2.indexOf("0 ") >= 0 || t2.indexOf("| ") >= 0 || t2.indexOf("& ") >= 0) {
                      const e5 = t2.trim().split(" ");
                      if (e5.length > 1) {
                        const t3 = e5[0].trim(), a3 = e5[1].trim();
                        "1" === t3 ? i2.push("or") : "0" === t3 ? i2.push("and") : i2.push(t3), i2.push(a3);
                      } else
                        i2.push(t2.trim());
                    } else
                      i2.push(t2.trim());
                  }
                }
                n.push(i2);
              }
              const r = new Smart.FilterGroup(), i = [], o = [];
              for (let t2 = 0; t2 < n.length; t2++) {
                const r2 = n[t2];
                if (r2.length > 1) {
                  const t3 = new Smart.FilterGroup();
                  let n2 = r2.length > 2 ? "" : "and", i2 = 0, d2 = [];
                  for (let o2 = 0; o2 < r2.length; o2++) {
                    let l = r2[o2];
                    if ("and" !== l && "or" !== l) {
                      if (i2++, 2 === i2) {
                        let s = a[r2[o2 - 1]];
                        s || (s = r2[o2 - 1]), "number" === e2 && (l = parseFloat(l)), "date" === e2 && (l = new Date(l));
                        const c = t3.createFilter(e2, l, s);
                        if (i2 = 0, d2.push(c), n2) {
                          for (let e3 = 0; e3 < d2.length; e3++)
                            t3.addFilter(n2, d2[e3]);
                          d2 = [];
                        }
                      }
                    } else
                      n2 = l;
                  }
                  o.push(t3);
                } else {
                  let e3 = r2[0];
                  if (e3 && a[e3] && (e3 = "and"), "and" !== e3 && "or" !== e3)
                    throw new Error('Filter Exprresion expects "AND" or "OR", but the token is: ' + e3);
                  i.push(e3);
                }
              }
              let d = 0;
              if (1 === o.length)
                return o[0];
              for (let e3 = 0; e3 < o.length; e3++) {
                let t2 = i[d];
                (e3 + 1) % 2 == 0 && d++, t2 || (t2 = "and"), r.addFilter(t2, o[e3]);
              }
              return r;
            }
            filterBy(e2, ...t) {
              const a = this, n = (() => {
                for (let t2 = 0; t2 < a.dataFields.length; t2++) {
                  const n2 = a.dataFields[t2];
                  if (n2.name === e2)
                    return n2.dataType;
                }
              })(), r = a._createFilter(n, t);
              return a.boundSource.filter((t2) => r.evaluate(t2[e2]));
            }
            _filter(e2, t = "and") {
              const a = this, n = [], r = [];
              if (0 === e2.length)
                return void a.clearFilter();
              const i = (e3) => {
                for (let t2 = 0; t2 < a.dataFields.length; t2++) {
                  const n2 = a.dataFields[t2];
                  if (n2.name === e3)
                    return n2.dataType;
                }
              };
              let o, d;
              "and" === t ? (o = true, d = function(e3, t2, a2) {
                return e3 && t2.evaluate(a2[t2.dataField]);
              }) : (o = false, d = function(e3, t2, a2) {
                return e3 || t2.evaluate(a2[t2.dataField]);
              });
              for (let t2 = 0; t2 < e2.length; t2++) {
                const o2 = e2[t2], d2 = o2[0];
                let l = null;
                l = o2[1] instanceof Smart.FilterGroup ? o2[1] : a._createFilter(i(d2), o2.splice(1)), l && (r.push(d2), l.dataField = d2, n.push(l));
              }
              if (a.boundHierarchy) {
                const e3 = function(e4) {
                  let t3 = o;
                  for (let a2 = 0; a2 < n.length; a2++) {
                    const r2 = n[a2];
                    t3 = d(t3, r2, e4);
                  }
                  return e4.$.filtered = t3, t3;
                }, t2 = function(n2, r2, i2) {
                  let o2 = 0;
                  for (let a2 = 0; a2 < n2.length; a2++) {
                    const i3 = n2[a2];
                    e3(i3), i3.$.filtered && o2++, i3.children && t2(i3.children, i3, r2);
                  }
                  o2 > 0 && a.groupBy.length > 0 && r2 ? (r2.$.filtered = true, i2 && !i2.$.filtered && (i2.$.filtered = true)) : o2 > 0 && o2 !== n2.length && r2 ? (r2.$.filtered = null, i2 && !i2.$.filtered && (i2.$.filtered = null)) : o2 > 0 && o2 === n2.length && r2 && (r2.$.filtered = true, i2 && !i2.$.filtered && (i2.$.filtered = true));
                };
                t2(a.boundHierarchy, null, null);
              } else
                for (let e3 = 0; e3 < a.boundSource.length; e3++) {
                  const t2 = a.boundSource[e3];
                  let r2 = o;
                  for (let e4 = 0; e4 < n.length; e4++) {
                    const a2 = n[e4];
                    r2 = d(r2, a2, t2);
                  }
                  t2.$.filtered = r2;
                }
              a.onFilter && a.onFilter();
            }
            clearGroup() {
              const e2 = this;
              e2.groupBy = [], e2.boundHierarchy = null, e2.refreshHierarchy(), e2.onGroup && e2.onGroup();
            }
            clearFilter() {
              const e2 = this;
              for (let t = 0; t < e2.boundSource.length; t++) {
                e2.boundSource[t].$.filtered = true;
              }
              if (e2.boundHierarchy) {
                const t = function(e3, a, n) {
                  for (let n2 = 0; n2 < e3.length; n2++) {
                    const r = e3[n2];
                    r.$.filtered = true, r.$.filtered, r.children && t(r.children, r, a);
                  }
                  a && (a.$.filtered = true, n && !n.$.filtered && (n.$.filtered = true));
                };
                t(e2.boundHierarchy, null, null);
              }
              e2.onFilter && e2.onFilter();
            }
            clearSort() {
              this._sort(this.boundSource, [], [], []);
            }
            _sort(e2, t, a, n, r, i) {
              const o = this;
              let d = false;
              if (0 === e2.length)
                return;
              if (e2 && e2.constructor && e2 instanceof Smart.ObservableArray && (d = true), (!e2 || !Array.isArray(e2) || 0 === e2.length || !t || Array.isArray(t) && 0 === t.length) && !d && !o.boundHierarchy) {
                if (o.virtualDataSource)
                  return;
                throw new Error("sort: Missing or Invalid arguments!");
              }
              "string" == typeof t && (t = [t]);
              const l = [], s = [];
              void 0 === a && (a = []);
              const c = function(e3, t2) {
                let a2;
                switch (t2 || typeof e3) {
                  case "string":
                    a2 = new Intl.Collator().compare;
                    break;
                  case "number":
                  case "int":
                  case "bigInt":
                  case "float":
                  case "double":
                    a2 = function(e4, t3) {
                      return e4 - t3;
                    };
                    break;
                  case "boolean":
                  case "bool":
                    a2 = function(e4, t3) {
                      return e4 === t3 ? 0 : false === e4 ? -1 : 1;
                    };
                    break;
                  case "date":
                  case "time":
                  case "dateTime":
                    a2 = e3 instanceof Date ? function(e4, t3) {
                      return e4 || t3 ? e4 ? t3 ? e4.getTime() - t3.getTime() : 1 : -1 : 0;
                    } : e3 instanceof Smart.Utilities.DateTime || e3 instanceof Smart.Utilities.BigNumber ? function(e4, t3) {
                      return e4.compare(t3);
                    } : function(e4, t3) {
                      return e4 - t3;
                    };
                    break;
                  case "object":
                    if (e3 instanceof Date)
                      a2 = function(e4, t3) {
                        return e4 || t3 ? e4 ? t3 ? e4.getTime() - t3.getTime() : 1 : -1 : 0;
                      };
                    else if (e3 instanceof Smart.Utilities.DateTime || e3 instanceof Smart.Utilities.BigNumber)
                      a2 = function(e4, t3) {
                        return e4.compare(t3);
                      };
                    else if (e3 instanceof Smart.Utilities.Complex || window.NIComplex && e3 instanceof window.NIComplex) {
                      const e4 = new Smart.Utilities.ComplexNumericProcessor();
                      a2 = function(t3, a3) {
                        return e4.compareComplexNumbers(t3, a3);
                      };
                    }
                }
                return a2;
              };
              for (let r2 = 0; r2 < t.length; r2++) {
                void 0 === a[r2] || "asc" === a[r2] || "ascending" === a[r2] ? l[r2] = 1 : l[r2] = -1;
                let d2 = e2[0][t[r2]];
                if (void 0 === d2 && e2[0] && e2[0].children && e2[0].data && (d2 = e2[0].data[t[r2]]), i && i) {
                  const e3 = t[r2];
                  if (i[e3]) {
                    s[r2] = i[e3];
                    continue;
                  }
                }
                o.sortComparators && o.sortComparators[t[r2]] ? s[r2] = o.sortComparators[t[r2]] : s[r2] = c(d2, n[r2]);
              }
              t.length > 0 && r ? r(e2, t, a, s) : e2.sort(function(e3, a2) {
                for (let n2 = 0; n2 < t.length; n2++) {
                  const r2 = s[n2](e3[t[n2]], a2[t[n2]]);
                  if (0 === r2) {
                    if (t[n2 + 1])
                      continue;
                    return void 0 !== e3.$.index ? (e3.$.index - a2.$.index) * l[n2] : 0;
                  }
                  return r2 * l[n2];
                }
                if (0 === t.length)
                  return e3.$.index < a2.$.index ? -1 : e3.$.index > a2.$.index ? 1 : 0;
              });
              for (let t2 = 0; t2 < e2.length; t2++)
                o[t2] = e2[t2];
            }
            static Filter(e2, t, a, n, r = "and") {
              let i, o;
              "and" === r ? (i = true, o = function(e3, t2, a2, r2) {
                return n ? e3 && n(t2, a2, r2) : e3 && r2.evaluate(t2[a2]);
              }) : (i = false, o = function(e3, t2, a2, r2) {
                return n ? e3 || n(t2, a2, r2) : e3 || r2.evaluate(t2[a2]);
              });
              return e2.filter((e3) => {
                let n2 = i;
                for (let r2 = 0; r2 < a.length; r2++) {
                  const i2 = a[r2], d = t[r2];
                  n2 = o(n2, e3, d, i2);
                }
                return n2;
              });
            }
            filter(e2, t, a) {
              Smart.DataAdapter.Filter(this.boundSource, e2, t, a);
            }
            sort(e2, t, a) {
              Smart.DataAdapter.Sort(this.boundSource, e2, t, a);
            }
            static Sort(e2, t, a, n) {
              const r = function(e3) {
                let t2;
                switch (typeof e3) {
                  case "string":
                    if (e3.indexOf("-") >= 0 || e3.indexOf("/") >= 0) {
                      const t3 = new Date(e3);
                      if (t3 && "Invalid Date" !== t3.toString()) {
                        return function(e4, t4) {
                          const a2 = new Date(e4), n2 = new Date(t4);
                          return a2 || n2 ? a2 ? n2 ? a2.getTime() - n2.getTime() : 1 : -1 : 0;
                        };
                      }
                    }
                    t2 = new Intl.Collator().compare;
                    break;
                  case "number":
                    t2 = function(e4, t3) {
                      return e4 - t3;
                    };
                    break;
                  case "boolean":
                    t2 = function(e4, t3) {
                      return e4 === t3 ? 0 : false === e4 ? -1 : 1;
                    };
                    break;
                  case "object":
                    if (e3 instanceof Date)
                      t2 = function(e4, t3) {
                        return e4 || t3 ? e4 ? t3 ? e4.getTime() - t3.getTime() : 1 : -1 : 0;
                      };
                    else if (e3 instanceof Smart.Utilities.DateTime || e3 instanceof Smart.Utilities.BigNumber)
                      t2 = function(e4, t3) {
                        return e4.compare(t3);
                      };
                    else if (e3 instanceof Smart.Utilities.Complex || window.NIComplex && e3 instanceof window.NIComplex) {
                      const e4 = new Smart.Utilities.ComplexNumericProcessor();
                      t2 = function(t3, a2) {
                        return e4.compareComplexNumbers(t3, a2);
                      };
                    } else
                      t2 = function(e4, t3) {
                        return e4 - t3;
                      };
                }
                return t2;
              };
              if (!e2 || !Array.isArray(e2) || 0 === e2.length || !t || Array.isArray(t) && 0 === t.length)
                return;
              "string" == typeof t && (t = [t]);
              const i = [], o = [];
              void 0 === a && (a = []);
              for (let n2 = 0; n2 < t.length; n2++)
                void 0 === a[n2] || "asc" === a[n2] || "ascending" === a[n2] ? i[n2] = 1 : i[n2] = -1, o[n2] = r(e2[0][t[n2]]);
              if (n)
                return void n(e2, t, a, o);
              const d = e2.slice(0);
              return d.sort(function(e3, a2) {
                for (let n2 = 0; n2 < t.length; n2++) {
                  const r2 = o[n2](e3[t[n2]], a2[t[n2]]);
                  if (0 === r2) {
                    if (t[n2 + 1])
                      continue;
                    return void 0 !== e3._index ? (e3._index - a2._index) * i[n2] : 0;
                  }
                  return r2 * i[n2];
                }
              }), d;
            }
          };
          class e {
            constructor(e2, t) {
              const a = this;
              a.config = e2, a.callback = t, false !== e2.autoFetch && a.call(e2);
            }
            call(e2) {
              const t = this;
              e2 || (e2 = t.config);
              let a = "GET", n = e2.url, r = null, i = true;
              if (e2.type && (a = e2.type), e2.data)
                if ("GET" === a) {
                  n += "?";
                  for (let t2 in e2.data)
                    Object.prototype.hasOwnProperty.call(e2.data, t2) && (n += encodeURI(t2 + "=" + e2.data[t2] + "&"));
                  "&" === n.charAt(n.length - 1) && (n = n.slice(0, n.length - 1));
                } else
                  "POST" === a && (r = JSON.stringify(e2.data));
              e2 && false === e2.async && "xlsx" !== e2.dataSourceType && (i = false), void 0 !== window.fetch && i ? t.ajaxFetch(e2, a, n, r) : t.ajaxXMLHttpRequest(e2, a, n, r, i);
            }
            ajaxFetch(e2, t, a, n) {
              const r = this, i = { method: t };
              let o, d, l, s;
              switch (e2.dataSourceType) {
                case "json":
                  o = "json";
                  break;
                case "xlsx":
                  o = "arrayBuffer";
                  break;
                default:
                  o = "text";
              }
              if (e2 && e2.contentType && (i.headers = new Headers({ "Content-Type": e2.contentType })), null !== n && (i.body = n), e2.timeout && (l = setTimeout(function() {
                s = true;
              }, e2.timeout)), e2.beforeSend) {
                if (false === e2.beforeSend(i, e2))
                  return;
              }
              fetch(a, i).then(function(e3) {
                if (s)
                  throw d = 408, new Error("timeout");
                if (l && clearTimeout(l), d = e3.status, !e3.ok)
                  throw new Error(e3.statusText);
                return e3[o]();
              }).then(function(t2) {
                if ("arrayBuffer" === o)
                  return JSZip.loadAsync(t2).then(function(t3) {
                    return t3.files["xl/worksheets/sheet1.xml"].async("text").then(function(a2) {
                      return t3.files["xl/sharedStrings.xml"].async("text").then(function(t4) {
                        const n2 = r.parseXLSXData(a2, t4);
                        r.ajaxComplete(e2, n2, d);
                      });
                    });
                  });
                r.ajaxComplete(e2, t2, d);
              }).catch(function(t2) {
                "JSZip is not defined" === t2.message && (t2.message = "JSZip is not defined. Please include a reference to JSZip to be able to load data from XLSX files."), e2 && e2.loadError && e2.loadError(d, t2), r.callback && r.callback(t2, d);
              });
            }
            ajaxXMLHttpRequest(e2, t, a, n, r) {
              const i = new XMLHttpRequest(), o = this;
              if (i.open(t, a, r), i.ontimeout = function() {
                e2 && e2.loadError && e2.loadError(408, "timeout");
              }, i.onload = function() {
                if (4 === i.readyState) {
                  const t2 = i.status;
                  let a2 = i.response;
                  t2 >= 200 && t2 <= 299 ? ("json" === e2.dataSourceType && (a2 = JSON.parse(a2)), o.ajaxComplete(e2, a2, t2)) : e2 && e2.loadError && e2.loadError(t2, a2);
                }
              }, i.onerror = function() {
                e2 && e2.loadError && e2.loadError(i.status, i.response);
              }, e2 && e2.contentType && i.setRequestHeader("Content-Type", e2.contentType), r && e2.timeout && (i.timeout = e2.timeout), e2.beforeSend) {
                if (false === e2.beforeSend(i, e2))
                  return;
              }
              i.send(n);
            }
            ajaxComplete(e2, t, a) {
              if (e2) {
                if (e2.beforeLoadComplete) {
                  const a2 = e2.beforeLoadComplete(t);
                  a2 && (t = a2);
                }
                e2.loadComplete && e2.loadComplete(t, a), this.callback && this.callback(t, a);
              }
            }
            parseXLSXData(e2, t) {
              const a = new DOMParser(), n = a.parseFromString(t, "text/xml"), r = Array.from(n.getElementsByTagName("si")), i = [], o = a.parseFromString(e2, "text/xml"), d = Array.from(o.getElementsByTagName("row")), l = [];
              return r.forEach(function(e3) {
                let t2 = e3.getElementsByTagName("t");
                if (1 === t2.length)
                  i.push(t2[0].innerHTML);
                else {
                  let e4 = "";
                  t2 = Array.from(t2), t2.forEach(function(t3) {
                    e4 += t3.innerHTML;
                  }), i.push(e4);
                }
              }), d.forEach(function(e3) {
                const t2 = {};
                Array.from(e3.getElementsByTagName("c")).forEach(function(e4) {
                  const a2 = e4.getAttribute("r").match(/\D+/)[0], n2 = e4.getAttribute("t"), r2 = e4.getElementsByTagName("v")[0].innerHTML;
                  let o2;
                  switch (n2) {
                    case "s":
                      o2 = i[parseFloat(r2)];
                      break;
                    case "b":
                      o2 = 1 === parseFloat(r2);
                      break;
                    default:
                      o2 = parseFloat(r2);
                  }
                  t2[a2] = o2;
                }), l.push(t2);
              }), l;
            }
          }
          Smart.Ajax = window.Ajax = e;
        })();
      }
    ),
    /***/
    9613: (
      /***/
      () => {
        Smart.Utilities.Assign("Draw", class {
          constructor(t, e) {
            const i = this;
            i.host = t, i.renderEngine = e || "", i.refresh();
            const r = ["clear", "removeElement", "attr", "getAttr", "line", "circle", "rect", "path", "pieslice", "pieSlicePath", "text", "measureText"];
            for (let t2 in r)
              i._addFn(Smart.Utilities.Draw.prototype, r[t2]);
          }
          _addFn(t, e) {
            t[e] || (t[e] = function() {
              return this.renderer[e].apply(this.renderer, arguments);
            });
          }
          _initRenderer(t) {
            return this.createRenderer(this, t);
          }
          _internalRefresh() {
            const t = this;
            if (t.renderer || (t.host.innerHTML = "", t._initRenderer(t.host)), "none" === window.getComputedStyle(t.host).display)
              return;
            const e = t.renderer;
            if (!e)
              return;
            const i = e.getRect();
            t._render({ x: 1, y: 1, width: i.width, height: i.height });
          }
          _render(t) {
            this._plotRect = t;
          }
          refresh() {
            this._internalRefresh();
          }
          getSize() {
            const t = this._plotRect;
            return { width: t.width, height: t.height };
          }
          toGreyScale(t) {
            if (-1 === t.indexOf("#"))
              return t;
            const e = this.cssToRgb(t);
            e[0] = e[1] = e[2] = Math.round(0.3 * e[0] + 0.59 * e[1] + 0.11 * e[2]);
            const i = this.rgbToHex(e[0], e[1], e[2]);
            return "#" + i[0] + i[1] + i[2];
          }
          decToHex(t) {
            return t.toString(16);
          }
          hexToDec(t) {
            return parseInt(t, 16);
          }
          rgbToHex(t, e, i) {
            return [this.decToHex(t), this.decToHex(e), this.decToHex(i)];
          }
          hexToRgb(t, e, i) {
            return [this.hexToDec(t), this.hexToDec(e), this.hexToDec(i)];
          }
          cssToRgb(t) {
            return t.indexOf("rgb") <= -1 ? this.hexToRgb(t.substring(1, 3), t.substring(3, 5), t.substring(5, 7)) : t.substring(4, t.length - 1).split(",");
          }
          hslToRgb(t) {
            let e, i, r;
            const s = parseFloat(t[0]), n = parseFloat(t[1]), h = parseFloat(t[2]);
            if (0 === n)
              e = i = r = h;
            else {
              const t2 = h < 0.5 ? h * (1 + n) : h + n - h * n, a = 2 * h - t2;
              e = this.hueToRgb(a, t2, s + 1 / 3), i = this.hueToRgb(a, t2, s), r = this.hueToRgb(a, t2, s - 1 / 3);
            }
            return [255 * e, 255 * i, 255 * r];
          }
          hueToRgb(t, e, i) {
            return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < 0.5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t;
          }
          rgbToHsl(t) {
            const e = parseFloat(t[0]) / 255, i = parseFloat(t[1]) / 255, r = parseFloat(t[2]) / 255, s = Math.max(e, i, r), n = Math.min(e, i, r);
            let h, a, o = (s + n) / 2;
            if (s === n)
              h = a = 0;
            else {
              const t2 = s - n;
              switch (a = o > 0.5 ? t2 / (2 - s - n) : t2 / (s + n), s) {
                case e:
                  h = (i - r) / t2 + (i < r ? 6 : 0);
                  break;
                case i:
                  h = (r - e) / t2 + 2;
                  break;
                case r:
                  h = (e - i) / t2 + 4;
              }
              h /= 6;
            }
            return [h, a, o];
          }
          swap(t, e) {
            const i = t;
            t = e, e = i;
          }
          getNum(t) {
            if (t.constructor !== Array) {
              if (isNaN(t))
                return 0;
            } else
              for (let e = 0; e < t.length; e++)
                if (!isNaN(t[e]))
                  return t[e];
            return 0;
          }
          _ptRotate(t, e, i, r, s) {
            const n = Math.sqrt(Math.pow(Math.abs(t - i), 2) + Math.pow(Math.abs(e - r), 2)), h = Math.asin((t - i) / n) + s;
            return { x: t = i + Math.cos(h) * n, y: e = r + Math.sin(h) * n };
          }
          log(t, e) {
            return Math.log(t) / (e ? Math.log(e) : 1);
          }
          _mod(t, e) {
            const i = Math.abs(t > e ? e : t);
            let r = 1;
            if (0 !== i)
              for (; i * r < 100; )
                r *= 10;
            return (t *= r) % (e *= r) / r;
          }
          createRenderer(t, e) {
            const i = t;
            let r = i.renderer = null;
            return document.createElementNS && "HTML5" !== i.renderEngine && (r = new Smart.Utilities.SvgRenderer(this)), null !== r || "HTML5" !== i.renderEngine && void 0 !== i.renderEngine || (r = new Smart.Utilities.HTML5Renderer(this)), r.init(e), i.renderer = r, r;
          }
          getByPriority(t) {
            let e;
            for (let i = 0; i < t.length; i++) {
              const r = t[i];
              if (null != r && "" !== r) {
                e = r;
                break;
              }
            }
            return e;
          }
          get(t, e, i) {
            return void 0 !== i ? t[e][i] : t[e];
          }
          min(t, e) {
            let i = NaN;
            for (let r = 0; r < t.length; r++) {
              const s = this.get(t, r, e);
              (isNaN(i) || s < i) && (i = s);
            }
            return i;
          }
          max(t, e) {
            let i = NaN;
            for (let r = 0; r < t.length; r++) {
              const s = this.get(t, r, e);
              (isNaN(i) || s > i) && (i = s);
            }
            return i;
          }
          sum(t, e) {
            let i = 0;
            for (let r = 0; r < t.length; r++) {
              const s = this.get(t, r, e);
              isNaN(s) || (i += s);
            }
            return i;
          }
          count(t, e) {
            let i = 0;
            for (let r = 0; r < t.length; r++) {
              const s = this.get(t, r, e);
              isNaN(s) || i++;
            }
            return i;
          }
          avg(t, e) {
            return this.sum(t, e) / Math.max(1, this.count(t, e));
          }
          filter(t, e) {
            if (!e)
              return t;
            const i = [];
            for (let r = 0; r < t.length; r++)
              e(t[r]) && i.push(t[r]);
            return i;
          }
          scale(t, e, i, r) {
            if (isNaN(t))
              return NaN;
            if ((t < Math.min(e.min, e.max) || t > Math.max(e.min, e.max)) && (!r || true !== r.ignore_range))
              return NaN;
            let s = NaN, n = 1;
            if (void 0 === e.type || "logarithmic" !== e.type) {
              let i2 = Math.abs(e.max - e.min);
              i2 || (i2 = 1), n = Math.abs(t - Math.min(e.min, e.max)) / i2;
            } else if ("logarithmic" === e.type) {
              let i2 = e.base;
              isNaN(i2) && (i2 = 10);
              let r2 = Math.min(e.min, e.max);
              r2 <= 0 && (r2 = 1);
              let s2 = Math.max(e.min, e.max);
              s2 <= 0 && (s2 = 1);
              const h = this.log(s2, i2);
              s2 = Math.pow(i2, h);
              const a = this.log(r2, i2);
              r2 = Math.pow(i2, a);
              const o = this.log(t, i2);
              n = Math.abs(o - a) / (h - a);
            }
            if ("logarithmic" === i.type) {
              let t2 = i.base;
              isNaN(t2) && (t2 = 10);
              const e2 = this.log(i.max, t2), r2 = this.log(i.min, t2);
              i.flip && (n = 1 - n);
              const h = Math.min(r2, e2) + n * Math.abs(e2 - r2);
              s = Math.pow(t2, h);
            } else
              s = Math.min(i.min, i.max) + n * Math.abs(i.max - i.min), i.flip && (s = Math.max(i.min, i.max) - s + i.min);
            return s;
          }
          axis(t, e, i) {
            if (i <= 1)
              return [e, t];
            (isNaN(i) || i < 2) && (i = 2);
            let r = 0;
            for (; Math.round(t) !== t && Math.round(e) !== e && r < 10; )
              t *= 10, e *= 10, r++;
            let s = (e - t) / i;
            for (; r < 10 && Math.round(s) !== s; )
              t *= 10, e *= 10, s *= 10, r++;
            const n = [1, 2, 5];
            let h, a = 0;
            for (; ; ) {
              let t2 = a % n.length, e2 = Math.floor(a / n.length), i2 = Math.pow(10, e2) * n[t2];
              if (t2 = (a + 1) % n.length, e2 = Math.floor((a + 1) / n.length), h = Math.pow(10, e2) * n[t2], s >= i2 && s < h)
                break;
              a++;
            }
            const o = h, l = [];
            let d = this.renderer._rnd(t, o, false);
            const c = r <= 0 ? 1 : Math.pow(10, r);
            for (; d < e + o; )
              l.push(d / c), d += o;
            return l;
          }
          _widgetToImage(t, e, i, r, s) {
            let n = t;
            if (!n)
              return false;
            void 0 !== i && "" !== i || (i = "image." + e);
            let h = n.renderEngine, a = n.animation;
            if (n.animation = "none", n.renderEngine = "HTML5", n.renderEngine !== h)
              try {
                n.refresh();
              } catch (t2) {
                return n.renderEngine = h, n.refresh(), n.animation = a, false;
              }
            let o = n.renderer.getContainer().firstElementChild, l = true;
            "function" == typeof r && (l = r(t, o));
            let d = true;
            return l && (d = this.exportImage(t, o, e, i, s)), n.renderEngine !== h && (n.renderEngine = h, n.refresh(), n.animation = a), d;
          }
          _saveAsImage(t, e) {
            return this._widgetToImage(this, t, e);
          }
          saveAsPNG(t) {
            return this._saveAsImage("png", t);
          }
          saveAsJPEG(t) {
            return this._saveAsImage("jpeg", t);
          }
          exportImage(t, e, i, r, s) {
            if (!e)
              return false;
            let n = "pdf" === i.toLowerCase();
            n && (i = "jpeg"), void 0 !== r && "" !== r || (r = "image." + i);
            let h = true;
            if ("print" !== i) {
              try {
                if (e)
                  if (n) {
                    s = s || "portrait";
                    const n2 = { content: { image: e.toDataURL("image/" + i), width: Math.min(e.width / 1.35, "portrait" === s ? 515 : 762) }, pageOrientation: s };
                    try {
                      pdfMake.createPdf(n2).download(r);
                    } catch (e2) {
                      t.error(t.localize("missingReference", { files: "pdfmake.min.js" }));
                    }
                  } else {
                    Smart.Utilities.DataExporter || t.error(t.localize("missingReference", { files: "smart.export.js" }));
                    const s2 = new Smart.Utilities.DataExporter();
                    e.toBlob(function(t2) {
                      s2.downloadFile(t2, i, r);
                    });
                  }
              } catch (t2) {
                h = false;
              }
              return h;
            }
            {
              const t2 = window.open("", "", "width=800,height=500"), i2 = t2.document.open(), r2 = '<!DOCTYPE html><html><head><meta charset="utf-8" /><title>jQWidgets Chart</title></head><body><img src="' + e.toDataURL() + '" /></html>';
              try {
                i2.write(r2), i2.close(), setTimeout(function() {
                  t2.print(), t2.close();
                }, 100);
              } catch (t3) {
              }
            }
          }
        }), Smart.Utilities.Assign("Renderer", class {
          constructor(t) {
            const e = this;
            e.draw = t, e._gradients = {}, e._toRadiansCoefficient = 2 * Math.PI / 360;
          }
          pieSlicePath(t, e, i, r, s, n, h) {
            r || (r = 1);
            const a = Math.abs(s - n), o = a > 180 ? 1 : 0;
            a >= 360 && (n = s + 359.99);
            const l = s * this._toRadiansCoefficient, d = n * this._toRadiansCoefficient;
            let c = t, p = t, u = e, g = e;
            const f = !isNaN(i) && i > 0;
            f && (h = 0);
            const m = Math.cos(l), _ = Math.sin(l), x = Math.cos(d), M = Math.sin(d);
            if (h + i > 0) {
              if (h > 0) {
                const i2 = (a / 2 + s) * this._toRadiansCoefficient;
                t += h * Math.cos(i2), e -= h * Math.sin(i2);
              }
              f && (c = t + i * m, u = e - i * _, p = t + i * x, g = e - i * M);
            }
            const y = t + r * m, w = t + r * x, N = e - r * _, v = e - r * M;
            let b = "";
            const C = Math.abs(Math.abs(n - s) - 360) > 0.02;
            return f ? (b = "M " + p + "," + g, b += " a" + i + "," + i, b += " 0 " + o + ",1 " + (c - p) + "," + (u - g), b += C ? " L" + y + "," + N : " M" + y + "," + N, b += " a" + r + "," + r, b += " 0 " + o + ",0 " + (w - y) + "," + (v - N), C && (b += " Z")) : (b = "M " + w + "," + v, b += " a" + r + "," + r, b += " 0 " + o + ",1 " + (y - w) + "," + (N - v), C && (b += " L" + t + "," + e, b += " Z")), b;
          }
          measureText(t, e, i, r) {
            const s = this._getTextParts(t, e, i), n = s.width;
            let h = s.height;
            false === r && (h /= 0.6);
            let a = {};
            if (isNaN(e) && (e = 0), 0 === e)
              a = { width: this._rup(n), height: this._rup(h) };
            else {
              const t2 = e * Math.PI * 2 / 360, i2 = Math.abs(Math.sin(t2)), r2 = Math.abs(Math.cos(t2)), s2 = Math.abs(n * i2 + h * r2), o = Math.abs(n * r2 + h * i2);
              a = { width: this._rup(o), height: this._rup(s2) };
            }
            return r && (a.textPartsInfo = s), a;
          }
          alignTextInRect(t, e, i, r, s, n, h, a, o, l) {
            const d = o * Math.PI * 2 / 360, c = Math.sin(d), p = Math.cos(d), u = s * c, g = s * p;
            "center" === h || "" === h || "undefined" === h ? t += i / 2 : "right" === h && (t += i), "center" === a || "middle" === a || "" === a || "undefined" === a ? e += r / 2 : "bottom" === a ? e += r - n / 2 : "top" === a && (e += n / 2);
            let f = "middle";
            -1 !== (l = l || "").indexOf("top") ? f = "top" : -1 !== l.indexOf("bottom") && (f = "bottom");
            let m = "center";
            return -1 !== l.indexOf("left") ? m = "left" : -1 !== l.indexOf("right") && (m = "right"), "center" === m ? (t -= g / 2, e -= u / 2) : "right" === m && (t -= g, e -= u), "top" === f ? (t -= n * c, e += n * p) : "middle" === f && (t -= n * c / 2, e += n * p / 2), { x: t = this._rup(t), y: e = this._rup(e) };
          }
          adjustColor(t, e) {
            if ("string" != typeof t)
              return "#000000";
            if (-1 === t.indexOf("#"))
              return t;
            const i = this.draw;
            let r = i.cssToRgb(t);
            const s = i.rgbToHsl(r);
            s[2] = Math.min(1, s[2] * e), s[1] = Math.min(1, s[1] * e * 1.1), r = i.hslToRgb(s), t = "#";
            for (let e2 = 0; e2 < 3; e2++) {
              let s2 = Math.round(r[e2]);
              s2 = i.decToHex(s2), 1 === s2.toString().length && (t += "0"), t += s2;
            }
            return t.toUpperCase();
          }
          _rup(t) {
            let e = Math.round(t);
            return t > e && e++, e;
          }
          _ptdist(t, e, i, r) {
            return Math.sqrt((i - t) * (i - t) + (r - e) * (r - e));
          }
          _rnd(t, e, i, r) {
            if (isNaN(t))
              return t;
            void 0 === r && (r = true);
            let s = t - (true === r ? t % e : this._mod(t, e));
            return t === s ? s : (i ? t > s && (s += e) : s > t && (s -= e), 1 === e ? Math.round(s) : s);
          }
          _ptrnd(t) {
            if (!document.createElementNS)
              return Math.round(t) === t ? t : this._rnd(t, 1, false, true);
            const e = this._rnd(t, 0.5, false, true);
            return 0.5 !== Math.abs(e - Math.round(e)) ? e > t ? e - 0.5 : e + 0.5 : e;
          }
          _getContrastColor(t) {
            if (void 0 === t)
              return;
            let e = this.draw.hexToRgb(t.slice(1, 3), t.slice(3, 5), t.slice(5, 7));
            return (0.299 * e[0] + 0.61 * e[1] + 0.114 * e[2]) / 255 > 0.6 ? "#000000" : "#FFFFFF";
          }
        }), Smart.Utilities.Assign("SvgRenderer", class extends Smart.Utilities.Renderer {
          constructor(t) {
            super(t);
            const e = this;
            e._svgns = "http://www.w3.org/2000/svg", e._openGroups = [], e._clipId = 0;
          }
          init(t) {
            const e = document.createElement("div");
            e.className = "drawContainer", e.onselectstart = function() {
              return false;
            }, t.appendChild(e), this.host = t, this.container = e;
            try {
              const t2 = document.createElementNS(this._svgns, "svg");
              t2.setAttribute("version", "1.1"), t2.setAttribute("width", "100%"), t2.setAttribute("height", "100%"), t2.setAttribute("overflow", "hidden"), e.appendChild(t2), this.canvas = t2;
            } catch (t2) {
              return false;
            }
            return this._id = (/* @__PURE__ */ new Date()).getTime(), this.clear(), true;
          }
          getType() {
            return "SVG";
          }
          refresh() {
          }
          getRect() {
            return { x: 0, y: 0, width: Math.max(this._rup(this.host.offsetWidth) - 1, 0), height: Math.max(this._rup(this.host.offsetHeight) - 1, 0) };
          }
          getContainer() {
            return this.container;
          }
          clear() {
            for (; this.canvas.childNodes.length > 0; )
              this.removeElement(this.canvas.firstElementChild);
            this._defaultParent = void 0, this._defs = document.createElementNS(this._svgns, "defs"), this._gradients = {}, this.canvas.appendChild(this._defs);
          }
          removeElement(t) {
            if (void 0 !== t)
              try {
                for (; t.firstChild; )
                  this.removeElement(t.firstChild);
                t.parentNode ? t.parentNode.removeChild(t) : this.canvas.removeChild(t);
              } catch (t2) {
              }
          }
          beginGroup() {
            const t = this._activeParent(), e = document.createElementNS(this._svgns, "g");
            return t.appendChild(e), this._openGroups.push(e), e;
          }
          endGroup() {
            0 !== this._openGroups.length && this._openGroups.pop();
          }
          _activeParent() {
            return 0 === this._openGroups.length ? this.canvas : this._openGroups[this._openGroups.length - 1];
          }
          createClipRect(t) {
            const e = document.createElementNS(this._svgns, "clipPath"), i = document.createElementNS(this._svgns, "rect");
            return this.attr(i, { x: t.x, y: t.y, width: t.width, height: t.height, fill: "none" }), this._clipId = this._clipId || 0, e.id = "cl" + this._id + "_" + (++this._clipId).toString(), e.appendChild(i), this._defs.appendChild(e), e;
          }
          getWindowHref() {
            let t = window.location.href;
            return t ? (t = t.replace(/([\('\)])/g, "\\$1"), t = t.replace(/#.*$/, ""), t) : t;
          }
          setClip(t, e) {
            const i = "url(" + this.getWindowHref() + "#" + e.id + ")";
            return this.attr(t, { "clip-path": i });
          }
          addHandler(t, e, i) {
            t.addEventListener(e, i);
          }
          removeHandler() {
          }
          on(t, e, i) {
            this.addHandler(t, e, i);
          }
          off(t, e, i) {
            this.removeHandler(t, e, i);
          }
          shape(t, e) {
            const i = document.createElementNS(this._svgns, t);
            if (i) {
              for (let t2 in e)
                i.setAttribute(t2, e[t2]);
              return this._activeParent().appendChild(i), i;
            }
          }
          _getTextParts(t, e, i) {
            const r = { width: 0, height: 0, parts: [] };
            if (void 0 === t)
              return r;
            const s = t.toString().split("<br>"), n = this._activeParent(), h = document.createElementNS(this._svgns, "text");
            this.attr(h, i);
            for (let t2 = 0; t2 < s.length; t2++) {
              const e2 = s[t2], i2 = h.ownerDocument.createTextNode(e2);
              let a;
              h.appendChild(i2), n.appendChild(h);
              try {
                a = h.getBBox();
              } catch (t3) {
              }
              const o = this._rup(a.width), l = this._rup(0.6 * a.height);
              h.removeChild(i2), r.width = Math.max(r.width, o), r.height += l + (t2 > 0 ? 4 : 0), r.parts.push({ width: o, height: l, text: e2 });
            }
            return n.removeChild(h), r;
          }
          _measureText(t, e, i, r) {
            return super.measureText(t, e, i, r);
          }
          measureText(t, e, i) {
            return this._measureText(t, e, i, false);
          }
          text(t, e, i, r, s, n, h, a, o, l, d) {
            const c = this._measureText(t, n, h, true, this).textPartsInfo, p = c.parts, u = this._getContrastColor(arguments[11]);
            let g;
            if (o || (o = "center"), l || (l = "center"), (p.length > 1 || a) && (g = this.beginGroup()), a) {
              const t2 = this.createClipRect({ x: this._rup(e) - 1, y: this._rup(i) - 1, width: this._rup(r) + 2, height: this._rup(s) + 2 });
              this.setClip(g, t2);
            }
            let f = this._activeParent(), m = 0, _ = 0;
            m = c.width, _ = c.height, (isNaN(r) || r <= 0) && (r = m), (isNaN(s) || s <= 0) && (s = _);
            const x = r || 0, M = s || 0;
            let y = 0;
            if (!n || 0 === n) {
              let t2;
              i += _, "center" === l || "middle" === l ? i += (M - _) / 2 : "bottom" === l && (i += M - _), r || (r = m), s || (s = _), f = this._activeParent();
              for (let r2 = p.length - 1; r2 >= 0; r2--) {
                t2 = document.createElementNS(this._svgns, "text"), this.attr(t2, h), this.attr(t2, { cursor: "default" });
                const s2 = t2.ownerDocument.createTextNode(p[r2].text);
                t2.appendChild(s2);
                let n2 = e;
                const a2 = p[r2].width, l2 = p[r2].height;
                "center" === o ? n2 += (x - a2) / 2 : "right" === o && (n2 += x - a2), this.attr(t2, { x: this._rup(n2), y: this._rup(i + y), width: this._rup(a2), height: this._rup(l2) }), void 0 !== u && (t2.style.fill = u), f.appendChild(t2), y -= p[r2].height + 4;
              }
              return g ? (this.endGroup(), g) : t2;
            }
            const w = this.alignTextInRect(e, i, r, s, m, _, o, l, n, d);
            e = w.x, i = w.y;
            const N = this.shape("g", { transform: "translate(" + e + "," + i + ")" }), v = this.shape("g", { transform: "rotate(" + n + ")" });
            N.appendChild(v), y = 0;
            for (let t2 = p.length - 1; t2 >= 0; t2--) {
              const e2 = document.createElementNS(this._svgns, "text");
              this.attr(e2, h), this.attr(e2, { cursor: "default" });
              const i2 = e2.ownerDocument.createTextNode(p[t2].text);
              e2.appendChild(i2);
              let r2 = 0;
              const s2 = p[t2].width, n2 = p[t2].height;
              "center" === o ? r2 += (c.width - s2) / 2 : "right" === o && (r2 += c.width - s2), this.attr(e2, { x: this._rup(r2), y: this._rup(y), width: this._rup(s2), height: this._rup(n2) }), v.appendChild(e2), y -= n2 + 4;
            }
            return f.appendChild(N), g && this.endGroup(), N;
          }
          line(t, e, i, r, s) {
            const n = this.shape("line", { x1: t, y1: e, x2: i, y2: r });
            return this.attr(n, s), n;
          }
          path(t, e) {
            const i = this.shape("path");
            return i.setAttribute("d", t), e && this.attr(i, e), i;
          }
          rect(t, e, i, r, s) {
            t = this._ptrnd(t), e = this._ptrnd(e), i = Math.max(1, this._rnd(i, 1, false)), r = Math.max(1, this._rnd(r, 1, false));
            const n = this.shape("rect", { x: t, y: e, width: i, height: r });
            return s && this.attr(n, s), n;
          }
          circle(t, e, i, r) {
            const s = this.shape("circle", { cx: t, cy: e, r: i });
            return r && this.attr(s, r), s;
          }
          pieslice(t, e, i, r, s, n, h, a) {
            const o = this.pieSlicePath(t, e, i, r, s, n, h), l = this.shape("path");
            return l.setAttribute("d", o), a && this.attr(l, a), l;
          }
          attr(t, e) {
            if (t && e)
              for (let i in e)
                "textContent" === i ? t.textContent = e[i] : "width" === i || "height" === i ? t.setAttribute(i, Math.max(0, e[i])) : t.setAttribute(i, e[i]);
          }
          removeAttr(t, e) {
            if (t && e)
              for (let i in e)
                "textContent" === i ? t.textContent = "" : t.removeAttribute(e[i]);
          }
          getAttr(t, e) {
            return t.getAttribute(e);
          }
          _toLinearGradient(t, e, i) {
            const r = "grd" + this._id + t.replace("#", "") + (e ? "v" : "h"), s = "url(" + this.getWindowHref() + "#" + r + ")";
            if (this._gradients[s])
              return s;
            const n = document.createElementNS(this._svgns, "linearGradient");
            this.attr(n, { x1: "0%", y1: "0%", x2: e ? "0%" : "100%", y2: e ? "100%" : "0%", id: r });
            for (let e2 = 0; e2 < i.length; e2++) {
              const r2 = i[e2], s2 = document.createElementNS(this._svgns, "stop"), h = "stop-color:" + this.adjustColor(t, r2[1]);
              this.attr(s2, { offset: r2[0] + "%", style: h }), n.appendChild(s2);
            }
            return this._defs.appendChild(n), this._gradients[s] = true, s;
          }
          _toRadialGradient(t, e, i) {
            const r = "grd" + this._id + t.replace("#", "") + "r" + (void 0 !== i ? i.key : ""), s = "url(" + this.getWindowHref() + "#" + r + ")";
            if (this._gradients[s])
              return s;
            const n = document.createElementNS(this._svgns, "radialGradient");
            void 0 === i ? this.attr(n, { cx: "50%", cy: "50%", r: "100%", fx: "50%", fy: "50%", id: r }) : this.attr(n, { cx: i.x, cy: i.y, r: i.outerRadius, id: r, gradientUnits: "userSpaceOnUse" });
            for (let i2 = 0; i2 < e.length; i2++) {
              const r2 = e[i2], s2 = document.createElementNS(this._svgns, "stop"), h = "stop-color:" + this.adjustColor(t, r2[1]);
              this.attr(s2, { offset: r2[0] + "%", style: h }), n.appendChild(s2);
            }
            return this._defs.appendChild(n), this._gradients[s] = true, s;
          }
        }), Smart.Utilities.Assign("HTML5Renderer", class extends Smart.Utilities.Renderer {
          constructor(t) {
            super(t), this._renderers = new Smart.Utilities.HTML5RenderHelpers(this);
          }
          init(t) {
            try {
              this.host = t;
              const e = document.createElement("div"), i = document.createElement("canvas");
              e.className = "chartContainer", e.style.position = "relative", e.onselectstart = function() {
                return false;
              }, i.id = "__smartCanvasWrap", i.style.width = "100%", i.style.height = "100%", e.appendChild(i), t.appendChild(e), this.canvas = i, i.width = t.offsetWidth, i.height = t.offsetHeight, this.ctx = i.getContext("2d"), this._elements = {}, this._maxId = 0, this._gradientId = 0, this._gradients = {}, this._currentPoint = { x: 0, y: 0 }, this._lastCmd = "", this._pos = 0;
            } catch (t2) {
              return false;
            }
            return true;
          }
          getType() {
            return "HTML5";
          }
          getContainer() {
            return this.host.getElementsByClassName("chartContainer")[0];
          }
          getRect() {
            return { x: 0, y: 0, width: this.canvas.width - 1, height: this.canvas.height - 1 };
          }
          beginGroup() {
          }
          endGroup() {
          }
          setClip() {
          }
          createClipRect() {
          }
          addHandler() {
          }
          removeHandler() {
          }
          on(t, e, i) {
            this.addHandler(t, e, i);
          }
          off(t, e, i) {
            this.removeHandler(t, e, i);
          }
          clear() {
            this._elements = {}, this._maxId = 0, this._renderers._gradients = {}, this._gradientId = 0;
          }
          removeElement(t) {
            void 0 !== t && this._elements[t.id] && delete this._elements[t.id];
          }
          shape(t, e) {
            let i = { type: t, id: this._maxId++ };
            for (let t2 in e)
              i[t2] = e[t2];
            return this._elements[i.id] = i, i;
          }
          attr(t, e) {
            for (let i in e)
              t[i] = e[i];
          }
          removeAttr(t, e) {
            for (let i in e)
              delete t[e[i]];
          }
          rect(t, e, i, r, s) {
            if (isNaN(t))
              throw 'Invalid value for "x"';
            if (isNaN(e))
              throw 'Invalid value for "y"';
            if (isNaN(i))
              throw 'Invalid value for "width"';
            if (isNaN(r))
              throw 'Invalid value for "height"';
            let n = this.shape("rect", { x: t, y: e, width: i, height: r });
            return s && this.attr(n, s), n;
          }
          path(t, e) {
            let i = this.shape("path", e);
            return this.attr(i, { d: t }), i;
          }
          line(t, e, i, r, s) {
            return this.path("M " + t + "," + e + " L " + i + "," + r, s);
          }
          circle(t, e, i, r) {
            let s = this.shape("circle", { x: t, y: e, r: i });
            return r && this.attr(s, r), s;
          }
          pieslice(t, e, i, r, s, n, h, a) {
            let o = this.path(this.pieSlicePath(t, e, i, r, s, n, h), a);
            return this.attr(o, { x: t, y: e, innerRadius: i, outerRadius: r, angleFrom: s, angleTo: n }), o;
          }
          _getCSSStyle(t) {
            const e = document.createElement("div");
            e.className = t, e.style.position = "absolute", e.style.visibility = "hidden", this.host.appendChild(e);
            let i = window.getComputedStyle(e);
            return i = { color: i.color, fontFamily: i.fontFamily, fontSize: i.fontSize, fontWeight: i.fontWeight }, this.host.removeChild(e), i;
          }
          _getTextParts(t, e, i) {
            let r = "Arial", s = "10pt", n = "";
            if (i && i.class) {
              let t2 = this._getCSSStyle(i.class);
              t2.fontSize && (s = t2.fontSize), t2.fontFamily && (r = t2.fontFamily), t2.fontWeight && (n = t2.fontWeight);
            }
            this.ctx.font = n + " " + s + " " + r;
            let h = { width: 0, height: 0, parts: [] }, a = t.toString().split("<br>");
            for (let t2 = 0; t2 < a.length; t2++) {
              let e2 = a[t2], i2 = this.ctx.measureText(e2).width, r2 = document.createElement("span");
              r2.className = "chart", r2.font = this.ctx.font, r2.textContent = e2, this.host.appendChild(r2);
              let s2 = 0.6 * r2.offsetHeight;
              this.host.removeChild(r2), h.width = Math.max(h.width, this._rup(i2)), h.height += s2 + (t2 > 0 ? 4 : 0), h.parts.push({ width: i2, height: s2, text: e2 });
            }
            return h;
          }
          _measureText(t, e, i, r) {
            return super.measureText(t, e, i, r);
          }
          measureText(t, e, i) {
            return this._measureText(t, e, i, false);
          }
          text(t, e, i, r, s, n, h, a, o, l, d) {
            let c = this.shape("text", { text: t, x: e, y: i, width: r, height: s, angle: n, clip: a, halign: o, valign: l, rotateAround: d });
            if (h && this.attr(c, h), c.fontFamily = "Arial", c.fontSize = "10pt", c.fontWeight = "", c.color = this._getContrastColor(arguments[11]), h && h.class) {
              let t2 = this._getCSSStyle(h.class);
              c.fontFamily = t2.fontFamily || c.fontFamily, c.fontSize = t2.fontSize || c.fontSize, c.fontWeight = t2.fontWeight || c.fontWeight, c.color = c.color || t2.color;
            }
            c.color = c.color || "#000000";
            let p = this._measureText(t, 0, h, true);
            return this.attr(c, { textPartsInfo: p.textPartsInfo, textWidth: p.width, textHeight: p.height }), (r <= 0 || isNaN(r)) && this.attr(c, { width: p.width }), (s <= 0 || isNaN(s)) && this.attr(c, { height: p.height }), c;
          }
          _toLinearGradient(t, e, i) {
            if (this._renderers._gradients[t])
              return t;
            let r = [];
            for (let e2 = 0; e2 < i.length; e2++)
              r.push({ percent: i[e2][0] / 100, color: this.adjustColor(t, i[e2][1]) });
            let s = "gr" + this._gradientId++;
            return this.createGradient(s, e ? "vertical" : "horizontal", r), s;
          }
          _toRadialGradient(t, e) {
            if (this._renderers._gradients[t])
              return t;
            let i = [];
            for (let r2 = 0; r2 < e.length; r2++)
              i.push({ percent: e[r2][0] / 100, color: this.adjustColor(t, e[r2][1]) });
            let r = "gr" + this._gradientId++;
            return this.createGradient(r, "radial", i), r;
          }
          createGradient(t, e, i) {
            this._renderers.createGradient(this, t, e, i);
          }
          refresh() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            for (let t in this._elements) {
              let e = this._elements[t];
              this._renderers.setFillStyle(this, e), this._renderers.setStroke(this, e), this._renderers[this._elements[t].type](this.ctx, e);
            }
          }
        }), Smart.Utilities.Assign("HTML5RenderHelpers", class {
          constructor(t) {
            this.HTML5Renderer = t, this._cmds = "mlcazq";
          }
          ptrnd(t) {
            if (0.5 === Math.abs(Math.round(t) - t))
              return t;
            let e = Math.round(t);
            return e < t && (e -= 1), e + 0.5;
          }
          createGradient(t, e, i, r) {
            t._gradients[e] = { orientation: i, colorStops: r };
          }
          setStroke(t, e) {
            let i = t.ctx, r = e["stroke-width"];
            i.strokeStyle = e.stroke || "transparent", i.lineWidth = 0 === r ? 0.01 : void 0 !== r ? r : 1, void 0 !== e["fill-opacity"] ? i.globalAlpha = e["fill-opacity"] : void 0 !== e.opacity ? i.globalAlpha = e.opacity : i.globalAlpha = 1, i.setLineDash && (e["stroke-dasharray"] ? i.setLineDash(e["stroke-dasharray"].split(",")) : i.setLineDash([]));
          }
          setFillStyle(t, e) {
            let i = t.ctx;
            if (i.fillStyle = "transparent", void 0 !== e["fill-opacity"] ? i.globalAlpha = e["fill-opacity"] : void 0 !== e.opacity ? i.globalAlpha = e.opacity : i.globalAlpha = 1, e.fill && -1 === e.fill.indexOf("#") && t._gradients[e.fill]) {
              let r, s = "horizontal" !== t._gradients[e.fill].orientation, n = "radial" === t._gradients[e.fill].orientation, h = this.ptrnd(e.x), a = this.ptrnd(e.y), o = this.ptrnd(e.x + (s ? 0 : e.width)), l = this.ptrnd(e.y + (s ? e.height : 0));
              if (("circle" === e.type || "path" === e.type || "rect" === e.type) && n) {
                let t2 = this.ptrnd(e.x), s2 = this.ptrnd(e.y);
                const n2 = e.innerRadius || 0, h2 = e.outerRadius || e.r || 0;
                "rect" === e.type && (t2 += e.width / 2, s2 += e.height / 2), r = i.createRadialGradient(t2, s2, n2, t2, s2, h2);
              }
              n || ((isNaN(h) || isNaN(o) || isNaN(a) || isNaN(l)) && (h = 0, a = 0, o = s ? 0 : i.canvas.width, l = s ? i.canvas.height : 0), r = i.createLinearGradient(h, a, o, l));
              let d = t._gradients[e.fill].colorStops;
              for (let t2 = 0; t2 < d.length; t2++)
                r.addColorStop(d[t2].percent, d[t2].color);
              i.fillStyle = r;
            } else
              e.fill && (i.fillStyle = e.fill);
          }
          rect(t, e) {
            0 !== e.width && 0 !== e.height && (t.fillRect(this.ptrnd(e.x), this.ptrnd(e.y), e.width, e.height), t.strokeRect(this.ptrnd(e.x), this.ptrnd(e.y), e.width, e.height));
          }
          circle(t, e) {
            0 !== e.r && (t.beginPath(), t.arc(this.ptrnd(e.x), this.ptrnd(e.y), e.r, 0, 2 * Math.PI, false), t.closePath(), t.fill(), t.stroke());
          }
          _parsePoint(t) {
            return { x: this._parseNumber(t), y: this._parseNumber(t) };
          }
          _parseNumber(t) {
            let e, i = false;
            for (e = this._pos; e < t.length; e++)
              if (t[e] >= "0" && t[e] <= "9" || "." === t[e] || "e" === t[e] || "-" === t[e] && !i || "-" === t[e] && e >= 1 && "e" === t[e - 1])
                i = true;
              else {
                if (i || " " !== t[e] && "," !== t[e])
                  break;
                this._pos++;
              }
            let r = parseFloat(t.substring(this._pos, e));
            if (!isNaN(r))
              return this._pos = e, r;
          }
          _isRelativeCmd(t) {
            return -1 !== this._cmds.indexOf(t);
          }
          _parseCmd(t) {
            for (let e = this._pos; e < t.length; e++) {
              if (-1 !== this._cmds.toLowerCase().indexOf(t[e].toLowerCase()))
                return this._pos = e + 1, this._lastCmd = t[e], this._lastCmd;
              if (" " !== t[e]) {
                if (t[e] >= "0" && t[e] <= "9") {
                  if (this._pos = e, "" === this._lastCmd)
                    break;
                  return this._lastCmd;
                }
              } else
                this._pos++;
            }
          }
          _toAbsolutePoint(t) {
            return { x: this._currentPoint.x + t.x, y: this._currentPoint.y + t.y };
          }
          path(t, e) {
            let i, r = e.d;
            for (this._pos = 0, this._lastCmd = "", this._currentPoint = { x: 0, y: 0 }, t.beginPath(); this._pos < r.length; ) {
              let e2 = this._parseCmd(r);
              if (void 0 === e2)
                break;
              if ("M" !== e2 && "m" !== e2)
                if ("L" !== e2 && "l" !== e2)
                  if ("A" !== e2 && "a" !== e2)
                    if ("Z" !== e2 && "z" !== e2 || void 0 === i)
                      if ("C" !== e2 && "c" !== e2)
                        if ("Q" !== e2 && "q" !== e2)
                          ;
                        else {
                          let e3 = this._parsePoint(r), i2 = this._parsePoint(r);
                          t.quadraticCurveTo(e3.x, e3.y, i2.x, i2.y), this._currentPoint = i2;
                        }
                      else {
                        let e3 = this._parsePoint(r), i2 = this._parsePoint(r), s = this._parsePoint(r);
                        t.bezierCurveTo(e3.x, e3.y, i2.x, i2.y, s.x, s.y), this._currentPoint = s;
                      }
                    else
                      t.lineTo(i.x, i.y), this._currentPoint = i;
                  else {
                    let i2 = this._parseNumber(r), s = this._parseNumber(r), n = this._parseNumber(r) * (Math.PI / 180), h = this._parseNumber(r), a = this._parseNumber(r), o = this._parsePoint(r);
                    if (this._isRelativeCmd(e2) && (o = this._toAbsolutePoint(o)), 0 === i2 || 0 === s)
                      continue;
                    let l = this._currentPoint, d = { x: Math.cos(n) * (l.x - o.x) / 2 + Math.sin(n) * (l.y - o.y) / 2, y: -Math.sin(n) * (l.x - o.x) / 2 + Math.cos(n) * (l.y - o.y) / 2 }, c = Math.pow(d.x, 2) / Math.pow(i2, 2) + Math.pow(d.y, 2) / Math.pow(s, 2);
                    c > 1 && (i2 *= Math.sqrt(c), s *= Math.sqrt(c));
                    let p = (h === a ? -1 : 1) * Math.sqrt((Math.pow(i2, 2) * Math.pow(s, 2) - Math.pow(i2, 2) * Math.pow(d.y, 2) - Math.pow(s, 2) * Math.pow(d.x, 2)) / (Math.pow(i2, 2) * Math.pow(d.y, 2) + Math.pow(s, 2) * Math.pow(d.x, 2)));
                    isNaN(p) && (p = 0);
                    let u = { x: p * i2 * d.y / s, y: p * -s * d.x / i2 }, g = { x: (l.x + o.x) / 2 + Math.cos(n) * u.x - Math.sin(n) * u.y, y: (l.y + o.y) / 2 + Math.sin(n) * u.x + Math.cos(n) * u.y }, f = function(t2) {
                      return Math.sqrt(Math.pow(t2[0], 2) + Math.pow(t2[1], 2));
                    }, m = function(t2, e3) {
                      return (t2[0] * e3[0] + t2[1] * e3[1]) / (f(t2) * f(e3));
                    }, _ = function(t2, e3) {
                      return (t2[0] * e3[1] < t2[1] * e3[0] ? -1 : 1) * Math.acos(m(t2, e3));
                    }, x = _([1, 0], [(d.x - u.x) / i2, (d.y - u.y) / s]), M = [(d.x - u.x) / i2, (d.y - u.y) / s], y = [(-d.x - u.x) / i2, (-d.y - u.y) / s], w = _(M, y);
                    m(M, y) <= -1 && (w = Math.PI), m(M, y) >= 1 && (w = 0), 0 === a && w > 0 && (w -= 2 * Math.PI), 1 === a && w < 0 && (w += 2 * Math.PI);
                    let N = i2 > s ? i2 : s, v = i2 > s ? 1 : i2 / s, b = i2 > s ? s / i2 : 1;
                    t.translate(g.x, g.y), t.rotate(n), t.scale(v, b), t.arc(0, 0, N, x, x + w, 1 - a), t.scale(1 / v, 1 / b), t.rotate(-n), t.translate(-g.x, -g.y);
                  }
                else {
                  let e3 = this._parsePoint(r);
                  if (void 0 === e3)
                    break;
                  t.lineTo(e3.x, e3.y), this._currentPoint = e3;
                }
              else {
                let e3 = this._parsePoint(r);
                if (void 0 === e3)
                  break;
                t.moveTo(e3.x, e3.y), this._currentPoint = e3, void 0 === i && (i = e3);
              }
            }
            t.fill(), t.stroke(), t.closePath();
          }
          text(t, e) {
            let i = this.ptrnd(e.x), r = this.ptrnd(e.y), s = this.ptrnd(e.width), n = this.ptrnd(e.height), h = e.halign, a = e.valign, o = e.angle, l = e.rotateAround, d = e.textPartsInfo, c = d.parts, p = e.clip;
            void 0 === p && (p = true), t.save(), h || (h = "center"), a || (a = "center"), p && (t.rect(i, r, s, n), t.clip());
            let u = e.textWidth, g = e.textHeight, f = s || 0, m = n || 0;
            if (t.fillStyle = e.color, t.font = e.fontWeight + " " + e.fontSize + " " + e.fontFamily, !o || 0 === o) {
              r += g, "center" === a || "middle" === a ? r += (m - g) / 2 : "bottom" === a && (r += m - g), s || (s = u), n || (n = g);
              let e2 = 0;
              for (let s2 = c.length - 1; s2 >= 0; s2--) {
                let n2 = c[s2], a2 = i, o2 = c[s2].width;
                "center" === h ? a2 += (f - o2) / 2 : "right" === h && (a2 += f - o2), t.fillText(n2.text, a2, r + e2), e2 -= n2.height + (s2 > 0 ? 4 : 0);
              }
              return void t.restore();
            }
            let _ = this.HTML5Renderer.alignTextInRect(i, r, s, n, u, g, h, a, o, l);
            i = _.x, r = _.y;
            let x = o * Math.PI * 2 / 360;
            t.translate(i, r), t.rotate(x);
            let M = 0, y = d.width;
            for (let e2 = c.length - 1; e2 >= 0; e2--) {
              let i2 = 0;
              "center" === h ? i2 += (y - c[e2].width) / 2 : "right" === h && (i2 += y - c[e2].width), t.fillText(c[e2].text, i2, M), M -= c[e2].height + 4;
            }
            t.restore();
          }
        }), Smart.Utilities.Assign("Plot", class {
          constructor(t) {
            this.renderer = t;
          }
          get(t, e, i) {
            return void 0 !== i ? t[e][i] : t[e];
          }
          min(t, e) {
            let i = NaN;
            for (let r = 0; r < t.length; r++) {
              let s = this.get(t, r, e);
              (isNaN(i) || s < i) && (i = s);
            }
            return i;
          }
          max(t, e) {
            let i = NaN;
            for (let r = 0; r < t.length; r++) {
              let s = this.get(t, r, e);
              (isNaN(i) || s > i) && (i = s);
            }
            return i;
          }
          sum(t, e) {
            let i = 0;
            for (let r = 0; r < t.length; r++) {
              let s = this.get(t, r, e);
              isNaN(s) || (i += s);
            }
            return i;
          }
          count(t, e) {
            let i = 0;
            for (let r = 0; r < t.length; r++) {
              let s = this.get(t, r, e);
              isNaN(s) || i++;
            }
            return i;
          }
          avg(t, e) {
            return this.sum(t, e) / Math.max(1, this.count(t, e));
          }
          filter(t, e) {
            if (!e)
              return t;
            let i = [];
            for (let r = 0; r < t.length; r++)
              e(t[r]) && i.push(t[r]);
            return i;
          }
          scale(t, e, i, r) {
            if (isNaN(t))
              return NaN;
            if ((t < Math.min(e.min, e.max) || t > Math.max(e.min, e.max)) && (!r || true !== r.ignore_range))
              return NaN;
            let s = NaN, n = 1;
            if (void 0 === e.type || "logarithmic" !== e.type) {
              let i2 = Math.abs(e.max - e.min);
              i2 || (i2 = 1), n = Math.abs(t - Math.min(e.min, e.max)) / i2;
            } else if ("logarithmic" === e.type) {
              let i2 = e.base;
              isNaN(i2) && (i2 = 10);
              let r2 = Math.min(e.min, e.max);
              r2 <= 0 && (r2 = 1);
              let s2 = Math.max(e.min, e.max);
              s2 <= 0 && (s2 = 1);
              let h = Math.log(s2) / Math.log(i2);
              s2 = Math.pow(i2, h);
              let a = Math.log(r2) / Math.log(i2);
              r2 = Math.pow(i2, a);
              let o = Math.log(t) / Math.log(i2);
              n = Math.abs(o - a) / (h - a);
            }
            if ("logarithmic" === i.type) {
              let t2 = i.base;
              isNaN(t2) && (t2 = 10);
              let e2 = Math.log(i.max) / Math.log(t2), r2 = Math.log(i.min) / Math.log(t2);
              i.flip && (n = 1 - n);
              let h = Math.min(r2, e2) + n * Math.abs(e2 - r2);
              s = Math.pow(t2, h);
            } else
              s = Math.min(i.min, i.max) + n * Math.abs(i.max - i.min), i.flip && (s = Math.max(i.min, i.max) - s + i.min);
            return s;
          }
          axis(t, e, i) {
            if (i <= 1)
              return [e, t];
            (isNaN(i) || i < 2) && (i = 2);
            let r = 0;
            for (; Math.round(t) !== t && Math.round(e) !== e && r < 10; )
              t *= 10, e *= 10, r++;
            let s = (e - t) / i;
            for (; r < 10 && Math.round(s) !== s; )
              t *= 10, e *= 10, s *= 10, r++;
            let n, h = [1, 2, 5], a = 0;
            for (; ; ) {
              let t2 = a % h.length, e2 = Math.floor(a / h.length), i2 = Math.pow(10, e2) * h[t2];
              if (t2 = (a + 1) % h.length, e2 = Math.floor((a + 1) / h.length), n = Math.pow(10, e2) * h[t2], s >= i2 && s < n)
                break;
              a++;
            }
            let o = n, l = [], d = this.renderer._rnd(t, o, false), c = r <= 0 ? 1 : Math.pow(10, r);
            for (; d < e + o; )
              l.push(d / c), d += o;
            return l;
          }
        });
      }
    ),
    /***/
    6321: (
      /***/
      () => {
        !function() {
          const e = "16.0.0", t = [];
          let n = "Smart";
          if (window[n] && window[n].Version) {
            if (window[n].Version === e)
              return;
            if (window[n].Version !== e)
              n += e;
            else {
              let e2 = 2;
              for (; window[n]; )
                n += e2.toString(), e2++;
            }
          }
          const r = navigator.userAgent.indexOf("Edge") > -1 && navigator.appVersion.indexOf("Edge") > -1;
          document.elementsFromPoint || (document.elementsFromPoint = document.msElementsFromPoint);
          class o {
            static isBoolean(e2) {
              return "boolean" == typeof e2;
            }
            static isFunction(e2) {
              return !!(e2 && e2.constructor && e2.call && e2.apply);
            }
            static isArray(e2) {
              return Array.isArray(e2);
            }
            static isObject(e2) {
              return e2 && ("object" == typeof e2 || this.isFunction(e2)) || false;
            }
            static isDate(e2) {
              return e2 instanceof Date;
            }
            static isString(e2) {
              return "string" == typeof e2;
            }
            static isNumber(e2) {
              return "number" == typeof e2;
            }
            static getType(e2) {
              const t2 = this, n2 = ["Boolean", "Number", "String", "Function", "Array", "Date", "Object"].find((n3) => {
                if (t2["is" + n3](e2))
                  return n3;
              });
              return n2 ? n2.toLowerCase() : void 0;
            }
          }
          class i {
            static animate(e2, t2, r2, o2) {
              const i2 = e2;
              if (!i2 || i2 instanceof HTMLElement == 0)
                return;
              if (0 === i2.getElementsByClassName("smart-ripple").length) {
                const e3 = document.createElement("span");
                e3.classList.add("smart-ripple"), e3.setAttribute("role", "presentation");
                let t3 = true, r3 = null;
                if (window[n].EnableShadowDOM && i2.enableShadowDOM && true !== i2.isInShadowDOM) {
                  for (let e4 = 0; e4 < i2.shadowRoot.host.shadowRoot.children.length; e4++)
                    "link" !== i2.shadowRoot.host.shadowRoot.children[e4].tagName.toLowerCase() && (r3 = i2.shadowRoot.host.shadowRoot.children[e4]);
                  i2.shadowRoot.host.shadowRoot.querySelector(".smart-ripple") && (t3 = false);
                } else
                  r3 = i2.firstElementChild;
                t3 && (r3 && !r3.noRipple && r3.offsetHeight > 0 ? r3.appendChild(e3) : i2.appendChild(e3));
              }
              let s2 = null;
              if (s2 = window[n].EnableShadowDOM && i2.shadowRoot ? i2.shadowRoot.host.shadowRoot.querySelector(".smart-ripple") : i2.getElementsByClassName("smart-ripple")[0], !s2)
                return;
              s2.innerHTML = "", s2.classList.remove("smart-animate"), s2.style.height = s2.style.width = Math.max(i2.offsetHeight, i2.offsetWidth) + "px";
              const a2 = window.getComputedStyle(s2.parentElement), l2 = parseInt(a2.borderLeftWidth) || 0, d2 = parseInt(a2.borderTopWidth) || 0, c2 = i2.getBoundingClientRect(), u2 = t2 - (c2.left + window.pageXOffset) - s2.offsetWidth / 2 - l2, p2 = r2 - (c2.top + window.pageYOffset) - s2.offsetHeight / 2 - d2;
              s2.style.left = u2 + "px", s2.style.top = p2 + "px", s2.classList.add("smart-animate"), s2.addEventListener("animationend", function e3() {
                s2.parentElement && s2.parentElement.removeChild(s2), o2 && o2(), s2.removeEventListener("animationend", e3), s2.removeEventListener("animationcancel", e3);
              }), s2.addEventListener("animationcancel", function e3() {
                s2.parentElement && s2.parentElement.removeChild(s2), o2 && o2(), s2.removeEventListener("animationcancel", e3), s2.removeEventListener("animationend", e3);
              });
            }
          }
          class s {
            static easeInQuad(e2, t2, n2, r2) {
              return n2 * (e2 /= r2) * e2 + t2;
            }
            static easeOutQuad(e2, t2, n2, r2) {
              return -n2 * (e2 /= r2) * (e2 - 2) + t2;
            }
            static easeInOutQuad(e2, t2, n2, r2) {
              return (e2 /= r2 / 2) < 1 ? n2 / 2 * e2 * e2 + t2 : -n2 / 2 * (--e2 * (e2 - 2) - 1) + t2;
            }
            static easeInCubic(e2, t2, n2, r2) {
              return n2 * (e2 /= r2) * e2 * e2 + t2;
            }
            static easeOutCubic(e2, t2, n2, r2) {
              return n2 * ((e2 = e2 / r2 - 1) * e2 * e2 + 1) + t2;
            }
            static easeInOutCubic(e2, t2, n2, r2) {
              return (e2 /= r2 / 2) < 1 ? n2 / 2 * e2 * e2 * e2 + t2 : n2 / 2 * ((e2 -= 2) * e2 * e2 + 2) + t2;
            }
            static easeInQuart(e2, t2, n2, r2) {
              return n2 * (e2 /= r2) * e2 * e2 * e2 + t2;
            }
            static easeOutQuart(e2, t2, n2, r2) {
              return -n2 * ((e2 = e2 / r2 - 1) * e2 * e2 * e2 - 1) + t2;
            }
            static easeInOutQuart(e2, t2, n2, r2) {
              return (e2 /= r2 / 2) < 1 ? n2 / 2 * e2 * e2 * e2 * e2 + t2 : -n2 / 2 * ((e2 -= 2) * e2 * e2 * e2 - 2) + t2;
            }
            static easeInQuint(e2, t2, n2, r2) {
              return n2 * (e2 /= r2) * e2 * e2 * e2 * e2 + t2;
            }
            static easeOutQuint(e2, t2, n2, r2) {
              return n2 * ((e2 = e2 / r2 - 1) * e2 * e2 * e2 * e2 + 1) + t2;
            }
            static easeInOutQuint(e2, t2, n2, r2) {
              return (e2 /= r2 / 2) < 1 ? n2 / 2 * e2 * e2 * e2 * e2 * e2 + t2 : n2 / 2 * ((e2 -= 2) * e2 * e2 * e2 * e2 + 2) + t2;
            }
            static easeInSine(e2, t2, n2, r2) {
              return -n2 * Math.cos(e2 / r2 * (Math.PI / 2)) + n2 + t2;
            }
            static easeOutSine(e2, t2, n2, r2) {
              return n2 * Math.sin(e2 / r2 * (Math.PI / 2)) + t2;
            }
            static easeInOutSine(e2, t2, n2, r2) {
              return -n2 / 2 * (Math.cos(Math.PI * e2 / r2) - 1) + t2;
            }
            static easeInExpo(e2, t2, n2, r2) {
              return 0 === e2 ? t2 : n2 * Math.pow(2, 10 * (e2 / r2 - 1)) + t2;
            }
            static easeOutExpo(e2, t2, n2, r2) {
              return e2 === r2 ? t2 + n2 : n2 * (1 - Math.pow(2, -10 * e2 / r2)) + t2;
            }
            static easeInOutExpo(e2, t2, n2, r2) {
              return 0 === e2 ? t2 : e2 === r2 ? t2 + n2 : (e2 /= r2 / 2) < 1 ? n2 / 2 * Math.pow(2, 10 * (e2 - 1)) + t2 : n2 / 2 * (2 - Math.pow(2, -10 * --e2)) + t2;
            }
            static easeInCirc(e2, t2, n2, r2) {
              return -n2 * (Math.sqrt(1 - (e2 /= r2) * e2) - 1) + t2;
            }
            static easeOutCirc(e2, t2, n2, r2) {
              return n2 * Math.sqrt(1 - (e2 = e2 / r2 - 1) * e2) + t2;
            }
            static easeInOutCirc(e2, t2, n2, r2) {
              return (e2 /= r2 / 2) < 1 ? -n2 / 2 * (Math.sqrt(1 - e2 * e2) - 1) + t2 : n2 / 2 * (Math.sqrt(1 - (e2 -= 2) * e2) + 1) + t2;
            }
            static easeInElastic(e2, t2, n2, r2) {
              let o2 = 1.70158, i2 = 0, s2 = n2;
              return 0 === e2 ? t2 : 1 == (e2 /= r2) ? t2 + n2 : (i2 || (i2 = 0.3 * r2), s2 < Math.abs(n2) ? (s2 = n2, o2 = i2 / 4) : o2 = i2 / (2 * Math.PI) * Math.asin(n2 / s2), -s2 * Math.pow(2, 10 * (e2 -= 1)) * Math.sin((e2 * r2 - o2) * (2 * Math.PI) / i2) + t2);
            }
            static easeOutElastic(e2, t2, n2, r2) {
              let o2 = 1.70158, i2 = 0, s2 = n2;
              return 0 === e2 ? t2 : 1 == (e2 /= r2) ? t2 + n2 : (i2 || (i2 = 0.3 * r2), s2 < Math.abs(n2) ? (s2 = n2, o2 = i2 / 4) : o2 = i2 / (2 * Math.PI) * Math.asin(n2 / s2), s2 * Math.pow(2, -10 * e2) * Math.sin((e2 * r2 - o2) * (2 * Math.PI) / i2) + n2 + t2);
            }
            static easeInOutElastic(e2, t2, n2, r2) {
              let o2 = 1.70158, i2 = 0, s2 = n2;
              return 0 === e2 ? t2 : 2 == (e2 /= r2 / 2) ? t2 + n2 : (i2 || (i2 = r2 * (0.3 * 1.5)), s2 < Math.abs(n2) ? (s2 = n2, o2 = i2 / 4) : o2 = i2 / (2 * Math.PI) * Math.asin(n2 / s2), e2 < 1 ? s2 * Math.pow(2, 10 * (e2 -= 1)) * Math.sin((e2 * r2 - o2) * (2 * Math.PI) / i2) * -0.5 + t2 : s2 * Math.pow(2, -10 * (e2 -= 1)) * Math.sin((e2 * r2 - o2) * (2 * Math.PI) / i2) * 0.5 + n2 + t2);
            }
            static easeInBack(e2, t2, n2, r2, o2) {
              return void 0 === o2 && (o2 = 1.70158), n2 * (e2 /= r2) * e2 * ((o2 + 1) * e2 - o2) + t2;
            }
            static easeOutBack(e2, t2, n2, r2, o2) {
              return void 0 === o2 && (o2 = 1.70158), n2 * ((e2 = e2 / r2 - 1) * e2 * ((o2 + 1) * e2 + o2) + 1) + t2;
            }
            static easeInOutBack(e2, t2, n2, r2, o2) {
              return void 0 === o2 && (o2 = 1.70158), (e2 /= r2 / 2) < 1 ? n2 / 2 * (e2 * e2 * ((1 + (o2 *= 1.525)) * e2 - o2)) + t2 : n2 / 2 * ((e2 -= 2) * e2 * ((1 + (o2 *= 1.525)) * e2 + o2) + 2) + t2;
            }
            static easeInBounce(e2, t2, n2, r2) {
              return n2 - this.easeOutBounce(r2 - e2, 0, n2, r2) + t2;
            }
            static easeOutBounce(e2, t2, n2, r2) {
              return (e2 /= r2) < 1 / 2.75 ? n2 * (7.5625 * e2 * e2) + t2 : e2 < 2 / 2.75 ? n2 * (7.5625 * (e2 -= 1.5 / 2.75) * e2 + 0.75) + t2 : e2 < 2.5 / 2.75 ? n2 * (7.5625 * (e2 -= 2.25 / 2.75) * e2 + 0.9375) + t2 : n2 * (7.5625 * (e2 -= 2.625 / 2.75) * e2 + 0.984375) + t2;
            }
            static easeInOutBounce(e2, t2, n2, r2) {
              return e2 < r2 / 2 ? 0.5 * this.easeInBounce(2 * e2, 0, n2, r2) + t2 : 0.5 * this.easeOutBounce(2 * e2 - r2, 0, n2, r2) + 0.5 * n2 + t2;
            }
          }
          class a {
            static get isMobile() {
              const e2 = /(iphone|ipod|ipad|android|iemobile|blackberry|bada)/.test(window.navigator.userAgent.toLowerCase());
              return e2 || ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
            }
            static get Browser() {
              let e2;
              const t2 = function(t3) {
                let n3 = t3.indexOf(e2);
                if (-1 === n3)
                  return;
                const r2 = t3.indexOf("rv:");
                return "Trident" === e2 && -1 !== r2 ? parseFloat(t3.substring(r2 + 3)) : parseFloat(t3.substring(n3 + e2.length + 1));
              };
              let n2 = {};
              return n2[function() {
                const t3 = [{ string: navigator.userAgent, subString: "Edge", identity: "Edge" }, { string: navigator.userAgent, subString: "MSIE", identity: "IE" }, { string: navigator.userAgent, subString: "Trident", identity: "IE" }, { string: navigator.userAgent, subString: "Firefox", identity: "Firefox" }, { string: navigator.userAgent, subString: "Opera", identity: "Opera" }, { string: navigator.userAgent, subString: "OPR", identity: "Opera" }, { string: navigator.userAgent, subString: "Chrome", identity: "Chrome" }, { string: navigator.userAgent, subString: "Safari", identity: "Safari" }];
                for (let n3 = 0; n3 < t3.length; n3++) {
                  let r2 = t3[n3].string;
                  if (e2 = t3[n3].subString, -1 !== r2.indexOf(t3[n3].subString))
                    return t3[n3].identity;
                }
                return "Other";
              }()] = true, n2.version = t2(navigator.userAgent) || t2(navigator.appVersion) || "Unknown", n2;
            }
            static toCamelCase(e2) {
              return e2.replace(/-([a-z])/g, function(e3) {
                return e3[1].toUpperCase();
              });
            }
            static toDash(e2) {
              return e2.split(/(?=[A-Z])/).join("-").toLowerCase();
            }
            static unescapeHTML(e2) {
              return new DOMParser().parseFromString(e2, "text/html").documentElement.textContent;
            }
            static escapeHTML(e2) {
              const t2 = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;", "/": "&#x2F;", "`": "&#x60;", "=": "&#x3D;" };
              return String(e2).replace(/[&<>"'`=\/]/g, (e3) => t2[e3]);
            }
            static sanitizeHTML(e2) {
              if (e2 && (e2.indexOf("onclick") >= 0 || e2.indexOf("onload") >= 0 || e2.indexOf("onerror") >= 0))
                return this.escapeHTML(e2);
              const t2 = new RegExp("<s*(applet|audio|base|bgsound|embed|form|iframe|isindex|keygen|layout|link|meta|object|script|svg|style|template|video)[^>]*>(.*?)<s*/s*(applet|audio|base|bgsound|embed|form|iframe|isindex|keygen|layout|link|meta|object|script|svg|style|template|video)>", "ig");
              return String(e2).replace(t2, (e3) => this.escapeHTML(e3));
            }
            static createGUID() {
              function e2() {
                return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
              }
              return e2() + e2() + "-" + e2() + "-" + e2() + "-" + e2() + "-" + e2() + e2() + e2();
            }
            static getScriptLocation() {
              return "./" !== window[n].BaseUrl ? window[n].BaseUrl : function() {
                if (document.currentScript) {
                  let e3 = document.currentScript.src, t3 = e3.lastIndexOf("/");
                  return e3 = e3.substring(0, t3), e3;
                }
                const e2 = new Error();
                let t2 = "(", n2 = ")";
                if (Smart.Utilities.Core.Browser.Safari && (t2 = "@", n2 = "\n"), e2.fileName)
                  return e2.fileName.replace("/smart.element.js", "");
                let r2 = e2.stack.split(t2);
                return r2 = r2[1], r2 = r2.split(n2)[0], r2 = r2.split(":"), r2.splice(-2, 2), r2 = r2.join(":"), r2.replace("/smart.element.js", "");
              }();
            }
            static CSSVariablesSupport() {
              return window.CSS && window.CSS.supports && window.CSS.supports("(--fake-var: 0)");
            }
            static assign(e2, t2) {
              const n2 = (e3) => e3 && "object" == typeof e3 && !Array.isArray(e3) && null !== e3;
              let r2 = Object.assign({}, e2);
              return n2(e2) && n2(t2) && Object.keys(t2).forEach((o2) => {
                n2(t2[o2]) ? o2 in e2 ? r2[o2] = this.assign(e2[o2], t2[o2]) : Object.assign(r2, { [o2]: t2[o2] }) : Object.assign(r2, { [o2]: t2[o2] });
              }), r2;
            }
            static html(e2, t2) {
              const n2 = this;
              let r2 = "", o2 = e2.childNodes;
              if (!t2) {
                for (let e3, t3 = 0, i2 = o2.length; t3 < i2 && (e3 = o2[t3]); t3++) {
                  const t4 = ["strong"];
                  if (e3 instanceof HTMLElement || e3.tagName && t4.indexOf(e3.tagName.toLowerCase()) >= 0) {
                    const t5 = e3.tagName.toLowerCase(), o3 = e3.attributes;
                    let i3 = "<" + t5;
                    for (let e4, t6 = 0; e4 = o3[t6]; t6++)
                      i3 += " " + e4.name + '="' + e4.value.replace(/[&\u00A0"]/g, y.Core.escapeHTML) + '"';
                    i3 += ">", ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"][t5] && (r2 += i3), r2 = r2 + i3 + n2.html(e3) + "</" + t5 + ">";
                  } else {
                    if (8 === e3.nodeType)
                      continue;
                    r2 += e3.textContent.replace(/[&\u00A0<>]/g, y.Core.escapeHTML);
                  }
                }
                return r2;
              }
              {
                const n3 = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
                e2.innerHTML = t2.replace(n3, "<$1></$2>");
              }
            }
          }
          let l = [];
          class d {
            static watch(e2) {
              switch (e2.nodeName.toLowerCase()) {
                case "smart-grid":
                case "smart-kanban":
                case "smart-table":
                case "smart-pivot-table":
                case "smart-scheduler":
                case "smart-tabs":
                case "smart-card-view":
                case "smart-list-box":
                case "smart-combo-box":
                case "smart-drop-down-list":
                case "smart-calendar":
                case "smart-gauge":
                case "smart-numeric-text-box":
                case "smart-menu":
                case "smart-tree":
                  l.push(e2);
                  break;
                default:
                  return;
              }
              d.start();
            }
            static start() {
              d.isStarted || (d.isStarted = true, d.interval && clearInterval(d.interval), 0 === l.length || document.hidden ? d.isStarted = false : d.interval = setInterval(function() {
                d.observe();
              }, 100));
            }
            static stop() {
              d.isStarted = false, d.interval && clearInterval(d.interval);
            }
            static observeElement(e2) {
              const t2 = e2;
              if ("test" === window.Smart.Mode || document.hidden)
                return void (d.interval && clearInterval(d.interval));
              let n2 = e2._computedStyle || "resize" !== t2.hasStyleObserver ? document.defaultView.getComputedStyle(t2, null) : {}, r2 = true, o2 = "resize" !== t2.hasStyleObserver ? ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth", "display", "visibility", "font-size", "font-family", "font-style", "font-weight", "max-height", "min-height", "max-width", "min-width", "overflow", "overflow-x", "overflow-y"] : [];
              if (e2.styleProperties && (o2 = o2.concat(e2.styleProperties)), e2.observableStyleProperties && (o2 = e2.observableStyleProperties), !t2._styleInfo) {
                t2._styleInfo = [];
                for (let e3 = 0; e3 < o2.length; e3++) {
                  const r3 = o2[e3], i3 = r3.startsWith("--") ? n2.getPropertyValue(r3) : n2[r3];
                  t2._styleInfo[r3] = i3;
                }
                return;
              }
              if (e2.isHidden || "none" !== n2.display && (0 !== e2.offsetWidth && 0 !== e2.offsetHeight || (e2.isHidden = true)), e2.isHidden) {
                if (e2.visibilityChangedHandler(), e2.isHidden)
                  return;
                r2 = false;
              }
              let i2 = [];
              for (let e3 = 0; e3 < o2.length; e3++) {
                const r3 = o2[e3], s2 = r3.startsWith("--") ? n2.getPropertyValue(r3) : n2[r3];
                t2._styleInfo[r3] !== s2 && (i2[r3] = { oldValue: t2._styleInfo[r3], value: s2 }, i2.length++), t2._styleInfo[r3] = s2;
              }
              i2.length > 0 && (t2.$.fireEvent("styleChanged", { styleProperties: i2 }, { bubbles: false, cancelable: true }), i2.display && r2 && t2.$.fireEvent("resize", t2, { bubbles: false, cancelable: true }));
            }
            static observe() {
              for (let e2 = 0; e2 < l.length; e2++) {
                const t2 = l[e2];
                this.observeElement(t2);
              }
            }
            static unwatch(e2) {
              d.stop();
              const t2 = l.indexOf(e2);
              -1 !== t2 && l.splice(t2, 1), d.start();
            }
          }
          let c = [];
          const u = [], p = ["resize", "down", "up", "move", "tap", "taphold", "swipeleft", "swiperight", "swipetop", "swipebottom"];
          class h {
            constructor(e2) {
              const t2 = this;
              t2.target = e2, t2.$target = new f(e2), t2.$document = e2.$document ? e2.$document : new f(document), t2.id = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase();
              let n2 = { handlers: {}, boundEventTypes: [], listen: t2.listen.bind(t2), unlisten: t2.unlisten.bind(t2) };
              return t2.tapHoldDelay = 750, t2.swipeMin = 10, t2.swipeMax = 5e3, t2.swipeDelay = 1e3, t2.tapHoldDelay = 750, t2.inputEventProperties = ["clientX", "clientY", "pageX", "pageY", "screenX", "screenY"], p.forEach((e3) => {
                n2[e3] = (t3) => {
                  n2.handlers[e3] = t3;
                }, t2[e3] = (e4) => {
                  if (!n2.handlers[e4.type]) {
                    if (("mousemove" === e4.type || "pointermove" === e4.type || "touchmove" === e4.type) && n2.handlers.move) {
                      const r2 = t2.createEvent(e4, "move");
                      n2.handlers.move(r2);
                    }
                    return true;
                  }
                  return n2.handlers[e4.type](e4);
                };
              }), t2.listen(), t2.handlers = n2.handlers, n2;
            }
            listen(e2) {
              const t2 = this;
              if ("resize" === e2 && t2.target !== document && t2.target !== window && false !== t2.target.hasResizeObserver) {
                if (Smart.Utilities.Core.Browser.Firefox) {
                  if (!t2.target.resizeObserver) {
                    let e3, n2, r2, o2 = false, i2 = t2.target.offsetWidth, s2 = t2.target.offsetHeight;
                    const a2 = new ResizeObserver(() => {
                      if (!o2)
                        return void (o2 = true);
                      const a3 = new CustomEvent("resize", { bubbles: false, cancelable: true });
                      n2 = t2.target.offsetWidth, r2 = t2.target.offsetHeight, e3 = n2 !== i2 || r2 !== s2, t2.target.requiresLayout && (e3 = true), e3 && (t2.resize(a3), t2.target.requiresLayout = false);
                    });
                    a2.observe(t2.target), t2.target.resizeObserver = a2;
                  }
                } else if (!t2.target.resizeTrigger) {
                  const e3 = document.createElement("div");
                  e3.className = "smart-resize-trigger-container", e3.innerHTML = '<div class="smart-resize-trigger-container"><div class="smart-resize-trigger"></div></div><div class="smart-resize-trigger-container"><div class="smart-resize-trigger-shrink"></div></div>', e3.setAttribute("aria-hidden", true), window[n].EnableShadowDOM && t2.target.shadowRoot ? t2.target.shadowRoot.appendChild(e3) : t2.target.appendChild(e3), t2.target.resizeTrigger = e3;
                  const r2 = e3.childNodes[0], o2 = r2.childNodes[0], i2 = e3.childNodes[1], s2 = function() {
                    o2.style.width = "100000px", o2.style.height = "100000px", r2.scrollLeft = 1e5, r2.scrollTop = 1e5, i2.scrollLeft = 1e5, i2.scrollTop = 1e5;
                  };
                  let a2, l2, d2, c2, u2 = t2.target.offsetWidth, p2 = t2.target.offsetHeight;
                  if (0 === u2 || 0 === p2) {
                    const e4 = function() {
                      s2(), t2.target.removeEventListener("resize", e4);
                    };
                    t2.target.addEventListener("resize", e4), s2();
                  } else
                    s2();
                  t2.target.resizeHandler = function() {
                    l2 || (l2 = requestAnimationFrame(function() {
                      if (l2 = 0, d2 = t2.target.offsetWidth, c2 = t2.target.offsetHeight, a2 = d2 !== u2 || c2 !== p2, t2.target.requiresLayout && (a2 = true), !a2)
                        return;
                      u2 = d2, p2 = c2;
                      const e4 = new CustomEvent("resize", { bubbles: false, cancelable: true });
                      t2.resize(e4), t2.target.requiresLayout = false;
                    })), s2();
                  }, r2.addEventListener("scroll", t2.target.resizeHandler), i2.addEventListener("scroll", t2.target.resizeHandler);
                }
              }
              t2.isListening || (t2.isListening = true, t2.isPressed = false, t2.isReleased = false, t2.isInBounds = false, window.PointerEvent ? (t2.$target.listen("pointerdown.inputEvents" + t2.id, t2.pointerDown.bind(t2)), t2.$target.listen("pointerup.inputEvents" + t2.id, t2.pointerUp.bind(t2)), t2.$target.listen("pointermove.inputEvents" + t2.id, t2.pointerMove.bind(t2)), t2.$target.listen("pointercancel.inputEvents" + t2.id, t2.pointerCancel.bind(t2))) : ("ontouchstart" in window && (t2.$target.listen("touchmove.inputEvents" + t2.id, t2.touchMove.bind(t2)), t2.$target.listen("touchstart.inputEvents" + t2.id, t2.touchStart.bind(t2)), t2.$target.listen("touchend.inputEvents" + t2.id, t2.touchEnd.bind(t2)), t2.$target.listen("touchcancel.inputEvents" + t2.id, t2.touchCancel.bind(t2))), t2.$target.listen("mousedown.inputEvents" + t2.id, t2.mouseDown.bind(t2)), t2.$target.listen("mouseup.inputEvents" + t2.id, t2.mouseUp.bind(t2)), t2.$target.listen("mousemove.inputEvents" + t2.id, t2.mouseMove.bind(t2)), t2.$target.listen("mouseleave.inputEvents" + t2.id, t2.mouseLeave.bind(t2))), t2.target._handleDocumentUp || (t2.target._handleDocumentUp = t2.handleDocumentUp.bind(t2), t2.target._handleDocumentUpId = t2.id, t2.$document.listen("mouseup.inputEvents" + t2.target._handleDocumentUpId, t2.target._handleDocumentUp)));
            }
            unlisten(e2) {
              const t2 = this;
              if (t2.isListening = false, window.PointerEvent ? (t2.$target.unlisten("pointerdown.inputEvents" + t2.id), t2.$target.unlisten("pointerup.inputEvents" + t2.id), t2.$target.unlisten("pointermove.inputEvents" + t2.id), t2.$target.unlisten("pointercancel.inputEvents" + t2.id)) : ("ontouchstart" in window && (t2.$target.unlisten("touchstart.inputEvents" + t2.id), t2.$target.unlisten("touchmove.inputEvents" + t2.id), t2.$target.unlisten("touchend.inputEvents" + t2.id), t2.$target.unlisten("touchcancel.inputEvents" + t2.id)), t2.$target.unlisten("mousedown.inputEvents" + t2.id), t2.$target.unlisten("mouseup.inputEvents" + t2.id), t2.$target.unlisten("mousemove.inputEvents" + t2.id), t2.$target.unlisten("mouseleave.inputEvents" + t2.id)), t2.target._handleDocumentUp && (t2.$document.unlisten("mouseup.inputEvents" + t2.target._handleDocumentUpId, t2.target._handleDocumentUp), delete t2.target._handleDocumentUp, delete t2.target._handleDocumentUpId), "resize" === e2) {
                if (Smart.Utilities.Core.Browser.Firefox)
                  t2.target.resizeObserver && (t2.target.resizeObserver.unobserve(t2.target), delete t2.target.resizeObserver);
                else if (t2.target.resizeTrigger) {
                  const e3 = t2.target.resizeTrigger, n2 = e3.childNodes[0], r2 = e3.childNodes[1];
                  n2.removeEventListener("scroll", t2.target.resizeHandler), r2.removeEventListener("scroll", t2.target.resizeHandler), t2.target.resizeHandler = null, e3.parentNode.removeChild(e3), delete t2.target.resizeTrigger;
                }
              }
            }
            handleDocumentUp(e2) {
              const t2 = this;
              t2.isPressed = false, t2.isReleased = false, t2.resetSwipe(e2);
            }
            createEvent(e2, t2) {
              const n2 = this, r2 = e2.touches, o2 = e2.changedTouches, i2 = r2 && r2.length ? r2[0] : o2 && o2.length ? o2[0] : void 0, s2 = new CustomEvent(t2, { bubbles: true, cancelable: true, composed: void 0 !== n2.$target.element.getRootNode().host });
              if (s2.originalEvent = e2, i2) {
                for (let e3 = 0; e3 < n2.inputEventProperties.length; e3++) {
                  const t3 = n2.inputEventProperties[e3];
                  s2[t3] = i2[t3];
                }
                return s2;
              }
              for (let t3 in e2)
                t3 in s2 || (s2[t3] = e2[t3]);
              return s2;
            }
            fireTap(e2) {
              const t2 = this;
              if (clearTimeout(this.tapHoldTimeout), !this.tapHoldFired && this.isInBounds) {
                const n2 = t2.createEvent(e2, "tap");
                t2.tap(n2);
              }
            }
            initTap(e2) {
              const t2 = this;
              t2.isInBounds = true, t2.tapHoldFired = false, t2.tapHoldTimeout = setTimeout(function() {
                if (t2.isInBounds) {
                  t2.tapHoldFired = true;
                  const n2 = t2.createEvent(e2, "taphold");
                  t2.taphold(n2);
                }
              }, t2.tapHoldDelay);
            }
            pointerDown(e2) {
              return this.handleDown(e2);
            }
            mouseDown(e2) {
              const t2 = this;
              if (!(t2.isPressed || t2.touchStartTime && /* @__PURE__ */ new Date() - t2.touchStartTime < 500))
                return t2.handleDown(e2);
            }
            touchStart(e2) {
              const t2 = this;
              return t2.touchStartTime = /* @__PURE__ */ new Date(), t2.isTouchMoved = true, t2.handleDown(e2);
            }
            mouseUp(e2) {
              const t2 = this;
              if (!(t2.isReleased || t2.touchEndTime && /* @__PURE__ */ new Date() - t2.touchEndTime < 500))
                return t2.handleUp(e2);
            }
            handleDown(e2) {
              const t2 = this;
              t2.isReleased = false, t2.isPressed = true;
              const n2 = t2.createEvent(e2, "down");
              return (t2.handlers.tap || t2.handlers.taphold) && t2.initTap(n2), (t2.handlers.swipeleft || t2.handlers.swiperight || t2.handlers.swipetop || t2.handlers.swipebottom) && t2.initSwipe(n2), t2.down(n2);
            }
            handleUp(e2) {
              const t2 = this;
              t2.isReleased = true, t2.isPressed = false;
              const n2 = t2.createEvent(e2, "up"), r2 = t2.up(n2);
              return (t2.handlers.tap || t2.handlers.taphold) && t2.fireTap(n2), t2.resetSwipe(n2), r2;
            }
            handleMove(e2) {
              const t2 = this;
              let n2 = t2.move(e2);
              return t2.isPressed && (t2._maxSwipeVerticalDistance = Math.max(t2._maxSwipeVerticalDistance, Math.abs(t2._startY - e2.pageY)), t2._maxSwipeHorizontalDistance = Math.max(t2._maxSwipeHorizontalDistance, Math.abs(t2._startX - e2.pageX)), n2 = t2.handleSwipeEvents(e2)), n2;
            }
            touchEnd(e2) {
              return this.touchEndTime = /* @__PURE__ */ new Date(), this.handleUp(e2);
            }
            pointerUp(e2) {
              return this.handleUp(e2);
            }
            pointerCancel(e2) {
              this.pointerUp(e2);
            }
            touchCancel(e2) {
              this.touchEnd(e2);
            }
            mouseLeave() {
              this.isInBounds = false;
            }
            mouseMove(e2) {
              if (!this.isTouchMoved)
                return this.handleMove(e2);
            }
            pointerMove(e2) {
              return this.handleMove(e2);
            }
            touchMove(e2) {
              const t2 = this, n2 = e2.touches, r2 = e2.changedTouches, o2 = n2 && n2.length ? n2[0] : r2 && r2.length ? r2[0] : void 0;
              for (let n3 = 0; n3 < t2.inputEventProperties.length; n3++) {
                const r3 = t2.inputEventProperties[n3];
                void 0 === e2[r3] && (e2[r3] = o2[r3]);
              }
              return t2.isTouchMoved = true, t2.handleMove(e2);
            }
            handleSwipeEvents(e2) {
              const t2 = this;
              let n2 = true;
              return (t2.handlers.swipetop || t2.handlers.swipebottom) && (n2 = this.handleVerticalSwipeEvents(e2)), false === n2 || (t2.handlers.swipeleft || t2.handlers.swiperight) && (n2 = this.handleHorizontalSwipeEvents(e2)), n2;
            }
            handleVerticalSwipeEvents(e2) {
              let t2, n2;
              return t2 = e2.pageY, n2 = t2 - this._startY, this.swiped(e2, n2, "vertical");
            }
            handleHorizontalSwipeEvents(e2) {
              let t2, n2;
              return t2 = e2.pageX, n2 = t2 - this._startX, this.swiped(e2, n2, "horizontal");
            }
            swiped(e2, t2, n2) {
              const r2 = this;
              if (n2 = n2 || 0, Math.abs(t2) >= r2.swipeMin && !r2._swipeEvent && !r2._swipeLocked) {
                let o2 = t2 < 0 ? "swipeleft" : "swiperight";
                if ("horizontal" === n2 ? r2._swipeEvent = r2.createEvent(e2, o2) : (o2 = t2 < 0 ? "swipetop" : "swipebottom", r2._swipeEvent = r2.createEvent(e2, t2 < 0 ? "swipetop" : "swipebottom")), r2[o2] && (r2[o2](this._swipeEvent), Math.abs(t2) <= this.swipeMax))
                  return e2.stopImmediatePropagation(), false;
              }
              return true;
            }
            resetSwipe() {
              this._swipeEvent = null, clearTimeout(this._swipeTimeout);
            }
            initSwipe(e2) {
              const t2 = this;
              t2._maxSwipeVerticalDistance = 0, t2._maxSwipeHorizontalDistance = 0, t2._startX = e2.pageX, t2._startY = e2.pageY, t2._swipeLocked = false, t2._swipeEvent = null, t2._swipeTimeout = setTimeout(function() {
                t2._swipeLocked = true;
              }, t2.swipeDelay);
            }
          }
          class m {
            get scrollWidth() {
              const e2 = this;
              return e2.horizontalScrollBar ? e2.horizontalScrollBar.max : -1;
            }
            set scrollWidth(e2) {
              const t2 = this;
              e2 < 0 && (e2 = 0), t2.horizontalScrollBar && (t2.horizontalScrollBar.max = e2);
            }
            get scrollHeight() {
              const e2 = this;
              return e2.verticalScrollBar ? e2.verticalScrollBar.max : -1;
            }
            set scrollHeight(e2) {
              const t2 = this;
              e2 < 0 && (e2 = 0), t2.verticalScrollBar && (t2.verticalScrollBar.max = e2);
            }
            get scrollLeft() {
              const e2 = this;
              return e2.horizontalScrollBar ? e2.horizontalScrollBar.value : -1;
            }
            set scrollLeft(e2) {
              const t2 = this;
              e2 < 0 && (e2 = 0), t2.horizontalScrollBar && (t2.horizontalScrollBar.value = e2);
            }
            get scrollTop() {
              const e2 = this;
              return e2.verticalScrollBar ? e2.verticalScrollBar.value : -1;
            }
            set scrollTop(e2) {
              const t2 = this;
              e2 < 0 && (e2 = 0), t2.verticalScrollBar && (t2.verticalScrollBar.value = e2);
            }
            get vScrollBar() {
              return this.verticalScrollBar;
            }
            get hScrollBar() {
              return this.horizontalScrollBar;
            }
            constructor(e2, t2, n2) {
              const r2 = this;
              r2.container = e2, r2.horizontalScrollBar = t2, r2.verticalScrollBar = n2, r2.disableSwipeScroll = false, r2.listen();
            }
            listen() {
              const e2 = this, t2 = a.isMobile, n2 = e2.horizontalScrollBar, r2 = e2.verticalScrollBar;
              let o2, i2, s2, l2, d2, c2, u2, p2;
              e2.inputEvents = new h(e2.container);
              const m2 = function(e3) {
                return { amplitude: 0, delta: 0, initialValue: 0, min: 0, max: e3.max, previousValue: 0, pointerPosition: 0, targetValue: 0, scrollBar: e3, value: 0, velocity: 0 };
              }, f2 = m2(n2), g2 = m2(r2), w2 = function() {
                const t3 = e2.container.touchVelocityCoefficient || 50;
                c2 = Date.now(), u2 = c2 - l2, l2 = c2;
                const n3 = function(e3) {
                  e3.delta = e3.value - e3.previousValue, e3.previousValue = e3.value;
                  let n4 = t3 * e3.delta / (1 + u2);
                  e3.velocity = 0.8 * n4 + 0.2 * e3.velocity;
                };
                n3(g2), n3(f2);
              }, b2 = function(e3) {
                return p2.value = e3 > p2.max ? p2.max : e3 < p2.min ? p2.min : e3, p2.scrollBar.value = p2.value, e3 > p2.max ? "max" : e3 < p2.min ? "min" : "value";
              };
              function v2() {
                let t3, n3;
                p2.amplitude && (e2.container.$.fireEvent("kineticScroll"), t3 = Date.now() - l2, n3 = -p2.amplitude * Math.exp(-t3 / 500), n3 > 5 || n3 < -5 ? (b2(p2.targetValue + n3), cancelAnimationFrame(i2), i2 = 0, i2 = requestAnimationFrame(v2)) : b2(p2.targetValue));
              }
              let _2;
              e2.inputEvents.down(function(n3) {
                if (!t2)
                  return;
                const r3 = n3.originalEvent.target, i3 = r3 && r3.closest ? r3.closest("smart-scroll-bar") : void 0;
                if (i3 === e2.horizontalScrollBar || i3 === e2.verticalScrollBar)
                  return;
                s2 = true, o2 = false;
                const a2 = function(e3, t3) {
                  e3.amplitude = 0, e3.pointerPosition = t3, e3.previousValue = e3.value, e3.value = e3.scrollBar.value, e3.initialValue = e3.value, e3.max = e3.scrollBar.max;
                };
                a2(g2, n3.clientY), a2(f2, n3.clientX), l2 = Date.now(), clearInterval(d2), d2 = setInterval(w2, 500);
              }), e2.inputEvents.up(function() {
                if (!s2)
                  return true;
                if (clearInterval(d2), e2.disableSwipeScroll)
                  return void (s2 = false);
                const t3 = function(e3) {
                  p2 = e3, e3.amplitude = 0.8 * e3.velocity, e3.targetValue = Math.round(e3.value + e3.amplitude), l2 = Date.now(), cancelAnimationFrame(i2), i2 = requestAnimationFrame(v2), e3.velocity = 0;
                };
                g2.velocity > 10 || g2.velocity < -10 ? t3(g2) : (f2.velocity > 10 || f2.velocity < -10) && t3(f2), s2 = false;
              }), e2.inputEvents.move(function(t3) {
                if (!s2)
                  return true;
                if (e2.disableSwipeScroll)
                  return;
                if (o2 && (t3.originalEvent.preventDefault(), t3.originalEvent.stopPropagation()), f2.visible = e2.scrollWidth > 0, g2.visible = e2.scrollHeight > 0, !s2 || !f2.visible && !g2.visible)
                  return;
                const n3 = e2.container.touchScrollRatio, r3 = e2.container;
                let i3, a2;
                n3 && ("number" == typeof n3 ? (i3 = -n3, a2 = -n3) : "function" == typeof n3 && (i3 = n3(g2.max, r3.offsetHeight), a2 = n3(f2.max, r3.offsetWidth))), g2.ratio = i3 || -g2.max / r3.offsetHeight, g2.delta = (t3.clientY - g2.pointerPosition) * g2.ratio, f2.ratio = a2 || -f2.max / r3.offsetWidth, f2.delta = (t3.clientX - f2.pointerPosition) * f2.ratio;
                let l3 = "value";
                const d3 = function(t4, n4, r4) {
                  return t4.delta > 5 || t4.delta < -5 ? (p2 = t4, l3 = t4.initialValue + t4.delta > p2.max ? "max" : t4.initialValue + t4.delta < p2.min ? "min" : "value", "min" === l3 && 0 === t4.initialValue || "max" === l3 && t4.initialValue === t4.max || !t4.visible || (e2.container.$.fireEvent("kineticScroll"), b2(t4.initialValue + t4.delta), w2(), r4.originalEvent.preventDefault(), r4.originalEvent.stopPropagation(), o2 = true, false)) : null;
                };
                let c3 = d3(g2, t3.clientY, t3);
                if (null !== c3)
                  return c3;
                {
                  let e3 = d3(f2, t3.clientX, t3);
                  if (null !== e3)
                    return e3;
                }
              }), e2.scrollTo = function(t3, n3) {
                const r3 = false === n3 ? f2 : g2;
                let o3 = false;
                l2 || (l2 = Date.now()), _2 || (_2 = Date.now()), Math.abs(Date.now() - _2) > 375 ? l2 = Date.now() : o3 = true, _2 = Date.now(), r3.value = r3.scrollBar.value, r3.delta = t3 - r3.value, r3.max = r3.scrollBar.max, t3 <= r3.min && (t3 = r3.min), t3 >= r3.max && (t3 = r3.max), r3.targetValue = t3;
                const s3 = t3;
                let a2 = r3.value;
                r3.velocity = 100 * r3.delta / (1 + r3.max), r3.from = a2;
                const d3 = function(e3) {
                  return r3.value = e3 > r3.max ? r3.max : e3 < r3.min ? r3.min : e3, r3.scrollBar.value = r3.value, e3 > r3.max ? "max" : e3 < r3.min ? "min" : "value";
                }, c3 = function() {
                  let n4, u3 = Date.now() - _2, p3 = Math.min(1e3, Date.now() - l2), h2 = r3.velocity * Math.exp(p3 / 175);
                  if (o3)
                    (h2 < 0 && r3.value <= t3 || h2 > 0 && r3.value >= t3) && (h2 = 0), (r3.value + h2 <= r3.min || r3.value + h2 >= r3.max) && (h2 = 0), h2 > 0.5 || h2 < -0.5 ? (d3(r3.value + h2), cancelAnimationFrame(i2), i2 = 0, i2 = requestAnimationFrame(c3)) : d3(r3.targetValue);
                  else {
                    if (u3 >= 175)
                      return cancelAnimationFrame(i2), e2.container.$.fireEvent("kineticScroll"), void (i2 = 0);
                    n4 = y.Animation.Easings.easeInSine(u3, a2, s3 - a2, 175), d3(n4), cancelAnimationFrame(i2), i2 = 0, i2 = requestAnimationFrame(c3);
                  }
                };
                cancelAnimationFrame(i2), i2 = requestAnimationFrame(c3);
              }, e2.inputEvents.listen();
            }
            unlisten() {
              const e2 = this;
              e2.inputEvents && e2.inputEvents.unlisten(), delete e2.inputEvents;
            }
          }
          class f {
            constructor(e2) {
              this.events = {}, this.handlers = {}, this.element = e2;
            }
            hasClass(e2) {
              const t2 = this, n2 = e2.split(" ");
              for (let e3 = 0; e3 < n2.length; e3++)
                if (!t2.element.classList.contains(n2[e3]))
                  return false;
              return true;
            }
            addClass(e2) {
              const t2 = this;
              if (t2.hasClass(e2))
                return;
              const n2 = e2.split(" ");
              for (let e3 = 0; e3 < n2.length; e3++)
                t2.element.classList.add(n2[e3]);
              t2.isNativeElement || d.observeElement(t2.element);
            }
            removeClass(e2) {
              const t2 = this;
              if (0 === arguments.length)
                return void t2.element.removeAttribute("class");
              const n2 = e2.split(" ");
              for (let e3 = 0; e3 < n2.length; e3++)
                t2.element.classList.remove(n2[e3]);
              "" === t2.element.className && t2.element.removeAttribute("class"), t2.isNativeElement || d.observeElement(t2.element);
            }
            get isCustomElement() {
              const e2 = this;
              return !!e2.element.tagName.startsWith(n) || e2.element instanceof window[n].BaseElement == 1 || "DIV" !== e2.element.tagName && "SPAN" !== e2.element.tagName && "BUTTON" !== e2.element.tagName && "INPUT" !== e2.element.tagName && "UL" !== e2.element.tagName && "LI" !== e2.element.tagName && document.createElement(e2.element.nodeName) instanceof window[n].BaseElement == 1;
            }
            get isNativeElement() {
              return !this.isCustomElement;
            }
            dispatch(e2) {
              const t2 = this, n2 = t2.events[e2.type];
              let r2 = false;
              if (n2.length > 1)
                for (let e3 = 0; e3 < n2.length; e3++) {
                  const t3 = n2[e3];
                  if (t3.namespace && t3.namespace.indexOf("_") >= 0) {
                    r2 = true;
                    break;
                  }
                }
              r2 && n2.sort(function(e3, t3) {
                let n3 = e3.namespace, r3 = t3.namespace;
                return n3 = -1 === n3.indexOf("_") ? 0 : parseInt(n3.substring(n3.indexOf("_") + 1)), r3 = -1 === r3.indexOf("_") ? 0 : parseInt(r3.substring(r3.indexOf("_") + 1)), n3 < r3 ? -1 : n3 > r3 ? 1 : 0;
              });
              for (let r3 = 0; r3 < n2.length; r3++) {
                const o2 = n2[r3];
                if (e2.namespace = o2.namespace, e2.context = o2.context, e2.defaultPrevented)
                  break;
                const i2 = o2.handler.apply(t2.element, [e2]);
                if (void 0 !== i2 && (e2.result = i2, false === i2)) {
                  e2.preventDefault(), e2.stopPropagation();
                  break;
                }
              }
              return e2.result;
            }
            fireEvent(e2, t2, r2) {
              const o2 = this;
              r2 || (r2 = { bubbles: true, cancelable: true, composed: null !== o2.element.getRootNode().host }), r2.detail = t2 || {};
              const i2 = new CustomEvent(e2, r2);
              if (i2.originalStopPropagation = i2.stopPropagation, i2.stopPropagation = function() {
                return i2.isPropagationStopped = true, i2.originalStopPropagation();
              }, o2.dispatchEvent(i2), window[n].isVue) {
                const t3 = y.Core.toDash(e2);
                if (t3 !== e2) {
                  const e3 = new CustomEvent(t3, r2);
                  e3.originalStopPropagation = i2.stopPropagation, e3.stopPropagation = function() {
                    return e3.isPropagationStopped = true, e3.originalStopPropagation();
                  }, o2.dispatchEvent(e3);
                }
              }
              return i2;
            }
            get isPassiveSupported() {
              const e2 = this;
              if (void 0 !== e2.supportsPassive)
                return e2.supportsPassive;
              e2.supportsPassive = false;
              try {
                let t2 = Object.defineProperty({}, "passive", { get: function() {
                  e2.supportsPassive = true;
                } });
                window.addEventListener("testPassive", null, t2), window.removeEventListener("testPassive", null, t2);
              } catch (e3) {
              }
              return e2.supportsPassive;
            }
            dispatchEvent(e2) {
              const t2 = this, n2 = e2.type, r2 = t2.element.context, o2 = n2.substring(0, 1).toUpperCase() + n2.substring(1);
              t2.element.context = document, t2.element["on" + o2] ? t2.element["on" + o2](e2) : t2.element["on" + n2.toLowerCase()] ? t2.element["on" + n2.toLowerCase()](e2) : t2.element.dispatchEvent(e2), t2.element.context = r2;
            }
            listen(e2, t2) {
              const n2 = this, r2 = e2.split("."), o2 = r2.slice(1).join("."), i2 = r2[0];
              n2.events[i2] || (n2.events[i2] = []);
              const s2 = { type: i2, handler: t2, context: n2.element, namespace: o2 };
              p.indexOf(i2) >= 0 && (n2.inputEvents || (n2.inputEvents = new h(n2.element)), n2.inputEvents[i2](function(e3) {
                n2.dispatchEvent(e3);
              }), n2.inputEvents.boundEventTypes.push(i2), n2.inputEvents.listen(i2)), 0 === n2.events[i2].length && (n2.handlers[i2] = n2.dispatch.bind(n2), "wheel" === i2 ? n2.element.addEventListener("wheel", n2.handlers[i2], !!n2.isPassiveSupported && { passive: false }) : "touchmove" === i2 || "touchstart" === i2 || "touchend" === i2 ? n2.element.addEventListener(i2, n2.handlers[i2], !!n2.isPassiveSupported && { passive: false }) : n2.element.addEventListener(i2, n2.handlers[i2], false)), n2.events[i2].push(s2);
            }
            unlisten(e2) {
              const t2 = this, n2 = e2.split("."), r2 = n2.slice(1).join("."), o2 = n2[0];
              let i2 = t2.events[o2];
              if (t2.inputEvents && t2.inputEvents.boundEventTypes.indexOf(o2) >= 0 && (t2.inputEvents.boundEventTypes.splice(t2.inputEvents.boundEventTypes.indexOf(o2), 1), 0 === t2.inputEvents.boundEventTypes.length && t2.inputEvents.unlisten(o2)), i2) {
                for (let e3 = 0; e3 < i2.length; e3++) {
                  if ("" !== r2) {
                    let e4 = i2.findIndex((e5) => e5.namespace === r2);
                    i2.splice(e4, 1);
                    break;
                  }
                  i2 = [];
                }
                0 === i2.length && (t2.element.removeEventListener(o2, t2.handlers[o2]), t2.events[o2] = [], delete t2.handlers[o2]);
              }
            }
            getAttributeValue(e2, t2) {
              const n2 = this, r2 = n2.element.getAttribute(e2);
              if (n2.isNativeElement)
                return n2.deserialize(r2, t2);
              const o2 = n2.element.propertyByAttributeName[e2];
              return void 0 === o2.deserialize ? n2.deserialize(r2, t2, o2.nullable) : n2.element[o2.deserialize](r2);
            }
            setAttributeValue(e2, t2, n2) {
              const r2 = this;
              let o2, i2 = false;
              if (r2.isNativeElement) {
                if (o2 = r2.serialize(t2, n2), "boolean" === n2 && ["checked", "selected", "async", "autofocus", "autoplay", "controls", "defer", "disabled", "hidden", "ismap", "loop", "multiple", "open", "readonly", "required", "scoped"].indexOf(e2) >= 0)
                  return void (t2 ? r2.element.setAttribute(e2, "") : r2.element.removeAttribute(e2));
              } else {
                const s2 = r2.element.propertyByAttributeName[e2];
                i2 = !s2 || s2.nullable, o2 = s2 && s2.serialize ? r2.element[s2.serialize](t2) : r2.serialize(t2, n2, i2);
              }
              "array" !== n2 && "object" !== n2 || "[]" !== o2 && "{}" !== o2 ? void 0 === o2 ? (r2.element.removeAttribute(e2), r2.element.shadowRoot && r2.element.$.root && r2.element.$.root.removeAttribute(e2)) : (r2.element.setAttribute(e2, o2), r2.element.shadowRoot && r2.element.$.root && r2.element.$.root.setAttribute(e2, o2)) : r2.element.removeAttribute(e2);
            }
            serialize(e2, t2, n2) {
              if (void 0 === t2 && (t2 = y.Types.getType(e2)), void 0 !== e2 && (n2 || null !== e2)) {
                if (n2 && null === e2)
                  return "null";
                if ("string" === t2)
                  return e2;
                if ("boolean" === t2 || "bool" === t2) {
                  if (true === e2 || "true" === e2 || 1 === e2 || "1" === e2)
                    return "";
                  if (false === e2 || "false" === e2 || 0 === e2 || "0" === e2)
                    return;
                }
                return "array" === t2 ? JSON.stringify(e2) : ["string", "number", "int", "integer", "float", "date", "any", "function"].indexOf(t2) >= 0 ? e2.toString() : "object" === t2 ? JSON.stringify(e2) : void 0;
              }
            }
            deserialize(e2, t2, n2) {
              const r2 = "null" === e2;
              if (void 0 !== e2 && (!r2 || n2)) {
                if (r2 && n2)
                  return null;
                if ("boolean" === t2 || "bool" === t2)
                  return null !== e2;
                if ("number" === t2 || "float" === t2)
                  return "NaN" === e2 ? NaN : "Infinity" === e2 ? 1 / 0 : "-Infinity" === e2 ? -1 / 0 : parseFloat(e2);
                if ("int" === t2 || "integer" === t2)
                  return "NaN" === e2 ? NaN : "Infinity" === e2 ? 1 / 0 : "-Infinity" === e2 ? -1 / 0 : parseInt(e2);
                if ("string" === t2)
                  return e2;
                if ("any" === t2)
                  return e2;
                if ("date" === t2)
                  return new Date(e2);
                if ("function" === t2) {
                  if ("function" == typeof window[e2])
                    return window[e2];
                } else if ("array" === t2 || "object" === t2)
                  try {
                    const t3 = JSON.parse(e2);
                    if (t3)
                      return t3;
                  } catch (n3) {
                    if (window[e2] && "object" == typeof window[e2])
                      return window[e2];
                    if ("object" === t2 && e2.indexOf("{") >= 0) {
                      let t3 = (e2 = e2.replace(/{/gi, "").replace(/}/gi, "").replace("[", "").replace("]", "").replace(/'/gi, "").replace(/"/gi, "").trim()).trim().split(","), n4 = {};
                      for (let e3 = 0; e3 < t3.length; e3++) {
                        const r3 = t3[e3].split(":")[0].trim(), o2 = t3[e3].split(":")[1].trim();
                        n4[r3] = o2;
                      }
                      return n4;
                    }
                    if ("array" === t2 && e2.indexOf("[") >= 0) {
                      if (e2.indexOf("{") >= 0) {
                        let t3 = e2.replace(/{/gi, "").replace("[", "").replace("]", "").replace(/'/gi, "").replace(/"/gi, "").trim();
                        t3 = t3.split("},");
                        for (let e3 = 0; e3 < t3.length; e3++) {
                          let n4 = {}, r3 = t3[e3].trim().split(",");
                          for (let e4 = 0; e4 < r3.length; e4++) {
                            const t4 = r3[e4].split(":")[0].trim(), o2 = r3[e4].split(":")[1].trim();
                            n4[t4] = o2;
                          }
                          t3[e3] = n4;
                        }
                        return t3;
                      }
                      return e2.replace("[", "").replace("]", "").replace(/'/gi, "").replace(/"/gi, "").trim().split(",");
                    }
                  }
              }
            }
          }
          class g {
            static get Ripple() {
              return i;
            }
            static get Easings() {
              return s;
            }
          }
          class y {
            static get Types() {
              return o;
            }
            static get Core() {
              return a;
            }
            static get Animation() {
              return g;
            }
            static get Scroll() {
              return m;
            }
            static get InputEvents() {
              return h;
            }
            static Extend(e2) {
              return new f(e2);
            }
            static Assign(e2, t2) {
              if (e2.indexOf(".") >= 0) {
                const n2 = e2.split(".");
                return y[n2[0]] || (y[n2[0]] = {}), void (y[n2[0]][n2[1]] = t2);
              }
              y[e2] = t2;
            }
          }
          const w = y.Extend(document);
          let b = null;
          document.addEventListener("click", () => {
            d.start(), b && clearTimeout(b), b = setTimeout(() => {
              d.stop();
            }, 1e4);
          }), document.addEventListener("mouseenter", () => {
            d.start();
          }), document.addEventListener("mouseleave", () => {
            d.stop();
          });
          class v {
          }
          v.cache = {};
          class _ extends HTMLElement {
            static get properties() {
              return { animation: { value: "advanced", type: "string", allowedValues: ["none", "simple", "advanced"] }, unfocusable: { value: false, type: "boolean" }, disabled: { value: false, type: "boolean" }, dataContext: { value: null, reflectToAttribute: false, type: "any" }, debugMode: { value: true, type: "boolean", reflectToAttribute: false }, locale: { value: "en", type: "string", reflectToAttribute: false }, localizeFormatFunction: { value: null, type: "any", reflectToAttribute: false }, messages: { value: { en: { propertyUnknownName: "Invalid property name: '{{name}}'!", propertyUnknownType: "'{{name}}' property is with undefined 'type' member!", propertyInvalidValue: "Invalid '{{name}}' property value! Actual value: '{{actualValue}}', Expected value: '{{value}}'!", propertyInvalidValueType: "Invalid '{{name}}' property value type! Actual type: '{{actualType}}', Expected type: '{{type}}'!", methodInvalidValueType: "Invalid '{{name}}' method argument value type! Actual type: '{{actualType}}', Expected type: '{{type}}' for argument with index: '{{argumentIndex}}'!", methodInvalidArgumentsCount: "Invalid '{{name}}' method arguments count! Actual arguments count: '{{actualArgumentsCount}}', Expected at least: '{{argumentsCount}}' argument(s)!", methodInvalidReturnType: "Invalid '{{name}}' method return type! Actual type: '{{actualType}}', Expected type: '{{type}}'!", elementNotInDOM: "Element does not exist in DOM! Please, add the element to the DOM, before invoking a method.", moduleUndefined: "Module is undefined.", missingReference: "{{elementType}}: Missing reference to '{{files}}'.", htmlTemplateNotSuported: "{{elementType}}: Web Browser doesn't support HTMLTemplate elements.", invalidTemplate: "{{elementType}}: '{{property}}' property accepts a string that must match the id of an HTMLTemplate element from the DOM." } }, reflectToAttribute: false, inherit: true, type: "object" }, props: { value: null, reflectToAttribute: false, isHierarchicalProperty: true, type: "any" }, readonly: { value: false, type: "boolean" }, renderMode: { value: "auto", type: "string", reflectToAttribute: false, allowedValues: ["auto", "manual"] }, rightToLeft: { value: false, type: "boolean" }, rethrowError: { value: true, type: "boolean", reflectToAttribute: false }, theme: { value: window[n].Theme, type: "string" }, visibility: { value: "visible", allowedValues: ["visible", "collapsed", "hidden"], type: "string" }, wait: { value: false, type: "boolean" } };
            }
            getBindings(e2, t2) {
              const n2 = this;
              let r2 = 0, o2 = {}, i2 = ((e3) => {
                if (e3 instanceof HTMLElement)
                  return n2.parseAttributes(e3);
                {
                  let t3 = n2.parseProperty(e3.data ? e3.data.trim() : null, "textContent", e3);
                  if (t3)
                    return n2 && e3.parentNode === n2.$.content && (t3.value = "" !== n2.$.html ? n2.$.html : void 0, n2.innerHTML = ""), { textContent: t3 };
                }
              })(e2);
              i2 && (o2.data = i2), t2 || (o2.mapping = [], t2 = o2), e2.getAttribute && (o2.nodeId = e2.getAttribute("smart-id"), t2 && i2 && (t2.mapping[o2.nodeId] = i2)), o2.node = e2, e2.firstChild && (o2.children = {});
              for (let i3 = e2.firstChild; i3; i3 = i3.nextSibling)
                o2.children[r2++] = n2.getBindings(i3, t2);
              return o2;
            }
            _addRemovePropertyBinding(e2, t2, n2, r2, o2) {
              if (!e2 || !t2 || !n2)
                return;
              const i2 = this, s2 = i2.bindings, a2 = n2.getAttribute("smart-id"), l2 = e2.indexOf("{{") >= 0;
              let d2 = false;
              (e2 = e2.replace("{{", "").replace("}}", "").replace("[[", "").replace("]]", "")).indexOf("!") >= 0 && (e2 = e2.replace("!", ""), d2 = true);
              const c2 = i2._properties[e2], u2 = { name: e2, reflectToAttribute: c2.reflectToAttribute, twoWay: l2, type: c2.type, not: d2 };
              if (o2 && !r2) {
                const n3 = {}, r3 = { name: e2, targetPropertyName: t2, reflectToAttribute: c2.reflectToAttribute, twoWay: l2, type: c2.type, not: d2 };
                n3[e2] = r3, s2.mapping[a2] = n3;
              }
              const p2 = function(e3) {
                for (let o3 in e3) {
                  const s3 = e3[o3];
                  if (s3.nodeId === a2) {
                    s3.data || (s3.data = {}), r2 ? (s3.data[t2] = null, delete s3.data[t2]) : s3.data[t2] = u2;
                    break;
                  }
                  if (s3.children)
                    p2(s3.children);
                  else if (s3.node && s3.node.children && s3.node === n2.parentElement) {
                    const e4 = s3.node;
                    if (!e4.firstChild)
                      continue;
                    s3.children = {};
                    let t3 = 0;
                    for (let n3 = e4.firstChild; n3; n3 = n3.nextSibling)
                      s3.children[t3++] = i2.getBindings(n3);
                    p2(s3.children);
                  }
                }
              };
              p2(s2.children), r2 ? delete i2.boundProperties[e2] : i2.boundProperties[e2] = true, i2.updateBoundNodes(e2);
            }
            addPropertyBinding(e2, t2, n2, r2) {
              this._addRemovePropertyBinding(e2, t2, n2, false, r2);
            }
            removePropertyBinding(e2, t2, n2, r2) {
              this._addRemovePropertyBinding(e2, t2, n2, true, r2);
            }
            parseAttributes(e2) {
              const t2 = this;
              let n2;
              for (let r2 = 0; r2 < e2.attributes.length; r2++) {
                const o2 = e2.attributes[r2], i2 = o2.name, s2 = o2.value;
                v.cache["toCamelCase" + i2] || (v.cache["toCamelCase" + i2] = y.Core.toCamelCase(i2));
                const a2 = v.cache["toCamelCase" + i2];
                if (i2.indexOf("(") >= 0) {
                  let r3 = i2.substring(1, i2.length - 1);
                  if (t2 && !t2.dataContext) {
                    t2.templateListeners[e2.getAttribute("smart-id") + "." + r3] = s2, e2.removeAttribute(i2);
                    continue;
                  }
                  {
                    n2 || (n2 = {});
                    const e3 = s2.substring(0, s2.indexOf("("));
                    n2[a2] = { isEvent: true, name: r3, value: e3 };
                    continue;
                  }
                }
                let l2 = t2.parseProperty(s2, i2, e2);
                l2 && (n2 || (n2 = {}), n2[a2] = l2);
              }
              return n2;
            }
            parseProperty(e2, t2) {
              if (!e2 || !e2.length)
                return;
              const n2 = this;
              let r2, o2 = e2.length, i2 = 0, s2 = 0, a2 = 0, l2 = true;
              for (; s2 < o2; ) {
                i2 = e2.indexOf("{{", s2);
                let t3 = e2.indexOf("[[", s2), n3 = "}}";
                if (t3 >= 0 && (i2 < 0 || t3 < i2) && (i2 = t3, l2 = false, n3 = "]]"), a2 = i2 < 0 ? -1 : e2.indexOf(n3, i2 + 2), a2 < 0)
                  return;
                r2 = r2 || {};
                let o3 = e2.slice(i2 + 2, a2).trim();
                r2.name = o3, s2 = a2 + 2;
              }
              const d2 = r2.name, c2 = n2 ? n2._properties[d2] : null;
              return r2.twoWay = l2, r2.ready = false, n2 && (d2.indexOf("::") >= 0 ? n2.boundProperties[d2.substring(0, d2.indexOf("::"))] = true : n2.boundProperties[d2] = true), c2 ? (r2.type = c2.type, r2.reflectToAttribute = c2.reflectToAttribute) : (["checked", "selected", "async", "autofocus", "autoplay", "controls", "defer", "disabled", "hidden", "ismap", "loop", "multiple", "open", "readonly", "required", "scoped"].indexOf(t2) >= 0 ? r2.type = "boolean" : r2.type = "string", r2.reflectToAttribute = true), r2;
            }
            updateTextNodes() {
              const e2 = this;
              e2.updateTextNode(e2.shadowRoot || e2, e2.bindings, e2);
            }
            updateTextNode(e2, t2, n2) {
              const r2 = this;
              if (!t2)
                return;
              let o2 = 0;
              for (let i2 = e2.firstChild; i2 && t2.children; i2 = i2.nextSibling)
                r2.updateTextNode(i2, t2.children[o2++], n2);
              if (t2 && t2.data)
                for (let e3 in t2.data) {
                  const r3 = t2.data[e3], o3 = r3.name;
                  "textContent" === e3 && r3.twoWay && !r3.updating && void 0 !== r3.value && (n2[o3] = r3.value);
                }
            }
            updateBoundProperty(e2, t2) {
              if (t2.updating)
                return;
              const n2 = this;
              t2.updating = true, n2[e2] = t2.value, t2.updating = false;
            }
            updateBoundNodes(e2) {
              const t2 = this;
              if (t2.updateBoundNode(t2.shadowRoot || t2, t2.bindings, t2, e2), t2.detachedChildren.length > 0)
                for (let n2 = 0; n2 < t2.detachedChildren.length; n2++) {
                  const r2 = t2.detachedChildren[n2], o2 = r2.getAttribute("smart-id"), i2 = function(e3) {
                    if (e3.nodeId === o2)
                      return e3;
                    for (let t3 in e3.children) {
                      const n3 = e3.children[t3];
                      if ((n3.getAttribute ? n3.getAttribute("smart-id") : "") === o2)
                        return e3;
                      if (n3.children) {
                        const e4 = i2(n3);
                        if (e4)
                          return e4;
                      }
                    }
                    return null;
                  }, s2 = i2(t2.bindings);
                  if (s2)
                    t2.updateBoundNode(r2, s2, t2, e2, true);
                  else if (r2.getAttribute && t2.bindings.mapping) {
                    const n3 = t2, r3 = t2.bindings;
                    if (r3)
                      for (let o3 in r3.mapping) {
                        const i3 = n3.querySelector('[smart-id="' + o3 + '"]');
                        if (i3) {
                          const s3 = r3.mapping[o3];
                          t2.updateBoundData(i3, s3, n3, e2);
                        }
                      }
                  }
                }
            }
            updateBoundMappedNodes() {
              const e2 = this, t2 = e2.bindings, n2 = e2;
              if (t2.mapping)
                for (let r2 in t2.mapping) {
                  let o2 = n2.querySelector('[smart-id="' + r2 + '"]');
                  if (n2.shadowRoot && (o2 = n2.querySelector('[id="' + r2 + '"]'), o2 || (o2 = n2.shadowRoot.querySelector('[id="' + r2 + '"]') || n2.shadowRoot.querySelector('[smart-id="' + r2 + '"]'))), o2) {
                    const i2 = t2.mapping[r2];
                    e2.updateBoundData(o2, i2, n2);
                  } else if (n2.getAttribute("aria-controls")) {
                    let i2 = document.getElementById(n2.getAttribute("aria-controls"));
                    if (!i2 && n2.shadowRoot && (i2 = n2.shadowRoot.getElementById(n2.getAttribute("aria-controls"))), o2 = i2.querySelector('[smart-id="' + r2 + '"]'), o2) {
                      const i3 = t2.mapping[r2];
                      e2.updateBoundData(o2, i3, n2);
                    }
                  }
                }
            }
            updateBoundNode(e2, t2, n2, r2, o2) {
              const i2 = this;
              if (!t2)
                return;
              let s2 = 0;
              if (o2) {
                if (o2 && !t2.data)
                  for (let a3 = e2.firstChild; a3 && t2.children; a3 = a3.nextSibling)
                    if (a3.getAttribute) {
                      const e3 = a3.getAttribute("smart-id"), o3 = function() {
                        for (let n3 in t2.children)
                          if (t2.children[n3].nodeId === e3)
                            return t2.children[n3];
                      }();
                      i2.updateBoundNode(a3, o3, n2, r2), s2++;
                    } else
                      i2.updateBoundNode(a3, t2.children[s2++], n2, r2, o2);
              } else
                for (let o3 = e2.firstChild; o3 && t2.children; o3 = o3.nextSibling)
                  if (o3.getAttribute) {
                    const e3 = o3.getAttribute("smart-id"), a3 = function() {
                      for (let n3 in t2.children)
                        if (t2.children[n3].nodeId === e3)
                          return t2.children[n3];
                    }();
                    i2.updateBoundNode(o3, a3, n2, r2), s2++;
                  } else
                    i2.updateBoundNode(o3, t2.children[s2++], n2, r2);
              if (!t2 || !t2.data)
                return;
              const a2 = t2.data;
              i2.updateBoundData(e2, a2, n2, r2);
            }
            updateBoundData(e2, t2, n2, r2) {
              const o2 = this;
              for (let i2 in t2) {
                const s2 = t2[i2];
                let a2 = s2.name;
                if (!s2.updating && (a2.indexOf("::") >= 0 && (a2 = a2.substring(0, a2.indexOf("::"))), void 0 === r2 || r2 === a2)) {
                  if (a2.indexOf("(") >= 0) {
                    let e3 = a2.substring(a2.indexOf("("));
                    const t3 = a2.substring(0, a2.indexOf("("));
                    if (e3 = e3.substring(1, e3.length - 1), e3 = e3.replace(/ /gi, ""), e3 = e3.split(","), e3.length > 0 && "" !== e3[0]) {
                      let r3 = [];
                      for (let t4 = 0; t4 < e3.length; t4++)
                        r3.push(n2[e3[t4]]);
                      s2.value = n2[t3].apply(n2, r3);
                    } else
                      s2.value = n2[t3]();
                    s2.type = typeof s2.value;
                  } else
                    s2.value = n2[a2];
                  if ("innerHTML" === a2) {
                    if (e2[i2].toString().trim() !== n2[a2].toString().trim()) {
                      if (window.smartBlazor && e2[i2].indexOf("<!--") >= 0) {
                        (s2.ready || n2._properties[a2].defaultValue !== s2.value) && (e2[i2] = s2.value.toString());
                        continue;
                      }
                      (s2.ready || n2._properties[a2].defaultValue !== s2.value) && (e2[i2] = s2.value.toString().trim());
                    }
                  } else
                    s2.not ? (e2[i2] = !s2.value, s2.targetPropertyName && (e2[s2.targetPropertyName] = !s2.value)) : (e2[i2] = s2.value, s2.targetPropertyName && (e2[s2.targetPropertyName] = s2.value));
                  if (e2.$ && e2.$.isNativeElement) {
                    v.cache["toDash" + i2] || (v.cache["toDash" + i2] = y.Core.toDash(i2));
                    const t3 = v.cache["toDash" + i2], n3 = e2.$.getAttributeValue(t3, s2.type);
                    !s2.reflectToAttribute || n3 === s2.value && s2.ready || e2.$.setAttributeValue(t3, s2.value, s2.type), s2.reflectToAttribute || e2.$.setAttributeValue(t3, null, s2.type);
                  }
                  if (!s2.ready) {
                    if (e2.$ && e2.$.isCustomElement) {
                      v.cache["toDash" + i2] || (v.cache["toDash" + i2] = y.Core.toDash(i2));
                      const t3 = v.cache["toDash" + i2];
                      e2._properties || (e2._beforeCreatedProperties = e2._properties = e2.propertyByAttributeName = []), e2._properties[i2] || (e2._properties[i2] = { attributeName: t3 }, e2._beforeCreatedProperties && (e2._beforeCreatedProperties[i2] = e2._properties[i2]), e2.propertyByAttributeName[t3] = e2._properties[i2]);
                      const n3 = e2._properties[i2];
                      n3.isUpdating = true, s2.reflectToAttribute && (s2.not ? e2.$.setAttributeValue(n3.attributeName, !s2.value, s2.type) : e2.$.setAttributeValue(n3.attributeName, s2.value, s2.type)), s2.reflectToAttribute || e2.$.setAttributeValue(n3.attributeName, null, s2.type), n3.isUpdating = false;
                    }
                    if (s2.twoWay) {
                      const t3 = function(t4) {
                        if (s2.value = t4, e2.$ && e2.$.isNativeElement) {
                          v.cache["toDash" + i2] || (v.cache["toDash" + i2] = y.Core.toDash(i2));
                          const t5 = v.cache["toDash" + i2], n3 = e2.$.getAttributeValue(t5, s2.type);
                          s2.reflectToAttribute && n3 !== s2.value && e2.$.setAttributeValue(t5, s2.value, s2.type), s2.reflectToAttribute || e2.$.setAttributeValue(t5, null, s2.type);
                        }
                      };
                      if (s2.name.indexOf("::") >= 0) {
                        const n3 = s2.name.indexOf("::"), r3 = s2.name.substring(n3 + 2);
                        o2["$" + e2.getAttribute("smart-id")].listen(r3, function() {
                          t3(e2[i2]);
                          const n4 = s2.name.substring(0, s2.name.indexOf("::"));
                          o2.updateBoundProperty(n4, s2);
                        });
                      }
                      if (e2.$ && e2.$.isCustomElement) {
                        e2._properties[i2] && (e2._properties[i2].notify = true), v.cache["toDash" + i2] || (v.cache["toDash" + i2] = y.Core.toDash(i2));
                        const n3 = v.cache["toDash" + i2];
                        o2["$" + e2.getAttribute("smart-id")].listen(n3 + "-changed", function(e3) {
                          let n4 = e3.detail;
                          t3(n4.value);
                          const r3 = o2.context;
                          e3.context !== document && (o2.context = o2), o2.updateBoundProperty(s2.name, s2), o2.context = r3;
                        });
                      }
                    }
                  }
                  s2.ready = true;
                }
              }
            }
            static clearCache() {
              this.cache = {};
            }
            addMessages(e2, t2) {
              Object.assign(this.messages[e2], t2);
            }
            localize(e2, t2) {
              const n2 = this;
              if (!n2.messages || !n2.messages[n2.locale])
                return;
              let r2 = n2.messages[n2.locale][e2];
              if ("" === r2)
                return "";
              if (!r2) {
                const r3 = n2.messages.en;
                if (r3) {
                  let n3 = r3[e2];
                  if (n3) {
                    for (let e3 in t2) {
                      let r4 = t2[e3];
                      n3 = n3.replace(new RegExp("{{" + e3 + "}}", "g"), r4);
                    }
                    return n3;
                  }
                  return e2;
                }
              }
              const o2 = r2;
              for (let e3 in t2) {
                let n3 = t2[e3];
                r2 = r2.replace(new RegExp("{{" + e3 + "}}", "g"), n3);
              }
              if (n2.localizeFormatFunction) {
                const i2 = n2.localizeFormatFunction(o2, r2, t2, e2);
                if (void 0 !== i2)
                  return i2;
              }
              return r2;
            }
            static get requires() {
              return {};
            }
            static get listeners() {
              return { "theme-changed": function(e2) {
                this.theme = e2.detail.newValue;
              } };
            }
            static get methods() {
              return {};
            }
            get classNamesMap() {
              return { animation: "smart-animate", rippleAnimation: "smart-ripple" };
            }
            get hasAnimation() {
              return "none" !== this.animation;
            }
            get hasRippleAnimation() {
              return "none" !== this.animation && "advanced" === this.animation;
            }
            static get modules() {
              return window[n].Modules;
            }
            get properties() {
              const e2 = this;
              return e2._properties || (e2._properties = []), e2._properties;
            }
            get parents() {
              const e2 = this;
              let t2 = [], r2 = e2.parentNode;
              for (; r2 && 9 !== r2.nodeType; )
                r2 instanceof HTMLElement == 1 && t2.push(r2), r2 = r2.parentNode;
              const o2 = e2.getRootNode();
              if (o2.host) {
                const e3 = (e4) => {
                  let t3 = [e4], n2 = e4.parentNode;
                  for (; n2 && 9 !== n2.nodeType; )
                    n2 instanceof HTMLElement == 1 && t3.push(n2), n2 = n2.parentNode;
                  return t3;
                };
                t2 = t2.concat(e3(o2.host));
              }
              return window[n].EnableShadowDOM && e2.isInShadowDOM && e2.shadowParent && (t2 = t2.concat(e2.shadowParent.parents)), t2;
            }
            log(e2) {
              this._logger("log", e2);
            }
            warn(e2) {
              this._logger("warn", e2);
            }
            error(e2) {
              this._logger("error", e2);
            }
            _logger(e2, t2) {
              if (this.debugMode) {
                const n2 = t2 instanceof Error ? t2.message : t2.toString();
                console[e2](n2);
              }
              if (this.rethrowError && "error" === e2)
                throw t2;
            }
            get focused() {
              return this.contains(document.activeElement);
            }
            template() {
              return "<div></div>";
            }
            registered() {
              const e2 = this;
              e2.onRegistered && e2.onRegistered();
            }
            created() {
              const e2 = this;
              e2.isReady = false, e2._initElement(e2), e2._setModuleState("created"), e2.onCreated && e2.onCreated();
            }
            completed() {
              const e2 = this;
              e2.isCompleted = true, e2._onCompleted && e2._onCompleted(), e2.onCompleted && e2.onCompleted();
            }
            whenReady(e2) {
              const t2 = this;
              t2.isCompleted ? e2() : (t2.whenReadyCallbacks || (t2.whenReadyCallbacks = []), t2.whenReadyCallbacks.push(e2));
            }
            whenRendered(e2) {
              const t2 = this;
              t2.isRendered ? e2() : (t2.whenRenderedCallbacks || (t2.whenRenderedCallbacks = []), t2.whenRenderedCallbacks.push(e2));
            }
            addThemeClass() {
              const e2 = this;
              "" !== e2.theme && e2.classList.add("smart-" + e2.theme);
            }
            addDefaultClass() {
              const e2 = this;
              e2.classList.add(n.toLowerCase() + "-element"), e2.classList.add(e2.nodeName.toLowerCase());
            }
            _renderShadowRoot() {
              const e2 = this;
              if (e2.shadowRoot) {
                e2.$.root.classList.add(e2.nodeName.toLowerCase());
                for (let t2 = 0; t2 < e2.attributes.length; t2++) {
                  const n2 = e2.attributes[t2];
                  "class" === n2.name || "id" === n2.name || "style" === n2.name || "tabindex" === n2.name || n2.name.indexOf("aria") >= 0 || e2.$.root.setAttribute(n2.name, n2.value);
                }
                for (let t2 = 0; t2 < e2.classList.length; t2++) {
                  const n2 = e2.classList[t2];
                  "smart-element-init" !== n2 && "smart-element" !== n2 && "smart-hidden" !== n2 && "smart-visibility-hidden" !== n2 && e2.$.root.classList.add(n2);
                }
              }
            }
            render() {
              const e2 = this;
              if (!e2.isRendered && (e2.isRendered = true, e2.isRendering = false, e2.context = document, e2._renderShadowRoot(), e2.whenRenderedCallbacks)) {
                for (let t2 = 0; t2 < e2.whenRenderedCallbacks.length; t2++)
                  e2.whenRenderedCallbacks[t2]();
                e2.whenRenderedCallbacks = [];
              }
              e2.onRender && e2.onRender(), e2.disabled && e2.setAttribute("aria-disabled", true), e2.readonly && -1 !== ["checkbox", "combobox", "grid", "gridcell", "listbox", "radiogroup", "slider", "spinbutton", "textbox"].indexOf(e2.getAttribute("role")) && e2.setAttribute("aria-readonly", true);
            }
            ready() {
              const e2 = this;
              if (e2._setId(), e2.addThemeClass(), e2.addDefaultClass(), "collapsed" === e2.visibility ? e2.classList.add("smart-hidden") : "hidden" === e2.visibility && e2.classList.add("smart-visibility-hidden"), e2.dataContext && e2.applyDataContext(), e2.onReady && e2.onReady(), e2.shadowRoot && Smart(e2._selector)) {
                if (Smart(e2._selector).styleUrls) {
                  const t2 = Smart(e2._selector).styleUrls;
                  for (let n2 = 0; n2 < t2.length; n2++)
                    e2.importStyle(t2[n2]);
                }
                if (Smart(e2._selector).styles) {
                  const t2 = document.createElement("style");
                  t2.innerHTML = Smart(e2._selector).styles, e2.shadowRoot.insertBefore(t2, e2.shadowRoot.firstChild);
                }
              }
              Smart(e2._selector) && Smart(e2._selector).ready && Smart(e2._selector).ready();
            }
            _setId() {
              const e2 = this;
              if (!e2.id) {
                const t2 = e2.elementName;
                e2.id = t2.slice(0, 1).toLowerCase() + t2.slice(1) + Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
              }
            }
            checkLicense() {
              const e2 = this;
              "Evaluation" === window[n].License && -1 === window.location.hostname.indexOf("htmlelements") && (e2.logWatermark(), e2.logLicense(), window[n].License = "");
            }
            logWatermark() {
              const e2 = document.createElement("a");
              e2.href = "https://www.htmlelements.com/", e2.innerHTML = "https://www.htmlelements.com/", e2.style.position = "absolute", e2.style.right = "5px", e2.style.bottom = "5px", e2.style.color = "#fff", e2.style.padding = "20px", e2.style.borderRadius = "5px", e2.style.background = "#0C3D78", e2.style.cursor = "pointer", e2.style.zIndex = "999999", e2.style.display = "block", e2.style.fontSize = "24px", e2.style.textDecoration = "none", e2.style.fontWeight = "bold", e2.style.opacity = 0, e2.style.transition = "opacity .35s ease-in-out", e2.id = "watermark", document.getElementById("watermark") || setTimeout(() => {
                document.getElementById("watermark") || (document.body.appendChild(e2), setTimeout(() => {
                  e2.style.opacity = 1;
                }), setTimeout(() => {
                  e2.style.opacity = 0, setTimeout(() => {
                    e2.parentNode.removeChild(e2);
                  }, 350);
                }, 6e3));
              }, 1e3);
            }
            logLicense() {
              console.log("****************************************************************************************************************"), console.log("****************************************************************************************************************"), console.log("****************************************************************************************************************"), console.log("*jQWidgets License Key Not Found."), console.log("*This is an EVALUATION only Version, it is NOT Licensed for software projects intended for PRODUCTION."), console.log("*if you want to hide this message, please send an email to: sales@jqwidgets.com for a license."), console.log("****************************************************************************************************************"), console.log("****************************************************************************************************************"), console.log("****************************************************************************************************************");
            }
            get _selector() {
              const e2 = this;
              return e2.id ? "#" + e2.id : e2.classList.length > 0 ? "." + e2.classList[0] : "";
            }
            applyDataContext(e2) {
              const t2 = this;
              let n2 = "string" == typeof t2.dataContext ? window[t2.dataContext] || document[t2.dataContext] : t2.dataContext;
              if (e2 && (n2 = e2, t2.dataContext = e2), n2) {
                if (!n2._uid) {
                  n2._uid = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase(), n2._properties = [];
                  for (let e3 in n2) {
                    const r2 = n2[e3];
                    "function" != typeof r2 && "_properties" !== e3 && "_uid" !== e3 && (n2._properties[e3] = r2, Object.defineProperty(n2, e3, { configurable: false, enumerable: true, get: () => n2._properties[e3], set(r3) {
                      const o2 = n2._properties[e3];
                      n2._properties[e3] = r3;
                      let i2 = [];
                      i2[e3] = { oldValue: o2, value: r3 }, i2.length++, t2.updatingDataContext = true, w.fireEvent("dataContextPropertyChanged", { dataContext: n2, properties: i2 }, { bubbles: false, cancelable: true }), t2.updatingDataContext = false;
                    } }));
                  }
                }
                if (t2.dataContextProperties = t2.parseAttributes(t2), t2.dataContextPropertiesMap = {}, t2.dataContextListeners = {}, t2.dataContextProperties) {
                  t2.updatingDataContext = true;
                  for (let e3 in t2.dataContextProperties) {
                    const r2 = t2.dataContextProperties[e3], o2 = r2.name;
                    if (r2.propertyName = e3, t2.dataContextPropertiesMap[o2] = e3, v.cache["toDash" + e3] || (v.cache["toDash" + e3] = y.Core.toDash(o2)), r2.isEvent) {
                      const e4 = r2.value;
                      t2.dataContextListeners[o2] && t2.removeEventListener(o2, t2.dataContextListeners[o2]), t2.dataContextListeners[o2] = function(t3) {
                        n2[e4](t3);
                      }, t2.addEventListener(o2, t2.dataContextListeners[o2]);
                    }
                    if (o2.indexOf(".") >= 0) {
                      const r3 = o2.split(".");
                      let i2 = n2[r3[0]];
                      for (let e4 = 1; e4 < r3.length; e4++)
                        i2 = i2[r3[e4]];
                      void 0 !== i2 && (t2[e3] = i2);
                    } else
                      t2[e3] = n2[o2];
                  }
                  t2.dataContextPropertyChangedHandler = function(e3) {
                    const n3 = e3.detail.properties;
                    if (e3.detail.dataContext === ("string" == typeof t2.dataContext ? window[t2.dataContext] || document[t2.dataContext] : t2.dataContext))
                      for (let e4 in n3) {
                        const r2 = t2.dataContextPropertiesMap[e4], o2 = t2.context;
                        r2 && (t2.context = document, t2[r2] = n3[e4].value, t2.context = o2);
                      }
                  }, w.listen("dataContextPropertyChanged", t2.dataContextPropertyChangedHandler), t2.updatingDataContext = false;
                } else
                  t2.dataContextProperties = null;
              } else {
                t2.dataContextProperties = null;
                const e3 = function() {
                  ("string" == typeof t2.dataContext ? window[t2.dataContext] || document[t2.dataContext] : t2.dataContext) && (t2.applyDataContext(), window.removeEventListener("load", e3));
                };
                window.addEventListener("load", e3);
              }
            }
            updateDataContextProperty(e2) {
              const t2 = this, n2 = "string" == typeof t2.dataContext ? window[t2.dataContext] || document[t2.dataContext] : t2.dataContext, r2 = t2.dataContextProperties[e2];
              if (!t2.updatingDataContext && r2.twoWay) {
                const o2 = r2.name;
                if (o2.indexOf(".") >= 0) {
                  const r3 = o2.split(".");
                  let i2 = n2[r3[0]];
                  for (let e3 = 1; e3 < r3.length; e3++)
                    i2 = i2[r3[e3]];
                  void 0 !== i2 && (i2 = t2[e2], c[n2._uid] && (c[n2._uid][e2] = i2));
                } else
                  n2[o2] = t2[e2], c[n2._uid] && (c[n2._uid][e2] = n2[o2]);
              }
            }
            static get version() {
              return window[n].Version;
            }
            initProperties() {
              const e2 = this;
              if (Smart(e2._selector) && Smart(e2._selector).properties && (e2._initProperties = Smart(e2._selector).properties), e2.hasAttribute("props") && !e2.props ? e2._initProperties = window[e2.getAttribute("props")] : e2.props && (e2._initProperties = e2.props), e2._initProperties) {
                const t2 = Object.keys(e2._initProperties);
                for (let n2 = 0; n2 < t2.length; n2++) {
                  const r2 = t2[n2], o2 = e2._initProperties[r2];
                  if (void 0 !== o2) {
                    if (o2.constructor === Smart.ObservableArray || o2 instanceof Smart.ObservableArray) {
                      e2[r2] = o2.toArray();
                      continue;
                    }
                    if (o2.constructor === Smart.DataAdapter || "smartDataAdapter" === o2.constructor.name || "object" == typeof o2 && Smart.DataAdapter && o2 instanceof Smart.DataAdapter || o2 instanceof Smart.Observable || o2.constructor === Smart.Observable || "object" != typeof o2 || y.Types.isArray(o2) || o2 instanceof Date) {
                      if (void 0 === e2[r2] && -1 === ["onReady", "onAttached", "onDetached", "onCreated", "onCompleted"].indexOf(r2)) {
                        const t3 = e2.localize("propertyUnknownName", { name: r2 });
                        e2.log(t3);
                      }
                      e2[r2] = o2;
                      continue;
                    }
                  }
                  if ("messages" !== r2)
                    if ("dataSourceMap" !== r2 && "rowCSSRules" !== r2) {
                      if (o2 && "object" == typeof o2) {
                        const t3 = function(n3, r3) {
                          const o3 = Object.keys(n3);
                          for (let i2 = 0; i2 < o3.length; i2++) {
                            const s2 = o3[i2], a2 = n3[s2], l2 = e2._properties[r3 + "_" + s2];
                            if (l2 && null === l2.value) {
                              if (void 0 === e2[r3 + "_" + s2]) {
                                const t4 = e2.localize("propertyUnknownName", { name: r3 + "_" + s2 });
                                e2.log(t4);
                              }
                              e2[r3 + "_" + s2] = a2;
                            } else if ("object" == typeof a2 && !y.Types.isArray(a2) && a2 && a2.constructor !== Date)
                              t3(a2, r3 + "_" + s2);
                            else {
                              if (void 0 === e2[r3 + "_" + s2]) {
                                const t4 = e2.localize("propertyUnknownName", { name: r3 + "_" + s2 });
                                e2.log(t4);
                              }
                              e2[r3 + "_" + s2] = a2;
                            }
                          }
                        };
                        t3(o2, r2);
                      }
                    } else
                      e2[r2] = o2;
                  else
                    e2[r2] = Object.assign(e2[r2], o2);
                }
              }
            }
            setProperties(e2) {
              const t2 = this, n2 = Object.keys(e2);
              for (let r2 = 0; r2 < n2.length; r2++) {
                const o2 = n2[r2], i2 = e2[o2];
                if (i2.constructor === Smart.ObservableArray || i2 instanceof Smart.ObservableArray)
                  t2[o2] = i2.toArray();
                else if (i2.constructor === Smart.DataAdapter || "smartDataAdapter" === i2.constructor.name || "object" == typeof i2 && Smart.DataAdapter && i2 instanceof Smart.DataAdapter || i2 instanceof Smart.Observable || i2.constructor === Smart.Observable || "object" != typeof i2 || y.Types.isArray(i2) || i2 instanceof Date) {
                  if (void 0 === t2[o2] && -1 === ["onReady", "onAttached", "onDetached", "onCreated", "onCompleted"].indexOf(o2))
                    continue;
                  const e3 = t2._properties[o2];
                  "int" === e3.type || "number" === e3.type && "string" == typeof subPropertyValue ? "int" === e3.type ? t2[o2] = parseInt(i2) : t2[o2] = parseFloat(i2) : t2[o2] = i2;
                } else if ("messages" !== o2 && "dataSourceMap" !== o2) {
                  if ("object" == typeof i2) {
                    const e3 = function(n3, r3) {
                      const o3 = Object.keys(n3);
                      for (let i3 = 0; i3 < o3.length; i3++) {
                        const s2 = o3[i3], a2 = n3[s2], l2 = t2._properties[r3 + "_" + s2];
                        if (l2 && null === l2.value) {
                          if (void 0 === t2[r3 + "_" + s2])
                            continue;
                          const e4 = t2._properties[r3 + "_" + s2];
                          "int" === e4.type || "number" === e4.type && "string" == typeof a2 ? "int" === e4.type ? t2[r3 + "_" + s2] = parseInt(a2) : t2[r3 + "_" + s2] = parseFloat(a2) : t2[r3 + "_" + s2] = a2;
                        } else if ("object" == typeof a2 && !y.Types.isArray(a2) && a2 && a2.constructor !== Date)
                          e3(a2, r3 + "_" + s2);
                        else {
                          if (void 0 === t2[r3 + "_" + s2])
                            continue;
                          const e4 = t2._properties[r3 + "_" + s2];
                          "int" === e4.type || "number" === e4.type && "string" == typeof a2 ? "int" === e4.type ? t2[r3 + "_" + s2] = parseInt(a2) : t2[r3 + "_" + s2] = parseFloat(a2) : t2[r3 + "_" + s2] = a2;
                        }
                      }
                    };
                    e3(i2, o2);
                  }
                } else
                  t2[o2] = i2;
              }
            }
            setup() {
              const e2 = this;
              if (e2.context = this, e2.isReady && !e2.isCompleted)
                return;
              if (e2.isReady)
                return e2._setModuleState("attached"), e2.isAttached = true, e2.attached(), e2._handleListeners("listen"), void (e2.context = document);
              e2.ownerElement && e2.ownerElement.detachedChildren.indexOf(e2) >= 0 && e2.ownerElement.detachedChildren.splice(e2.ownerElement.detachedChildren.indexOf(e2), 1), e2.isReady = true, e2.methods = e2.getStaticMember("methods"), e2.initProperties(), a.isMobile && e2.classList.add("smart-mobile");
              for (let t3 = 0; t3 < e2.attributes.length; t3 += 1) {
                const n2 = e2.propertyByAttributeName[e2.attributes[t3].name];
                if (!n2)
                  continue;
                let r3 = e2.$.getAttributeValue(n2.attributeName, n2.type);
                const o2 = r3 ? r3.toString() : "";
                if (!(o2.indexOf("{{") >= 0 || o2.indexOf("[[") >= 0 || "object" !== n2.type && "array" !== n2.type && (e2.attributes[t3].value.indexOf("{{") >= 0 || e2.attributes[t3].value.indexOf("[[") >= 0) || void 0 === r3 || n2.value === r3)) {
                  const o3 = y.Types.getType(r3), i2 = e2.attributes[t3].value;
                  if (("any" === n2.type || "object" === n2.type) && "" + e2[n2.name] === r3)
                    continue;
                  if ("array" === n2.type && e2[n2.name] && JSON.stringify(e2[n2.name]) === r3)
                    continue;
                  if ("number" === o3 && isNaN(r3) && "NaN" !== i2 && "Infinity" !== i2 && "-Infinity" !== i2) {
                    const t4 = e2.localize("propertyInvalidValueType", { name: n2.name, actualType: "string", type: n2.type });
                    e2.log(t4);
                  }
                  n2.isUpdatingFromAttribute = true, e2[n2.name] = r3, n2.isUpdatingFromAttribute = false;
                }
              }
              for (let t3 in e2._properties) {
                const n2 = e2._properties[t3];
                if ("innerHTML" === t3 && n2.value === n2.defaultValue && (n2.value = n2.defaultValue = y.Core.html(e2)), "boolean" !== n2.type && "bool" !== n2.type || "false" === e2.getAttribute(n2.attributeName) && (n2.isUpdating = true, e2.setAttribute(n2.attributeName, ""), n2.isUpdating = false), n2.defaultReflectToAttribute && n2.reflectToAttribute) {
                  if (n2.defaultReflectToAttribute && n2.defaultReflectToAttributeConditions) {
                    let t4 = true;
                    for (let r3 = 0; r3 < n2.defaultReflectToAttributeConditions.length; r3++) {
                      const o2 = n2.defaultReflectToAttributeConditions[r3];
                      let i2, s2;
                      for (let e3 in o2)
                        i2 = e3, s2 = o2[e3];
                      e2._properties[i2] && e2._properties[i2].value !== s2 && (t4 = false);
                    }
                    if (!t4)
                      continue;
                  }
                  n2.isUpdating = true, e2.$.setAttributeValue(n2.attributeName, n2.value, n2.type), n2.isUpdating = false;
                }
              }
              const t2 = [];
              if (e2.children.length > 0)
                for (let n2 = 0; n2 < e2.children.length; n2++) {
                  const r3 = e2.children[n2];
                  y.Extend(r3).isCustomElement && t2.push(r3);
                }
              e2.applyTemplate(), e2.complete = function() {
                if (!e2.templateBindingsReady) {
                  const t4 = (e3) => {
                    e3.templateBindingsReady || (e3.templateBindingsReady = true, e3.updateTextNodes(), e3.updateBoundNodes());
                  };
                  if (e2.ownerElement) {
                    let n2 = e2.ownerElement, r3 = [];
                    for (; n2; )
                      r3.push(n2), n2 = n2.ownerElement;
                    for (let e3 = r3.length - 1; e3 >= 0; e3--)
                      t4(r3[e3]);
                    t4(e2);
                  } else
                    t4(e2);
                }
                const t3 = () => {
                  if (e2._setModuleState("ready"), e2.ready(), "auto" !== e2.renderMode || e2.isRendered || e2.render(), e2.isAttached = true, e2._setModuleState("attached"), e2.attached(), e2._handleListeners("listen"), e2.isHidden || 0 !== e2.offsetWidth && 0 !== e2.offsetHeight || (e2.isHidden = true), e2.completed(), e2.isRendered && (e2.context = document), e2.whenReadyCallbacks) {
                    for (let t4 = 0; t4 < e2.whenReadyCallbacks.length; t4++)
                      e2.whenReadyCallbacks[t4]();
                    e2.whenReadyCallbacks = [];
                  }
                };
                if (e2.wait)
                  e2.classList.add("smart-visibility-hidden");
                else if (e2.classList.contains("smart-async"))
                  requestAnimationFrame(() => {
                    t3();
                  });
                else {
                  const n2 = e2.shadowParent;
                  e2.shadowParent = null;
                  const r3 = e2.parents;
                  if (e2.shadowParent = n2, 0 === r3.length)
                    return;
                  const o2 = () => {
                    let t4 = e2.ownerElement, n3 = [];
                    for (; t4; )
                      n3.push(t4), t4 = t4.ownerElement;
                    for (let e3 = n3.length - 1; e3 >= 0; e3--)
                      n3[e3].updateBoundMappedNodes();
                  };
                  e2.ownerElement && "HTML" !== r3[r3.length - 1].nodeName ? e2.getRootNode().host ? t3() : e2.ownerElement && "HTML" === e2.ownerElement.parents[e2.ownerElement.parents.length - 1].nodeName ? (o2(), t3()) : e2.checkIsInDomInterval = setInterval(() => {
                    const n3 = e2.parents;
                    "HTML" === n3[n3.length - 1].nodeName && (clearInterval(e2.checkIsInDomInterval), o2(), t3());
                  }, 100) : t3();
                }
              };
              let r2 = [].slice.call(e2.querySelectorAll("[smart-id]")).concat(t2);
              if (window[n].EnableShadowDOM && true !== e2.isInShadowDOM && (r2 = [].slice.call(e2.shadowRoot.querySelectorAll("[smart-id]")).concat(t2)), 0 === r2.length)
                e2.complete();
              else {
                e2._completeListeners = 0;
                for (let t3 = 0; t3 < r2.length; t3++) {
                  const n2 = r2[t3];
                  if (y.Extend(n2).isCustomElement) {
                    const t4 = (function() {
                      e2._completeListeners--, 0 === e2._completeListeners && (e2.complete(), delete e2._completeListeners);
                    }).bind(e2);
                    n2.isCompleted || n2.isUtilityElement || true === n2.wait || (e2._completeListeners++, n2._onCompleted || (n2.completeHandlers = [], n2._onCompleted = function() {
                      for (let e3 = 0; e3 < n2.completeHandlers.length; e3++)
                        n2.completeHandlers[e3]();
                    }), n2.completeHandlers.push(t4));
                  }
                }
                0 === e2._completeListeners && e2.complete();
              }
            }
            visibilityChangedHandler() {
              const e2 = this;
              e2.isReady && requestAnimationFrame(() => {
                0 === e2.offsetWidth || 0 === e2.offsetHeight ? e2.isHidden = true : (e2.isHidden = false, e2.$.fireEvent("resize", e2, { bubbles: false, cancelable: true }));
              });
            }
            attributeChangedCallback(e2, t2, n2) {
              const r2 = this, o2 = r2.propertyByAttributeName[e2];
              if ("class" !== e2 && "style" !== e2 || r2.visibilityChangedHandler(), o2 || r2.attributeChanged(e2, t2, n2), r2.onAttributeChanged && r2.onAttributeChanged(e2, t2, n2), !o2 || o2 && o2.isUpdating)
                return;
              let i2 = r2.$.getAttributeValue(o2.attributeName, o2.type);
              void 0 !== n2 && r2[o2.name] !== i2 && (o2.isUpdatingFromAttribute = true, r2[o2.name] = void 0 !== i2 ? i2 : r2._properties[o2.name].defaultValue, o2.isUpdatingFromAttribute = false);
            }
            attributeChanged(e2, t2, n2) {
            }
            set hasStyleObserver(e2) {
              const t2 = this;
              void 0 === t2._hasStyleObserver && (t2._hasStyleObserver = e2), e2 ? d.watch(t2) : d.unwatch(t2);
            }
            get hasStyleObserver() {
              const e2 = this;
              return void 0 === e2._hasStyleObserver || e2._hasStyleObserver;
            }
            attached() {
              const e2 = this;
              e2.hasStyleObserver && d.watch(e2), e2.onAttached && e2.onAttached(), Smart(e2._selector) && Smart(e2._selector).attached && Smart(e2._selector).attached();
            }
            detached() {
              const e2 = this;
              e2.hasStyleObserver && d.unwatch(e2), e2._setModuleState("detached"), e2.isAttached = false, e2.ownerElement && -1 === e2.ownerElement.detachedChildren.indexOf(e2) && e2.ownerElement.detachedChildren.push(e2), e2._handleListeners("unlisten"), e2.onDetached && e2.onDetached(), Smart(e2._selector) && Smart(e2._selector).detached && Smart(e2._selector).detached(), u && u[e2._selector] && delete u[e2._selector];
            }
            propertyChangedHandler(e2, t2, n2) {
              const r2 = this;
              t2 !== n2 && ("theme" === e2 && ("" !== t2 && r2.classList.remove("smart-" + t2), "" !== n2 && r2.classList.add("smart-" + n2)), "visibility" === e2 ? ("collapsed" === t2 ? r2.classList.remove("smart-hidden") : "hidden" === t2 && r2.classList.remove("smart-visibility-hidden"), "collapsed" === n2 ? r2.classList.add("smart-hidden") : "hidden" === n2 && r2.classList.add("smart-visibility-hidden")) : ("disabled" === e2 || "readonly" === e2) && r2._ariaPropertyChangedHandler(e2, n2), r2.propertyChanged && r2.propertyChanged(e2, t2, n2));
            }
            _ariaPropertyChangedHandler(e2, t2) {
              const n2 = this;
              "readonly" === e2 && -1 === ["checkbox", "combobox", "grid", "gridcell", "listbox", "radiogroup", "slider", "spinbutton", "textbox"].indexOf(n2.getAttribute("role")) || (t2 ? n2.setAttribute("aria-" + e2, true) : n2.removeAttribute("aria-" + e2));
            }
            _handleListeners(e2) {
              const t2 = this, n2 = t2.tagName.toLowerCase(), r2 = (r3) => {
                for (let o2 in r3) {
                  const i2 = o2.split(".");
                  let s2 = i2[0], a2 = t2.$;
                  if (i2[1])
                    if (s2 = i2[1], a2 = t2["$" + i2[0]], "document" === i2[0]) {
                      let e3 = t2.smartId;
                      "" === e3 && (e3 = y.Core.toCamelCase(n2)), s2 = s2 + "." + e3;
                    } else
                      t2.smartId && (s2 = s2 + "." + t2.smartId + "_" + t2.parents.length);
                  else
                    t2.smartId && (s2 = s2 + "." + t2.smartId);
                  const l2 = r3[o2], d2 = function(e3) {
                    const n3 = t2.context;
                    t2.context = t2, t2[l2] && t2[l2].apply(t2, [e3]), t2.context = n3;
                  };
                  a2 && a2[e2](s2, d2);
                }
              };
              r2(t2.getStaticMember("listeners")), r2(t2.templateListeners), Smart(t2._selector) && Smart(t2._selector).properties && r2(Smart(t2._selector).listeners);
            }
            parseTemplate() {
              const e2 = this, n2 = e2.template(), o2 = document.createDocumentFragment();
              if (t[e2.nodeName] && !r)
                return t[e2.nodeName].cloneNode(true);
              if ("" === n2)
                return null;
              let i2 = document.createElement("div");
              o2.appendChild(i2), i2.innerHTML = n2;
              let s2 = i2.childNodes;
              i2.parentNode.removeChild(i2);
              for (let e3 = 0; e3 < s2.length; e3++)
                o2.appendChild(s2[e3]);
              return t[e2.nodeName] = o2, r ? o2 : o2.cloneNode(true);
            }
            applyTemplate() {
              const e2 = this, t2 = e2.parseTemplate();
              if (!t2)
                return;
              if (!t2.hasChildNodes)
                return;
              const n2 = t2.childNodes[0], r2 = (t3, n3) => {
                e2["$" + t3] = n3.$ = y.Extend(n3), e2.$[t3] = n3, n3.ownerElement = e2;
              };
              let o2 = n2;
              if (n2.getElementsByTagName("content").length > 0) {
                let e3 = n2.getElementsByTagName("content")[0];
                o2 = e3.parentNode, o2.removeChild(e3);
              } else {
                const e3 = t2.querySelectorAll("[inner-h-t-m-l]");
                e3 && e3.length > 0 && (o2 = e3[0]);
              }
              e2.$.template = "template" === n2.nodeName.toLowerCase() ? n2 : n2.querySelector("template");
              let i2 = t2.querySelectorAll("[id]");
              0 === i2.length && (i2 = t2.querySelectorAll("*")), r2("root", n2), r2("content", o2), e2.$.html = e2.innerHTML.toString().trim();
              for (let t3 = 0; t3 < i2.length; t3 += 1) {
                let n3 = i2[t3];
                "" === n3.id && (n3.id = "child" + t3), r2(n3.id, n3), n3.setAttribute("smart-id", n3.id), e2.shadowRoot ? n3.shadowParent = e2 : n3.removeAttribute("id");
              }
              for (false !== e2.hasTemplateBindings ? e2.bindings = e2.getBindings(t2) : e2.bindings = [], e2.$root.addClass("smart-container"); e2.childNodes.length; )
                o2.appendChild(e2.firstChild);
              if (e2.appendTemplate(t2), e2.$.template) {
                const t3 = document.createElement("div");
                t3.classList.add("smart-template-container"), e2.$.templateContainer = t3, e2.$.template.parentNode.insertBefore(t3, e2.$.template), e2.refreshTemplate();
              }
            }
            refreshTemplate() {
              const e2 = this;
              if (!e2.$.templateContainer)
                return;
              e2.templateDetached(e2.$.templateContainer);
              const t2 = e2.$.template.content.cloneNode(true);
              e2.templateBindings = e2.getBindings(t2), e2.templateProperties = [];
              let n2 = document.createDocumentFragment();
              const r2 = function(t3, n3, o2) {
                for (let i2 in t3) {
                  const s2 = t3[i2], a2 = s2.node.cloneNode();
                  n3.appendChild(a2);
                  let l2 = [], d2 = false;
                  if (s2.data)
                    for (let t4 in s2.data) {
                      const r3 = s2.data[t4], i3 = r3.name;
                      if (e2.templateProperties[i3] = true, a2.removeAttribute(y.Core.toDash(t4)), "*items" === t4)
                        l2 = e2[i3], d2 = true;
                      else if (i3.indexOf("item.") >= 0 && void 0 !== o2)
                        r3.value = o2[i3.substring("item.".length)], a2[t4] = r3.value;
                      else if (i3.indexOf("item") >= 0 && void 0 !== o2)
                        r3.value = o2, a2[t4] = r3.value;
                      else if ("*if" === t4)
                        if (i3.indexOf("(") >= 0) {
                          let t5, r4 = i3.substring(i3.indexOf("("));
                          const o3 = i3.substring(0, i3.indexOf("("));
                          if (r4 = r4.substring(1, r4.length - 1), r4 = r4.replace(/ /gi, ""), r4 = r4.split(","), r4.length > 0 && "" !== r4[0]) {
                            let n4 = [];
                            for (let t6 = 0; t6 < r4.length; t6++)
                              n4.push(e2[r4[t6]]);
                            t5 = e2[o3].apply(e2, n4);
                          } else
                            t5 = e2[o3]();
                          false === t5 && n3.removeChild(a2);
                        } else
                          e2[i3] || n3.removeChild(a2);
                      else
                        e2.updateBoundNode(a2, s2, e2, i3);
                    }
                  if (l2.length > 0 || d2) {
                    for (let e3 = 0; e3 < l2.length; e3++)
                      s2.children && r2(s2.children, a2, l2[e3]);
                    if ("number" == typeof l2)
                      for (let e3 = 0; e3 < l2; e3++)
                        s2.children && r2(s2.children, a2, e3);
                  } else
                    s2.children && r2(s2.children, a2, o2);
                }
              };
              r2(e2.templateBindings.children, n2), e2.$.templateContainer.innerHTML = "", e2.$.templateContainer.appendChild(n2), e2.templateAttached(e2.$.templateContainer);
            }
            templateAttached() {
            }
            templateDetached() {
            }
            appendTemplate(e2) {
              this.appendChild(e2);
            }
            defineElementModules() {
              const e2 = this, t2 = e2.constructor.prototype;
              if ("BaseElement" === t2.elementName) {
                t2.modules = e2.constructor.modules;
                const n2 = t2.modules;
                for (let t3 = 0; t3 < n2.length; t3 += 1)
                  e2.addModule(n2[t3]);
              } else {
                const n2 = t2.modules;
                if (!n2)
                  return;
                for (let t3 = 0; t3 < n2.length; t3 += 1) {
                  const r2 = n2[t3], o2 = r2.prototype;
                  e2.defineElementMethods(o2.methodNames, o2), e2.defineElementProperties(r2.properties);
                }
              }
            }
            watch(e2, t2) {
              const n2 = this;
              n2._watch = null !== e2 && null !== t2 ? { properties: e2, propertyChangedCallback: t2 } : null;
            }
            unwatch() {
              this._watch = null;
            }
            set(e2, t2, n2) {
              const r2 = this, o2 = r2.context;
              r2.context = true === n2 ? document : r2, r2[e2] = t2, r2.context = o2;
            }
            get(e2) {
              return this[e2];
            }
            _setModuleState(e2, t2) {
              const n2 = this, r2 = "is" + e2.substring(0, 1).toUpperCase() + e2.substring(1), o2 = "on" + e2.substring(0, 1).toUpperCase() + e2.substring(1);
              for (let i2 = 0; i2 < n2.modulesList.length; i2++) {
                const s2 = n2.modulesList[i2];
                s2[r2] = true, s2[e2] && s2[e2](t2), s2[o2] && s2[o2](t2);
              }
            }
            addModule(e2, t2) {
              const n2 = this;
              if (!e2)
                return;
              const r2 = n2.modules.slice(0), o2 = e2.prototype, i2 = Object.getPrototypeOf(e2);
              if (i2.name && i2.name !== e2.name && n2.addModule(i2), !e2.moduleName && e2.name && (e2.moduleName = e2.name), -1 === r2.findIndex((t3) => e2.moduleName === t3.moduleName) && r2.push(e2), n2.defineModule(e2), n2.defineElementMethods(o2.methodNames, o2), n2.defineElementProperties(e2.properties), n2.constructor.prototype.modules = r2, t2)
                for (let t3 in Smart.Elements.tagNames) {
                  const r3 = Smart.Elements.tagNames[t3];
                  let o3 = Object.getPrototypeOf(r3), i3 = [];
                  for (; o3 !== HTMLElement; )
                    i3.push(o3.prototype), o3 = Object.getPrototypeOf(o3);
                  i3.indexOf(n2) >= 0 && r3 !== n2 && r3.prototype.addModule(e2);
                }
            }
            defineModule(e2) {
              if (e2.isDefined)
                return;
              e2.prototype._initModule = function(e3) {
                this.ownerElement = e3;
              };
              const t2 = e2.properties || {}, n2 = Object.keys(t2), r2 = Object.getOwnPropertyNames(e2.prototype);
              e2.prototype.methodNames = r2;
              for (let r3 = 0; r3 < n2.length; r3 += 1) {
                const o2 = n2[r3], i2 = t2[o2];
                Object.defineProperty(e2.prototype, o2, { configurable: false, enumerable: true, get() {
                  return this.ownerElement ? this.ownerElement[o2] : i2.value;
                }, set(e3) {
                  this.ownerElement[o2] = e3;
                } });
              }
              e2.isDefined = true;
            }
            getStaticMember(e2, t2) {
              const r2 = window[n][this.elementName], o2 = r2[e2];
              t2 || (t2 = "");
              let i2 = "array" === t2 ? [] : "string" === t2 ? "" : {}, s2 = Object.getPrototypeOf(r2), a2 = [];
              for (; s2[e2]; )
                a2.push(s2[e2]), s2 = Object.getPrototypeOf(s2);
              for (let e3 = a2.length - 1; e3 >= 0; e3--)
                if ("array" === t2)
                  for (let t3 = 0; t3 < a2[e3].length; t3++)
                    -1 === i2.indexOf(a2[e3][t3]) && i2.push(a2[e3][t3]);
                else
                  "string" === t2 ? -1 === i2.indexOf(a2[e3]) && (i2 += a2[e3]) : i2 = y.Core.assign(i2, a2[e3]);
              if ("array" === t2) {
                for (let e3 = 0; e3 < o2.length; e3++)
                  -1 === i2.indexOf(o2[e3]) && i2.push(o2[e3]);
                return i2;
              }
              return "string" === t2 ? (-1 === i2.indexOf(o2) && (i2 += o2), i2) : y.Core.assign(i2, o2);
            }
            defineElementHierarchicalProperties(e2, t2) {
              const n2 = this, r2 = [];
              !function(e3) {
                const n3 = Object.keys(e3);
                for (let o2 = 0; o2 < n3.length; o2++) {
                  const i2 = n3[o2];
                  if ("messages" === i2)
                    continue;
                  const s2 = e3[i2], a2 = Object.keys(s2), l2 = a2.indexOf("value") >= 0 && a2.indexOf("type") >= 0 && "object" == typeof s2.value;
                  if ("propertyObject" === s2.type || l2) {
                    const e4 = function(n4, o3) {
                      if (!n4.value)
                        return;
                      const i3 = Object.keys(n4.value);
                      for (let s3 = 0; s3 < i3.length; s3++) {
                        const a3 = i3[s3], l3 = n4.value[a3], d2 = o3 + "_" + a3;
                        if ("object" != typeof l3 || null === l3)
                          break;
                        const c2 = Object.keys(l3);
                        if (!(c2.indexOf("value") >= 0 && c2.indexOf("type") >= 0))
                          break;
                        if ("array" !== n4.type && (n4.isHierarchicalProperty = true), l3.parentPropertyName = o3, t2) {
                          const e5 = t2._properties[d2];
                          if (n4.value.hasOwnProperty(a3)) {
                            if (e5.isDefined)
                              continue;
                            delete n4.value[a3];
                          }
                          e5.isDefined = true, Object.defineProperty(n4.value, a3, { configurable: false, enumerable: true, get: () => t2._properties[d2].value, set(e6) {
                            t2.updateProperty(t2, t2._properties[d2], e6);
                          } });
                        }
                        r2[d2] || (r2[d2] = l3, r2.length++), ("propertyObject" === l3.type || "object" == typeof l3.value && "array" !== l3.type) && e4(t2 ? t2._properties[d2] : l3, d2);
                      }
                    };
                    e4(s2, i2);
                  }
                }
              }(e2), r2.length > 0 && !t2 && n2.defineElementProperties(r2);
            }
            defineElement() {
              const e2 = this, t2 = e2.constructor.prototype, r2 = e2.getStaticMember("properties"), o2 = Object.getOwnPropertyNames(t2);
              t2.extendedProperties = {}, t2.boundProperties = {}, t2.templateListeners = {}, e2.defineElementModules(), e2.defineElementMethods(o2, t2), e2.defineElementProperties(r2), e2.defineElementHierarchicalProperties(e2.extendedProperties), t2._initElement = function() {
                const e3 = this, r3 = t2.extendedProperties, o3 = Object.keys(r3), i2 = e3.modules;
                e3.$ = y.Extend(e3), e3.$document = w, e3.smartId = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase(), e3.isCreated || (e3.modulesList = [], e3._properties = [], e3._beforeCreatedProperties && (e3._properties = e3._beforeCreatedProperties, delete e3._beforeCreatedProperties), e3.detachedChildren = [], e3.propertyByAttributeName = []);
                for (let t3 = 0; t3 < i2.length; t3 += 1) {
                  let n2 = new (0, i2[t3])();
                  n2._initModule(e3), e3.modulesList.push(n2);
                }
                const s2 = [];
                for (let t3 = 0; t3 < o3.length; t3 += 1) {
                  const n2 = o3[t3], i3 = r3[n2];
                  let a2 = i3.value;
                  if (e3._properties[n2]) {
                    if (void 0 !== e3._properties[n2].notify)
                      continue;
                    delete e3._properties[n2];
                  }
                  if (E && "innerHTML" === n2 && delete e3[n2], -1 === window.navigator.userAgent.indexOf("PhantomJS") && e3.hasOwnProperty(n2))
                    if (i3.isHierarchicalProperty && e3[n2]) {
                      const t4 = e3[n2];
                      s2.push({ name: n2, value: t4 }), a2 = i3.value, delete e3[n2];
                    } else
                      a2 = e3[n2], delete e3[n2];
                  if ("array" === i3.type && null != a2 && (a2 = a2.slice(0)), "object" === i3.type && null != a2 && (a2 = Array.isArray(a2) ? a2.slice(0) : Object.assign({}, a2)), e3._properties[n2] = { name: n2, notify: i3.notify, allowedValues: i3.allowedValues, type: i3.type, nullable: i3.nullable, reflectToAttribute: i3.reflectToAttribute, defaultReflectToAttribute: i3.defaultReflectToAttribute, defaultReflectToAttributeConditions: i3.defaultReflectToAttributeConditions, value: a2, readOnly: i3.readOnly, defaultValue: a2, attributeName: i3.attributeName, observer: i3.observer, inherit: i3.inherit, extend: i3.extend, validator: i3.validator }, e3.propertyByAttributeName[i3.attributeName] = e3._properties[n2], !i3.hasOwnProperty("type")) {
                    const t4 = e3.localize("propertyUnknownType", { name: n2 });
                    e3.log(t4);
                  }
                  if ("any" === i3.type || "propertyObject" === i3.type)
                    continue;
                  const l2 = y.Types.getType(a2);
                  if (null != a2 && i3.type !== l2 && !i3.validator) {
                    if ("object" === i3.type && "array" === l2)
                      continue;
                    if ("number" === l2 && ["integer", "int", "float"].findIndex((e4) => e4 === i3.type) >= 0)
                      continue;
                    const t4 = e3.localize("propertyInvalidValueType", { name: n2, actualType: l2, type: i3.type });
                    e3.log(t4);
                  }
                }
                if (e3.defineElementHierarchicalProperties(e3._properties, e3), s2.length && "manual" !== window[n].RenderMode)
                  for (let t3 = 0; t3 < s2.length; t3++) {
                    const n2 = s2[t3];
                    e3[n2.name] = n2.value;
                  }
                e3.isCreated = true;
              }, t2.registered();
            }
            defineElementMethods(e2, t2) {
              const n2 = this.constructor.prototype, r2 = function(e3, t3) {
                const n3 = Array.prototype.slice.call(arguments, 2), r3 = function() {
                  if (!this.isReady && "localize" !== t3 && "localize" !== t3 && "cloneNode" !== t3 && "importStyle" !== t3 && "log" !== t3 && "parseAttributes" !== t3) {
                    const e4 = this.localize("elementNotInDOM");
                    this.log(e4);
                  }
                  let r4 = this;
                  for (let e4 = 0; e4 < this.modulesList.length; e4++) {
                    let n4 = this.modulesList[e4];
                    if (t3 in n4) {
                      r4 = n4;
                      break;
                    }
                  }
                  const o3 = this.context, i2 = n3.concat(Array.prototype.slice.call(arguments));
                  let s2 = null;
                  const a2 = function(e4, t4) {
                    return e4 === t4 || "number" === e4 && ("int" === t4 || "integer" === t4 || "float" === t4) || "bool" === e4 && "boolean" === t4 || "boolean" === e4 && "bool" === t4 || "object" === e4 && "any" === t4 || void 0;
                  };
                  if (this.methods) {
                    const e4 = this.methods[t3];
                    if (e4) {
                      const n4 = e4.split(":");
                      s2 = n4[n4.length - 1].trim();
                      const r5 = [], o4 = e4.substring(1 + e4.indexOf("("), e4.lastIndexOf(")")).split(",");
                      let l3 = "";
                      for (let e5 = 0; e5 < o4.length; e5++) {
                        const t4 = o4[e5];
                        l3 += t4, t4.indexOf(":") >= 0 ? (r5.push(l3), l3 = "") : l3 += ",";
                      }
                      let d2 = r5.length;
                      for (let e5 = 0; e5 < r5.length; e5++) {
                        const n5 = r5[e5].trim().split(":"), o5 = n5[0].split("=")[0].trim().indexOf("?") >= 0, s3 = n5[1].indexOf("?") >= 0, l4 = n5[1].replace(/\?/gi, "").trim(), c2 = l4.split("|");
                        let u2 = n5[0].split("=")[1];
                        const p2 = y.Types.getType(i2[e5]);
                        if (void 0 === i2[e5] && u2) {
                          switch (u2 = u2.trim(), l4[0]) {
                            case "date": {
                              let e6 = u2.substring(u2.indexOf("(") + 1, u2.lastIndexOf(")"));
                              e6 = e6.length > 0 ? e6.split(",").map((e7) => parseInt(e7)) : [], u2 = 0 === e6.length ? /* @__PURE__ */ new Date() : new Date(e6[0], e6[1], e6[2]);
                              break;
                            }
                            case "bool":
                            case "boolean":
                              u2 = "true" === u2 || "1" === u2;
                              break;
                            case "int":
                            case "integer":
                              u2 = parseInt(u2);
                              break;
                            case "float":
                            case "number":
                              u2 = parseFloat(u2);
                              break;
                            case "any":
                            case "object":
                              u2 = u2.indexOf("{") >= 0 ? JSON.parse(u2) : u2;
                          }
                          i2.push(u2);
                        } else
                          o5 && d2--;
                        if (l4 !== p2 && p2) {
                          let n6 = true;
                          for (let e6 = 0; e6 < c2.length; e6++)
                            if (a2(p2, c2[e6])) {
                              n6 = false;
                              break;
                            }
                          if (n6 && (null !== i2[e5] || !s3)) {
                            const n7 = this.localize("methodInvalidValueType", { name: t3, actualType: p2, type: l4, argumentIndex: e5 });
                            this.log(n7);
                          }
                        }
                        if (i2.length < d2) {
                          const e6 = this.localize("methodInvalidArgumentsCount", { name: t3, actualArgumentsCount: i2.length, argumentsCount: d2 });
                          this.log(e6);
                        }
                      }
                    }
                  }
                  this.context = this;
                  const l2 = e3.apply(r4, i2);
                  if (s2) {
                    const e4 = void 0 === y.Types.getType(l2) ? "void" : y.Types.getType(l2);
                    if (!a2(e4, s2)) {
                      const n4 = this.localize("methodInvalidReturnType", { name: t3, actualType: e4, type: s2 });
                      this.log(n4);
                    }
                  }
                  return this.context = o3, l2;
                };
                return r3;
              }, o2 = ["constructor", "ready", "created", "render", "attached", "detached", "appendChild", "insertBefore", "removeChild", "connect", "disconnectedCallback", "connectedCallback", "attributeChangedCallback", "propertyChangedHandler", "enableShadowDOM", "isInShadowDOM", "addPropertyBindings"];
              for (let i2 in e2) {
                let s2 = e2[i2];
                s2 && s2.startsWith && s2.startsWith("_") || void 0 !== o2.find((e3) => e3 === s2) || n2.extendedProperties[s2] || y.Types.isFunction(t2[s2]) && (n2[s2] = r2(t2[s2], s2));
              }
            }
            defineElementProperties(e2) {
              if (!e2)
                return;
              const t2 = this, n2 = t2.constructor.prototype, r2 = Object.keys(e2), o2 = t2.getStaticMember("properties");
              Object.assign(n2.extendedProperties, e2), t2.updateProperty = function(e3, t3, n3) {
                const r3 = e3;
                if (!t3 || t3.readOnly)
                  return;
                if (t3.allowedValues) {
                  let e4 = false;
                  for (let r4 = 0; r4 < t3.allowedValues.length; r4++)
                    if (t3.allowedValues[r4] === n3) {
                      e4 = true;
                      break;
                    }
                  if (!e4) {
                    const e5 = JSON.stringify(t3.allowedValues).replace(/\[|\]/gi, "").replace(",", ", ").replace(/"/gi, "'"), o4 = "'" + n3 + "'", i3 = r3.localize("propertyInvalidValue", { name: t3.name, actualValue: o4, value: e5 });
                    return void r3.log(i3);
                  }
                }
                const o3 = t3.name, i2 = r3._properties[o3].value;
                if (t3.validator && r3[t3.validator]) {
                  const e4 = r3.context;
                  r3.context = r3;
                  const o4 = r3[t3.validator](i2, n3);
                  void 0 !== o4 && (n3 = o4), r3.context = e4;
                }
                if (i2 !== n3) {
                  if (r3.propertyChanging) {
                    const e4 = r3.propertyChanging(o3, i2, n3);
                    if (false === e4 || null === e4)
                      return;
                  }
                  if (!t3.hasOwnProperty("type")) {
                    const e4 = r3.localize("propertyUnknownType", { name: o3 });
                    r3.log(e4);
                  }
                  if ("array" !== t3.type || JSON.stringify(i2) !== JSON.stringify(n3)) {
                    if (null != n3 && "any" !== t3.type && "propertyObject" !== t3.type && t3.type !== y.Types.getType(n3) && !t3.validator || null === n3 && !t3.nullable) {
                      let e4 = true;
                      if ("object" === t3.type && "array" === y.Types.getType(n3) && (e4 = false), "number" === y.Types.getType(n3) && ["integer", "int", "float"].findIndex((e5) => e5 === t3.type) >= 0 && (e4 = false), e4) {
                        const e5 = r3.localize("propertyInvalidValueType", { name: o3, actualType: y.Types.getType(n3), type: t3.type });
                        return void r3.error(e5);
                      }
                    }
                    if (t3.isUpdating = true, t3.isHierarchicalProperty) {
                      const e4 = function(t4, n4) {
                        if (!t4)
                          return;
                        const o4 = Object.keys(t4);
                        for (let i3 = 0; i3 < o4.length; i3++) {
                          const s2 = o4[i3], a2 = t4[s2];
                          "object" == typeof a2 && !y.Types.isArray(a2) && a2 && a2.constructor !== Date ? e4(a2, n4 + "_" + s2) : r3[n4 + "_" + s2] = a2;
                        }
                      };
                      e4(n3, o3);
                    } else
                      r3._properties[o3].value = n3;
                    if (!t3.isUpdatingFromAttribute && t3.reflectToAttribute && r3.$.setAttributeValue(t3.attributeName, n3, t3.type), r3.isReady && (!r3.ownerElement || r3.ownerElement && r3.ownerElement.isReady)) {
                      if ("wait" === o3 && (n3 || !i2 || r3.isCompleted || (r3.classList.remove("smart-visibility-hidden"), r3.ownerElement && r3.ownerElement.updateBoundMappedNodes(), r3.updateBoundMappedNodes(), r3.complete())), "renderMode" === o3)
                        return;
                      if (r3.context !== r3 && !r3.wait) {
                        const e5 = r3.context;
                        r3.context = r3, r3.propertyChangedHandler(o3, i2, n3), r3.context = e5, t3.observer && r3[t3.observer] && (r3.context = r3, r3[t3.observer](i2, n3), r3.context = document), r3._watch && r3._watch.properties.indexOf(o3) >= 0 && r3._watch.propertyChangedCallback(o3, i2, n3);
                      }
                      const e4 = t3.notify || r3.boundProperties[o3];
                      e4 && (r3.$.fireEvent(t3.attributeName + "-changed", { context: r3.context, oldValue: i2, value: r3[o3] }), r3.boundProperties[o3] && r3.updateBoundNodes(o3)), e4 && r3.templateProperties && r3.templateProperties[o3] && r3.refreshTemplate(), r3.dataContextProperties && ("dataContext" === o3 ? r3.applyDataContext() : r3.dataContextProperties[o3] && r3.updateDataContextProperty(o3));
                    }
                    t3.isUpdating = false;
                  }
                }
              };
              for (let t3 = 0; t3 < r2.length; t3 += 1) {
                const i2 = r2[t3], s2 = e2[i2], a2 = y.Core.toDash(i2), l2 = s2.type || "any", d2 = l2.indexOf("?") >= 0 || "any" === l2;
                d2 && "any" !== l2 && (s2.type = l2.substring(0, l2.length - 1)), s2.nullable = d2, s2.attributeName = a2.toLowerCase(), s2.name = i2, s2.reflectToAttribute = void 0 === s2.reflectToAttribute || s2.reflectToAttribute, s2.inherit && o2[i2] && (s2.value = o2[i2].value), s2.extend && o2[i2] && y.Core.assign(s2.value, o2[i2].value), n2.hasOwnProperty(i2) || Object.defineProperty(n2, i2, { configurable: false, enumerable: true, get() {
                  if (this._properties[i2])
                    return this._properties[i2].value;
                }, set(e3) {
                  const t4 = this;
                  t4.updateProperty(t4, t4._properties[i2], e3);
                } });
              }
            }
          }
          let C = [], S = [], x = [], E = false;
          const A = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
          A && parseInt(A[2], 10) <= 50 && (E = true);
          class P {
            static register(e2, t2) {
              const r2 = t2.prototype;
              let o2 = a.toCamelCase(e2).replace(/[a-z]+/, ""), i2 = t2.version || window[n].Version;
              if (window.customElements.get(e2) && window.customElements.get(e2).version === i2)
                return;
              let s2 = e2;
              for (i2 = i2.split("."); window.customElements.get(e2); )
                e2 = s2 + "-" + i2.join("."), i2[2] = parseInt(i2[2]) + 1;
              if (!C[e2]) {
                if (e2.startsWith(n.toLowerCase()))
                  C[e2] = window[n][o2] = window[n.toLowerCase() + o2] = t2;
                else {
                  let r3 = e2.split("-")[0];
                  r3 = r3.substring(0, 1).toUpperCase() + r3.substring(1), window[n][r3] || (window[n][r3] = {}), C[e2] = window[n][r3][o2] = window[r3.toLowerCase() + o2] = t2, window[n][o2] && (o2 = a.toCamelCase(e2)), window[n][o2] = t2;
                }
                r2.elementName = o2, r2.defineElement(), S[e2] && S[e2](r2), window.customElements.define(e2, t2);
              }
            }
            static registerElements() {
              const e2 = this;
              if (e2.toRegister) {
                e2.isRegistering = true;
                for (let t2 = 0; t2 < e2.toRegister.length; t2++) {
                  const n2 = e2.toRegister[t2];
                  e2.register(n2.tagName, n2.element);
                }
                e2.isRegistering = false;
              }
            }
            static get(e2) {
              if (C[e2])
                return C[e2];
            }
            static whenRegistered(e2, t2) {
              if (!e2)
                throw new Error("Syntax Error: Invalid tag name");
              const n2 = S[e2], r2 = this.get(e2), o2 = r2 ? r2.modules.length : 3;
              try {
                n2 || r2 ? !n2 && r2 ? (t2(r2.prototype), S[e2] = void 0) : n2 && !r2 ? S[e2] = function(e3) {
                  n2(e3), t2(e3);
                } : n2 && r2 && (r2.proto && (n2(r2.proto), t2(r2.proto)), S[e2] = void 0) : S[e2] = function(e3) {
                  try {
                    t2(e3);
                  } catch (e4) {
                    const t3 = e4 instanceof Error ? e4.message : e4.toString();
                    console.log(t3);
                  }
                };
              } catch (e3) {
                const t3 = e3 instanceof Error ? e3.message : e3.toString();
                console.log(t3);
              }
              if (r2 && o2 !== r2.prototype.modules.length) {
                const t3 = document.querySelectorAll(e2);
                for (let e3 = 0; e3 < t3.length; e3++) {
                  const n3 = t3[e3];
                  n3.isCreated && n3._initElement();
                }
              }
            }
          }
          P.lazyRegister = false, P.tagNames = [];
          class T {
            constructor() {
              const e2 = this;
              e2.name = "observableArray", e2.observables = arguments.length < 3 ? null : arguments[2];
              const t2 = new Proxy(e2, { deleteProperty: function(e3, t3) {
                return delete e3[t3], true;
              }, apply: function(e3, t3, n2) {
                return e3.apply(t3, n2);
              }, get: function(t3, n2) {
                return "symbol" == typeof (r2 = n2) || "object" == typeof r2 && "[object Symbol]" === Object.prototype.toString.call(r2) || t3[n2] || isNaN(parseInt(n2)) ? t3[n2] : e2.getItem(parseInt(n2));
                var r2;
              }, set: function(t3, n2, r2) {
                return t3[n2] || isNaN(parseInt(n2)) ? (t3[n2] = r2, true) : (e2.setItem(parseInt(n2), r2), true);
              } });
              if (e2._addArgs = { eventName: "change", object: t2, action: "add", index: null, removed: new Array(), addedCount: 1 }, e2._removeArgs = { eventName: "change", object: t2, action: "remove", index: null, removed: null, addedCount: 0 }, arguments.length >= 1 && Array.isArray(arguments[0])) {
                e2._array = [];
                const t3 = arguments[0];
                for (let n2 = 0, r2 = t3.length; n2 < r2; n2++) {
                  const r3 = e2._getItem(e2._array.length, t3[n2]);
                  e2._array.push(r3);
                }
              } else
                e2._array = Array.apply(null, arguments);
              return 2 === arguments.length && (e2.notifyFn = arguments[1]), t2;
            }
            get canNotify() {
              const e2 = this;
              return void 0 === e2._canNotify && (e2._canNotify = true), e2._canNotify;
            }
            set canNotify(e2) {
              this._canNotify = e2;
            }
            _notify(e2) {
              const t2 = this;
              t2.canNotify && t2.notifyFn && t2.notifyFn(e2);
            }
            notify(e2) {
              e2 && (this.notifyFn = e2);
            }
            toArray() {
              return this._array;
            }
            _getItem(e2, t2) {
              const n2 = this;
              return "string" == typeof t2 || "number" == typeof t2 || void 0 === t2 ? t2 : new Proxy(t2, { deleteProperty: function(e3, t3) {
                return delete e3[t3], true;
              }, set: function(t3, r2, o2) {
                const i2 = t3[r2];
                return t3[r2] = o2, !n2._canNotify || false === t3.canNotify || (n2.observables && !n2.observables[r2] || n2._notify({ eventName: "change", object: n2, target: t3, action: "update", index: e2, path: e2 + "." + r2, oldValue: i2, newValue: o2, propertyName: r2 }), true);
              } });
            }
            getItem(e2) {
              return this._array[e2];
            }
            setItem(e2, t2) {
              const n2 = this, r2 = n2._array[e2];
              n2._array[e2] = n2._getItem(e2, t2), n2._notify({ eventName: "change", object: n2._array, action: "update", index: e2, removed: [r2], addedCount: 1 });
            }
            get length() {
              return this._array.length;
            }
            set length(e2) {
              const t2 = this;
              o.isNumber(e2) && t2._array && t2._array.length !== e2 && t2.splice(e2, t2._array.length - e2);
            }
            toString() {
              return this._array.toString();
            }
            toLocaleString() {
              return this._array.toLocaleString();
            }
            concat() {
              const e2 = this;
              e2._addArgs.index = e2._array.length;
              const t2 = e2._array.concat.apply(e2._array, arguments);
              return new Smart.ObservableArray(t2);
            }
            join(e2) {
              return this._array.join(e2);
            }
            pop() {
              const e2 = this;
              e2._removeArgs.index = e2._array.length - 1, delete e2[e2._array.length - 1];
              const t2 = e2._array.pop();
              return e2._removeArgs.removed = [t2], e2._notify(e2._removeArgs), e2._notifyLengthChange(), t2;
            }
            push() {
              const e2 = this;
              if (e2._addArgs.index = e2._array.length, 1 === arguments.length && Array.isArray(arguments[0])) {
                const t2 = arguments[0];
                for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
                  const r3 = e2._getItem(e2._array.length, t2[n2]);
                  e2._array.push(r3);
                }
              } else {
                const t2 = e2._getItem(e2._addArgs.index, arguments[0]);
                e2._array.push.apply(e2._array, [t2]);
              }
              return e2._addArgs.addedCount = e2._array.length - e2._addArgs.index, e2._notify(e2._addArgs), e2._notifyLengthChange(), e2._array.length;
            }
            _notifyLengthChange() {
              const e2 = this;
              if (!e2.canNotify)
                return;
              const t2 = e2._createPropertyChangeData("length", e2._array.length);
              e2._notify(t2);
            }
            _createPropertyChangeData(e2, t2, n2) {
              return { eventName: "change", object: this, action: e2, value: t2, oldValue: n2 };
            }
            reverse() {
              return this._array.reverse();
            }
            shift() {
              const e2 = this, t2 = e2._array.shift();
              return e2._removeArgs.index = 0, e2._removeArgs.removed = [t2], e2._notify(e2._removeArgs), e2._notifyLengthChange(), t2;
            }
            slice(e2, t2) {
              return this._array.slice(e2, t2);
            }
            sort(e2) {
              return this._array.sort(e2);
            }
            splice(e2, t2, n2) {
              const r2 = this, o2 = r2._array.length;
              let i2;
              if (n2 && n2.length)
                for (let o3 = 0; o3 < n2.length; o3++)
                  i2 = r2._array.splice(e2 + o3, t2, n2[o3]);
              else
                i2 = r2._array.splice.apply(r2._array, arguments);
              if (n2) {
                let t3 = r2.canNotify;
                if (r2.canNotify = false, n2.length)
                  for (let t4 = 0; t4 < n2.length; t4++)
                    r2.setItem(e2 + t4, n2[t4]);
                else
                  r2.setItem(e2, n2);
                r2.canNotify = t3, r2._notify({ eventName: "change", object: this, action: "add", index: e2, added: i2, addedCount: r2._array.length > o2 ? r2._array.length - o2 : 0 });
              } else
                r2._notify({ eventName: "change", object: this, action: "remove", index: e2, removed: i2, addedCount: r2._array.length > o2 ? r2._array.length - o2 : 0 });
              return r2._array.length !== o2 && r2._notifyLengthChange(), i2;
            }
            unshift() {
              const e2 = this, t2 = e2._array.length, n2 = e2._array.unshift.apply(e2._array, arguments);
              return e2._addArgs.index = 0, e2._addArgs.addedCount = n2 - t2, e2._notify(this._addArgs), e2._notifyLengthChange(), n2;
            }
            indexOf(e2, t2) {
              const n2 = this;
              for (let r2 = t2 || 0, o2 = n2._array.length; r2 < o2; r2++)
                if (n2._array[r2] === e2)
                  return r2;
              return -1;
            }
            lastIndexOf(e2, t2) {
              const n2 = this;
              for (let r2 = t2 || n2._array.length - 1; r2 >= 0; r2--)
                if (n2._array[r2] === e2)
                  return r2;
              return -1;
            }
            find(e2, t2) {
              return this._array.find(e2, t2);
            }
            findIndex(e2, t2) {
              return this._array.findIndex(e2, t2);
            }
            every(e2, t2) {
              return this._array.every(e2, t2);
            }
            some(e2, t2) {
              return this._array.some(e2, t2);
            }
            forEach(e2, t2) {
              this._array.forEach(e2, t2);
            }
            map(e2, t2) {
              return this._array.map(e2, t2);
            }
            filter(e2, t2) {
              return this._array.filter(e2, t2);
            }
            reduce(e2, t2) {
              return void 0 !== t2 ? this._array.reduce(e2, t2) : this._array.reduce(e2);
            }
            reduceRight(e2, t2) {
              return void 0 !== t2 ? this._array.reduceRight(e2, t2) : this._array.reduceRight(e2);
            }
            move(e2, t2) {
              this.splice(t2, 0, this.splice(e2, 1)[0]);
            }
          }
          let D = {};
          window[n] && (D = window[n]), window[n] = function(e2, t2) {
            let r2 = e2;
            if (e2) {
              if (e2.indexOf("#") >= 0 || e2.indexOf(".") >= 0)
                return u[e2] ? u[e2] : t2 ? (u[e2] = new t2(), function(e3, t3) {
                  const n2 = t3.properties;
                  t3._properties = [];
                  const r3 = function(n3, o3) {
                    const i2 = Object.keys(n3);
                    for (let s2 = 0; s2 < i2.length; s2++) {
                      const a2 = i2[s2], l2 = n3[a2];
                      t3._properties[o3 + a2] = l2, Array.isArray(l2) ? t3._properties[o3 + a2] = new T(l2, function(t4) {
                        const n4 = a2 + "." + t4.path, r4 = t4.newValue, o4 = document.querySelector(e3);
                        if (o4) {
                          const e4 = n4.split(".");
                          let t5 = o4;
                          for (let n5 = 0; n5 < e4.length; n5++)
                            t5 = t5[e4[n5]];
                          t5 = r4;
                        }
                      }) : (Object.defineProperty(n3, a2, { configurable: false, enumerable: true, get: () => t3._properties[o3 + a2], set(e4) {
                        t3._properties[o3 + a2] = e4;
                      } }), l2 && "DataAdapter" === l2.constructor.name || l2 && "object" == typeof l2 && Smart.DataAdapter && l2 instanceof Smart.DataAdapter || "object" == typeof l2 && l2 && Object.keys(l2).length > 0 && r3(l2, o3 + a2 + "."));
                    }
                  };
                  r3(n2, ""), Object.defineProperty(t3, "properties", { configurable: false, enumerable: true, get: () => n2 });
                  const o2 = document.querySelector(e3);
                  if (o2 && o2.isReady)
                    for (let e4 in n2)
                      if ("properties" === e4) {
                        const t4 = n2[e4];
                        for (let e5 in t4)
                          o2[e5] = t4[e5];
                      } else
                        o2[e4] = n2[e4];
                  else if (o2) {
                    o2.props = {};
                    for (let e4 in n2)
                      o2.props[e4] = n2[e4];
                  }
                }(e2, u[e2]), u[e2]) : void 0;
              if (t2) {
                if (P.tagNames[e2] = t2, P.lazyRegister) {
                  P.toRegister || (P.toRegister = []);
                  const e3 = a.toCamelCase(r2).replace(/[a-z]+/, "");
                  return window[n][e3] = t2, void P.toRegister.push({ tagName: r2, element: t2 });
                }
                P.register(r2, t2);
              }
            }
          }, window.addEventListener("load", function() {
            const e2 = window[n].Elements.tagNames;
            let t2 = [];
            for (let r2 in e2) {
              const o2 = e2[r2];
              let i2 = document.querySelectorAll("[" + r2 + "]");
              for (let e3 = 0; e3 < i2.length; e3++) {
                const t3 = i2[e3];
                t3 instanceof HTMLDivElement && (t3.__proto__ = o2.prototype, t3.created(), t3.connectedCallback()), t3.classList.add("smart-element-ready");
              }
              let s2 = o2.name;
              "Item" === s2 && (s2 = "ListItem"), i2 = document.querySelectorAll('[is="' + n.toLocaleLowerCase() + s2 + '"]');
              for (let e3 = 0; e3 < i2.length; e3++)
                t2.push(i2[e3]);
            }
            if (t2.length > 0) {
              const e3 = (e4) => {
                let t3 = [], n2 = e4.parentNode;
                for (; n2 && 9 !== n2.nodeType; )
                  n2 instanceof HTMLElement == 1 && t3.push(n2), n2 = n2.parentNode;
                return t3;
              };
              t2.sort(function(t3, n2) {
                let r2 = e3(t3).length, o2 = e3(n2).length;
                return r2 < o2 ? 1 : r2 > o2 ? -1 : 0;
              });
              for (let e4 = 0; e4 < t2.length; e4++) {
                const n2 = t2[e4], r2 = n2.getAttribute("is");
                let o2;
                o2 = "smartItem" === r2 ? new window.smartListItem(n2) : new window[r2](n2), o2.removeAttribute("is");
              }
            }
          });
          const L = function() {
            if ("complete" === document.readyState && "manual" !== window[n].RenderMode) {
              x.sort(function(e2, t2) {
                let n2 = e2.element.parents.length, r2 = t2.element.parents.length;
                return n2 < r2 ? -1 : n2 > r2 ? 1 : 0;
              });
              for (let e2 = 0; e2 < x.length; e2++)
                window[n].RenderMode = "", x[e2].element.isLoading = false, x[e2].callback(), window[n].RenderMode = "";
              x = [], document.removeEventListener("readystatechange", L);
            }
          };
          Object.assign(window[n], { Elements: P, Modules: [], BaseElement: class extends _ {
            static get observedAttributes() {
              let e2 = this, t2 = ["external-style"];
              for (let n2 in e2.prototype.extendedProperties) {
                const r2 = e2.prototype.extendedProperties[n2];
                t2.push(r2.attributeName);
              }
              return t2;
            }
            static get styleUrls() {
              return [];
            }
            static get styles() {
              return "";
            }
            get styleUrl() {
              return this._styleUrl;
            }
            set styleUrl(e2) {
              this._styleUrl = e2;
            }
            get isInShadowDOM() {
              const e2 = this, t2 = e2.getRootNode();
              return !e2.hasAttribute("smart-blazor") && t2 !== document && t2 !== e2;
            }
            getShadowRootOrBody() {
              const e2 = this;
              return e2.isInShadowDOM && e2.getRootNode().host ? e2.getRootNode().host.shadowRoot : document.body;
            }
            get enableShadowDOM() {
              return window[n].EnableShadowDOM;
            }
            importStyle(e2, t2) {
              this._importStyle(e2, t2);
            }
            _importStyle(e2, t2) {
              const n2 = this;
              if (!n2.shadowRoot || !e2)
                return;
              const r2 = (e3) => {
                const r3 = n2.shadowRoot.children;
                for (let n3 = 0; n3 < r3.length; n3++) {
                  const o4 = r3[n3];
                  if (o4 instanceof HTMLLinkElement && o4.href === e3)
                    return t2 && t2(), null;
                }
                const o3 = document.createElement("link");
                return o3.rel = "stylesheet", o3.type = "text/css", o3.href = e3, o3.onload = t2, o3;
              }, o2 = (() => {
                const e3 = n2.shadowRoot.children;
                let t3 = null;
                for (let n3 = 0; n3 < e3.length; n3++) {
                  const r3 = e3[n3];
                  r3 instanceof HTMLLinkElement && (t3 = r3);
                }
                return t3;
              })(), i2 = (e3, t3) => {
                t3.parentNode.insertBefore(e3, t3.nextSibling);
              };
              if (Array.isArray(e2)) {
                const t3 = document.createDocumentFragment();
                for (let n3 = 0; n3 < e2.length; n3++) {
                  const o3 = r2(e2[n3]);
                  o3 && t3.appendChild(o3);
                }
                o2 ? i2(t3, o2) : n2.shadowRoot.insertBefore(t3, n2.shadowRoot.firstChild);
              } else {
                const t3 = r2(e2);
                if (!t3)
                  return;
                o2 ? i2(t3, o2) : n2.shadowRoot.insertBefore(t3, n2.shadowRoot.firstChild);
              }
            }
            attributeChanged(e2, t2, n2) {
              "style-url" === e2 && (this.styleUrl = n2);
            }
            attributeChangedCallback(e2, t2, n2) {
              this.isReady && super.attributeChangedCallback(e2, t2, n2);
            }
            constructor(e2, t2) {
              super();
              const n2 = this;
              if (e2) {
                t2 && (n2._initProperties = t2);
                const r2 = (e3) => {
                  if ("string" == typeof e3 ? document.querySelector(e3) : e3) {
                    const r3 = "string" == typeof e3 ? document.querySelector(e3) : e3;
                    if (r3 instanceof HTMLDivElement) {
                      const o2 = document.createElement(n2.tagName);
                      for (let e4 of r3.attributes)
                        o2.setAttribute(e4.name, r3.getAttribute(e4.name));
                      for (; r3.childNodes.length; )
                        o2.appendChild(r3.firstChild);
                      return "string" == typeof e3 && (o2.id = e3.substring(1)), o2._initProperties = t2, r3.parentNode && r3.parentNode.replaceChild(o2, r3), o2;
                    }
                    if (t2) {
                      const e4 = r3.context;
                      if (r3._initProperties = t2, r3.isReady) {
                        r3.context = r3;
                        const n3 = {}, o2 = {};
                        for (let e5 in t2)
                          n3[e5] = r3[e5], o2[e5] = t2[e5];
                        Object.getOwnPropertyNames(t2).length > 0 && (r3.initProperties(), r3.propertyChangedHandler(t2, n3, o2)), r3.context = e4;
                      }
                    }
                    return r3;
                  }
                };
                if ("string" == typeof e2) {
                  const t3 = document.querySelectorAll(e2), n3 = [];
                  if (t3.length > 1) {
                    for (let e3 = 0; e3 < t3.length; e3++) {
                      const o2 = r2(t3[e3]);
                      n3.push(o2);
                    }
                    return n3;
                  }
                } else if (e2 && e2.length > 0) {
                  const t3 = e2;
                  if (t3.length > 1) {
                    for (let e3 = 0; e3 < t3.length; e3++) {
                      const n3 = r2(t3[e3]);
                      C.push(n3);
                    }
                    return C;
                  }
                }
                return r2(e2);
              }
              n2._styleUrl = "", n2.isUtilityElement || n2.created();
            }
            _getRootShadowParent() {
              let e2 = this.shadowParent;
              for (; e2; ) {
                if (!e2.shadowParent)
                  return e2;
                e2 = e2.shadowParent;
              }
              return e2 || this.shadowParent;
            }
            _getStyleUrl(e2) {
              let t2 = y.Core.getScriptLocation() + window[n].StyleBaseUrl + e2;
              return this.shadowParent && (t2 = t2.replace("scoped/", "")), t2;
            }
            _getStyleUrls() {
              const e2 = this;
              e2.nodeName.startsWith(n);
              const t2 = e2.getStaticMember("styleUrls", "array"), r2 = [];
              for (let n2 = 0; n2 < t2.length; n2++) {
                const o2 = t2[n2], i2 = e2._getStyleUrl(o2);
                r2.push(i2);
              }
              return r2;
            }
            _setupShadowRoot() {
              const e2 = this;
              e2.classList.add("smart-element-init");
              const t2 = (t3) => {
                t3.$.root && (t3.$.root.classList.add(n.toLowerCase() + "-element"), t3.$.root.classList.add(e2.nodeName.toLowerCase())), t3.setup(), t3.classList.remove("smart-element-init");
              };
              if (document.adoptedStyleSheets)
                if (window[n].AdoptedStyleSheets)
                  window[n].AdoptedStyleSheetsLoaded ? (e2.shadowRoot.adoptedStyleSheets = window[n].AdoptedStyleSheets, t2(e2)) : (e2.shadowRoot.adoptedStyleSheets = window[n].AdoptedStyleSheets, window[n].AdoptedStyleSheetsLoadedQueue || (window[n].AdoptedStyleSheetsLoadedQueue = []), window[n].AdoptedStyleSheetsLoadedQueue.push(e2));
                else {
                  const r2 = new CSSStyleSheet();
                  let o2 = y.Core.getScriptLocation() + "/styles/smart.default.css";
                  r2.replace('@import url("' + o2 + '")').then(() => {
                    if (t2(e2), window[n].AdoptedStyleSheetsLoaded = true, window[n].AdoptedStyleSheetsLoadedQueue) {
                      const e3 = window[n].AdoptedStyleSheetsLoadedQueue;
                      for (let n2 = 0; n2 < e3.length; n2++) {
                        const r3 = e3[n2];
                        t2(r3);
                      }
                      delete window[n].AdoptedStyleSheetsLoadedQueue;
                    }
                  }).catch((e3) => {
                    console.error("Failed to load:", e3);
                  }), window[n].AdoptedStyleSheets = [r2], document.adoptedStyleSheets = [r2], e2.shadowRoot.adoptedStyleSheets = window[n].AdoptedStyleSheets;
                }
            }
            connect() {
              const e2 = this;
              window[n].EnableShadowDOM && !e2.shadowRoot && true !== e2.isInShadowDOM && (e2.attachShadow({ mode: "open" }), e2.shadowRoot && e2.$.root && (e2.shadowRoot.appendChild(e2.$.root), e2.$.root.classList.add(e2.nodeName.toLowerCase()))), e2.shadowRoot || e2.shadowParent ? e2.shadowRoot ? e2._setupShadowRoot() : (e2.shadowParent && window[n].EnableShadowDOM, e2.setup()) : e2.setup();
            }
            connectedCallback() {
              const e2 = this;
              if (e2.isLoading || e2.isUtilityElement)
                return;
              e2.classList.add("smart-element-init");
              const t2 = function() {
                e2.classList.remove("smart-element-init");
              };
              if ("complete" === document.readyState && (void 0 === window[n].isAngular && (window[n].isAngular = null !== document.body.querySelector("[ng-version]")), void 0 === window[n].isVue && (window[n].isVue = null !== document.querySelector(".vue-root")), window[n].isAngular)) {
                for (let t3 = 0; t3 < e2.parents.length && !e2.parents[t3].nodeName.toLowerCase().startsWith(n.toLowerCase() + "-"); t3++)
                  if (e2.parents[t3].hasAttribute("ng-version") && !e2.classList.contains("smart-angular")) {
                    window[n].RenderMode = "manual";
                    break;
                  }
              }
              if ("complete" === document.readyState && "manual" !== window[n].RenderMode) {
                const n2 = e2.parents;
                n2.length && "HTML" === n2[n2.length - 1].nodeName || e2.getRootNode().host ? (e2.checkIsInDomTimer && clearInterval(e2.checkIsInDomTimer), t2(), e2.connect()) : (e2.checkIsInDomTimer && clearInterval(e2.checkIsInDomTimer), n2.length > 0 && (e2.checkIsInDomTimer = setInterval(() => {
                  const n3 = e2.parents;
                  0 === n3.length && clearInterval(e2.checkIsInDomTimer), n3.length > 0 && "HTML" === n3[n3.length - 1].nodeName && (clearInterval(e2.checkIsInDomTimer), t2(), e2.connect());
                }, 100)));
              } else
                e2.isLoading = true, x.push({ element: this, callback: (function() {
                  this.isReady || (t2(), this.connect());
                }).bind(e2) });
            }
            disconnectedCallback() {
              const e2 = this;
              e2.isAttached ? (e2.shadowParent = null, e2.detached()) : e2._resetShadowParent();
            }
            adoptedCallback() {
              this.setup();
            }
            appendTemplate(e2) {
              const t2 = this;
              t2.shadowRoot ? t2.shadowRoot.appendChild(e2) : t2.appendChild(e2);
            }
            _resetShadowParent() {
              const e2 = this;
              if (!window[n].EnableShadowDOM || null === e2.shadowParent)
                return;
              const t2 = [];
              let r2 = e2.parentNode;
              for (; r2 && 9 !== r2.nodeType; ) {
                if (r2 instanceof HTMLElement == 1)
                  t2.push(r2);
                else if (11 === r2.nodeType && r2.host) {
                  r2 = r2.host;
                  continue;
                }
                r2 = r2.parentNode;
              }
              for (let n2 = 0; n2 < t2.length; n2++)
                if (t2[n2] === e2.shadowParent)
                  return;
              t2.length > 0 && "HTML" === t2[t2.length - 1].nodeName && (e2.shadowParent = null);
            }
          }, Utilities: y, Import: function(e2, t2) {
            let n2 = 0;
            const r2 = function(e3, t3) {
              return new Promise((n3) => {
                const r3 = document.createElement("script");
                r3.src = e3, r3.onload = n3;
                for (let e4 = 0; e4 < document.head.children.length; e4++) {
                  const r4 = document.head.children[e4];
                  if (r4.src && r4.src.toString().indexOf(t3) >= 0)
                    return void n3();
                }
                document.head.appendChild(r3);
              });
            };
            return new Promise((o2) => {
              const i2 = y.Core.getScriptLocation(), s2 = function(t3) {
                if (!e2[t3])
                  return;
                const a2 = i2 + "/" + e2[t3];
                r2(a2, e2[t3]).then(function() {
                  n2++, n2 === e2.length && o2(), s2(t3 + 1);
                });
              };
              if (t2)
                for (let t3 = 0; t3 < e2.length; t3++) {
                  const s3 = i2 + "/" + e2[t3];
                  r2(s3, e2[t3]).then(function() {
                    n2++, n2 === e2.length && o2();
                  });
                }
              else
                s2(0);
            });
          }, ObservableArray: T, Observable: class {
            constructor(e2, t2) {
              const n2 = this;
              var r2;
              return this.name = "observable", e2 && Object.assign(n2, e2), r2 = e2, Object.getOwnPropertyNames(Object.getPrototypeOf(r2)).forEach((e3) => "constructor" === e3 || !!e3.startsWith("_") || void (n2[e3] = r2[e3])), new Proxy(n2, { deleteProperty: function(e3, t3) {
                return delete e3[t3], true;
              }, get: function(e3, t3) {
                return e3[t3];
              }, set: function(e3, r3, o2) {
                const i2 = e3[r3];
                return i2 === o2 || (e3[r3] = o2, !("notifyFn" !== r3 && !r3.startsWith("_") && "canNotify" !== r3 && (!t2 || -1 !== t2.indexOf(r3)) && n2.canNotify && (n2._notify({ target: e3, propertyName: r3, oldValue: i2, newValue: o2 }), 0)));
              } });
            }
            get canNotify() {
              const e2 = this;
              return void 0 === e2._canNotify && (e2._canNotify = true), e2._canNotify;
            }
            set canNotify(e2) {
              this._canNotify = e2;
            }
            _notify(e2) {
              const t2 = this;
              if (t2.canNotify && t2.notifyFn)
                for (let n2 = 0; n2 < t2.notifyFn.length; n2++)
                  t2.notifyFn[n2](e2);
            }
            notify(e2) {
              const t2 = this;
              e2 && (t2.notifyFn || (t2.notifyFn = []), t2.notifyFn.push(e2));
            }
          }, Component: class {
            constructor(e2, t2) {
              const n2 = this.name;
              let r2 = null;
              return e2 ? r2 = new window[n2](e2, t2) : (r2 = new window[n2](), r2._initProperties = t2), this._element = r2, r2;
            }
            get name() {
              return "Component";
            }
            get element() {
              return this._element;
            }
          }, Theme: D.Theme || "", EnableShadowDOM: D.ShadowDom || false, BaseUrl: "./", StyleBaseUrl: "/styles/default/", Version: e, Templates: t, RenderMode: D.RenderMode || "auto", Render: function() {
            const e2 = () => {
              window[n].RenderMode = "", L();
            };
            "complete" === document.readyState ? e2() : (window.removeEventListener("load", e2), window.addEventListener("load", e2));
          }, Data: u, Mode: D.Mode || "production", License: D.License || "Evaluation" });
          let O = window[n].Theme;
          "manual" !== window[n].RenderMode && document.addEventListener("readystatechange", L), Object.defineProperty(window[n], "Theme", { configurable: false, enumerable: true, get: () => O, set(e2) {
            const t2 = O;
            O = e2, w.fireEvent("theme-changed", { oldValue: t2, newValue: e2 }, { bubbles: true, cancelable: true });
          } }), window[n]("smart-base-element", window[n].BaseElement), window[n]("smart-content-element", class extends window[n].BaseElement {
            static get properties() {
              return { content: { type: "any", reflectToAttribute: false }, innerHTML: { type: "string", reflectToAttribute: false } };
            }
            template() {
              return "<div inner-h-t-m-l='[[innerHTML]]'></div>";
            }
            ready() {
              super.ready(), this.applyContent();
            }
            refresh() {
            }
            clearContent() {
              const e2 = this;
              for (; e2.$.content.firstChild; )
                e2.$.content.removeChild(e2.$.content.firstChild);
            }
            applyContent() {
              const e2 = this;
              if (void 0 === e2.content)
                return void (e2.content = e2.$.content);
              if ("" === e2.content || null === e2.content)
                return void e2.clearContent();
              if (e2.content instanceof HTMLElement)
                return e2.clearContent(), void e2.$.content.appendChild(e2.content);
              const t2 = document.createDocumentFragment();
              let n2 = document.createElement("div");
              t2.appendChild(n2), e2.content instanceof HTMLElement ? n2.appendChild(e2.content) : n2.innerHTML = e2.content;
              let r2 = Array.from(n2.childNodes);
              n2.parentNode.removeChild(n2);
              for (let e3 = 0; e3 < r2.length; e3++)
                t2.appendChild(r2[e3]);
              e2.clearContent(), e2.$.content.appendChild(t2);
            }
            propertyChangedHandler(e2, t2, n2) {
              super.propertyChangedHandler(e2, t2, n2);
              const r2 = this;
              t2 !== n2 && ("innerHTML" === e2 && (r2.content = n2, r2.applyContent(), r2.innerHTML = r2.content = y.Core.html(r2.$.content)), "content" === e2 && r2.applyContent());
            }
          }), window[n]("smart-scroll-viewer", class extends window[n].ContentElement {
            static get properties() {
              return { autoRefresh: { type: "boolean", value: false }, horizontalScrollBarVisibility: { type: "string", value: "auto", allowedValues: ["auto", "disabled", "hidden", "visible"] }, touchScrollRatio: { type: "any", value: null }, touchVelocityCoefficient: { type: "number", value: 50 }, verticalScrollBarVisibility: { type: "string", value: "auto", allowedValues: ["auto", "disabled", "hidden", "visible"] } };
            }
            static get listeners() {
              return { touchmove: "_touchmoveHandler", touchstart: "_touchstartHandler", wheel: "_mouseWheelHandler", "document.up": "_upHandler" };
            }
            static get styleUrls() {
              return ["smart.scrollviewer.css"];
            }
            template() {
              return `<div id="container" class="smart-container" role="presentation">
                        <div id="scrollViewerContainer" class="smart-scroll-viewer-container" role="presentation">
                            <div id="scrollViewerContentContainer" inner-h-t-m-l='[[innerHTML]]' class="smart-scroll-viewer-content-container" role="presentation">
                                <content></content>
                            </div>
                        </div>
                        <smart-scroll-bar id="verticalScrollBar" theme="[[theme]]"  animation="[[animation]]" disabled="[[disabled]]" right-to-left="[[rightToLeft]]" orientation="vertical"></smart-scroll-bar>
                        <smart-scroll-bar id="horizontalScrollBar" theme="[[theme]]" disabled="[[disabled]]" right-to-left="[[rightToLeft]]"></smart-scroll-bar>
                    </div>`;
            }
            appendChild(e2) {
              const t2 = this;
              if (e2) {
                if (!t2.isCompleted || e2.classList && e2.classList.contains("smart-resize-trigger-container")) {
                  const e3 = Array.prototype.slice.call(arguments, 2);
                  return HTMLElement.prototype.appendChild.apply(t2, e3.concat(Array.prototype.slice.call(arguments)));
                }
                t2.$.scrollViewerContentContainer.appendChild(e2);
              }
            }
            removeChild(e2) {
              const t2 = this;
              if (e2) {
                if (!t2.isCompleted || e2.classList && e2.classList.contains("smart-resize-trigger-container")) {
                  const e3 = Array.prototype.slice.call(arguments, 2);
                  return HTMLElement.prototype.removeChild.apply(t2, e3.concat(Array.prototype.slice.call(arguments)));
                }
                t2.$.scrollViewerContentContainer.removeChild(e2);
              }
            }
            removeAll() {
              const e2 = this;
              e2.isCompleted && (e2.$.scrollViewerContentContainer.innerHTML = "");
            }
            _horizontalScrollbarHandler(e2) {
              const t2 = this;
              t2.$.scrollViewerContentContainer.style.left = (t2.rightToLeft ? 1 : -1) * t2.scrollLeft + "px", e2.stopPropagation && e2.stopPropagation(), t2.onHorizontalChange && t2.onHorizontalChange(e2);
            }
            _verticalScrollbarHandler(e2) {
              const t2 = this;
              t2.$.scrollViewerContentContainer.style.top = -t2.scrollTop + "px", e2.stopPropagation && e2.stopPropagation(), t2.onVerticalChange && t2.onVerticalChange(e2);
            }
            _touchmoveHandler(e2) {
              const t2 = this;
              if (t2._touchmoveInside && e2.cancelable)
                return e2.preventDefault(), void e2.stopPropagation();
              const n2 = t2.scrollHeight > 0, r2 = t2.scrollWidth > 0, o2 = t2._touchCoords;
              if (!n2 && !r2 || !o2)
                return;
              const i2 = e2.touches[0];
              let s2, a2, l2, d2;
              t2._touchCoords = [i2.pageX, i2.pageY], n2 ? (s2 = t2.scrollTop, a2 = t2.scrollHeight, l2 = i2.pageY, d2 = o2[1]) : (s2 = t2.scrollLeft, a2 = t2.scrollWidth, l2 = i2.pageX, d2 = o2[0]);
              const c2 = parseFloat(l2.toFixed(5)), u2 = parseFloat(d2.toFixed(5));
              0 === s2 && c2 >= u2 || s2 === a2 && c2 <= u2 || (l2 !== d2 && (t2._touchmoveInside = true), e2.cancelable && (e2.preventDefault(), e2.stopPropagation()));
            }
            _touchstartHandler(e2) {
              const t2 = e2.touches[0];
              this._touchCoords = [t2.pageX, t2.pageY];
            }
            _mouseWheelHandler(e2) {
              const t2 = this;
              if (!t2.disabled && (t2.computedHorizontalScrollBarVisibility || t2.computedVerticalScrollBarVisibility)) {
                if (e2.shiftKey && t2.computedHorizontalScrollBarVisibility) {
                  const n2 = t2.scrollLeft;
                  if (0 === n2 && e2.deltaX < 0 || n2 === t2.scrollHeight && e2.deltaX > 0)
                    return;
                  return e2.stopPropagation(), e2.preventDefault(), void (t2.scrollWidth > 0 && t2.scrollTo(void 0, t2.scrollLeft + t2._getScrollCoefficient(e2, t2.offsetWidth)));
                }
                if (t2.computedVerticalScrollBarVisibility) {
                  const n2 = t2.scrollTop;
                  if (0 === n2 && e2.deltaY < 0 || n2 === t2.scrollHeight && e2.deltaY > 0)
                    return;
                  if (e2.stopPropagation(), e2.preventDefault(), t2.scrollHeight > 0) {
                    t2._wheelrafId = 0;
                    const n3 = () => {
                      t2.scrollTop += e2.deltaY;
                    };
                    cancelAnimationFrame(t2._wheelrafId), t2._wheelrafId = 0, t2._wheelrafId = requestAnimationFrame(n3);
                  }
                }
              }
            }
            _overriddenHandler() {
            }
            _upHandler() {
              delete this._touchCoords, delete this._touchmoveInside;
            }
            _getScrollCoefficient(e2, t2) {
              const n2 = e2.deltaMode, r2 = Math.abs(e2.deltaY);
              let o2;
              return 0 === n2 ? o2 = r2 < 100 / 3 ? r2 : t2 : 1 === n2 ? o2 = r2 < 1 ? r2 * (100 / 3) : t2 : 2 === n2 && (o2 = t2), e2.deltaY < 0 ? -o2 : o2;
            }
            applyContent() {
              super.applyContent(), this.refresh();
            }
            get computedHorizontalScrollBarVisibility() {
              const e2 = this;
              return e2._scrollView && e2._scrollView.hScrollBar ? !e2._scrollView.hScrollBar.$.hasClass("smart-hidden") : null;
            }
            get computedVerticalScrollBarVisibility() {
              const e2 = this;
              return e2._scrollView && e2._scrollView.vScrollBar ? !e2._scrollView.vScrollBar.$.hasClass("smart-hidden") : null;
            }
            scrollTo(e2, t2) {
              const n2 = this;
              n2._scrollView && (void 0 !== e2 && n2._scrollView.scrollTo(e2), void 0 !== t2 && n2._scrollView.scrollTo(t2, false));
            }
            refreshScrollBarsVisibility() {
              const e2 = this;
              e2._scrollView && (e2._scrollView.hScrollBar.disabled = e2.disabled, e2._scrollView.vScrollBar.disabled = e2.disabled, "disabled" === e2.horizontalScrollBarVisibility && (e2._scrollView.hScrollBar.disabled = true), "disabled" === e2.verticalScrollBarVisibility && (e2._scrollView.vScrollBar.disabled = true), e2.scrollWidth > 0 ? e2._scrollView.hScrollBar.$.removeClass("smart-hidden") : "visible" !== e2.horizontalScrollBarVisibility && e2._scrollView.hScrollBar.$.addClass("smart-hidden"), e2.scrollHeight > 0 ? e2._scrollView.vScrollBar.$.removeClass("smart-hidden") : "visible" !== e2.verticalScrollBarVisibility && e2._scrollView.vScrollBar.$.addClass("smart-hidden"), "hidden" === e2.horizontalScrollBarVisibility && e2._scrollView.hScrollBar.$.addClass("smart-hidden"), "hidden" === e2.verticalScrollBarVisibility && e2._scrollView.vScrollBar.$.addClass("smart-hidden"), "visible" === e2.horizontalScrollBarVisibility && e2._scrollView.hScrollBar.$.removeClass("smart-hidden"), "visible" === e2.verticalScrollBarVisibility && (e2._scrollView.vScrollBar.$.removeClass("smart-hidden"), e2.disabled || (e2._scrollView.vScrollBar.disabled = e2.scrollHeight <= 0)), e2.computedHorizontalScrollBarVisibility && e2.computedVerticalScrollBarVisibility ? (e2._scrollView.hScrollBar.$.addClass("bottom-corner"), e2._scrollView.vScrollBar.$.addClass("bottom-corner")) : (e2._scrollView.hScrollBar.$.removeClass("bottom-corner"), e2._scrollView.vScrollBar.$.removeClass("bottom-corner")));
            }
            ready() {
              super.ready();
              const e2 = this;
              e2.$.verticalScrollBar.onChange = (t2) => {
                t2.detail = t2, e2._verticalScrollbarHandler(t2);
              }, e2.$.horizontalScrollBar.onChange = (t2) => {
                t2.detail = t2, e2._horizontalScrollbarHandler(t2);
              }, e2.$.verticalScrollBar.setAttribute("aria-controls", e2.id), e2.$.horizontalScrollBar.setAttribute("aria-controls", e2.id), e2._customScrollView || (e2._scrollView = new Smart.Utilities.Scroll(e2, e2.$.horizontalScrollBar, e2.$.verticalScrollBar)), e2.refresh();
            }
            refresh() {
              const e2 = this;
              function t2() {
                const t3 = e2.$.scrollViewerContainer.classList.contains("vscroll");
                e2.$.scrollViewerContainer.classList.remove("vscroll");
                const n3 = e2.$.scrollViewerContentContainer.offsetWidth - e2.$.scrollViewerContainer.offsetWidth;
                return n3 > 0 && "hidden" !== e2.horizontalScrollBarVisibility || "visible" === e2.horizontalScrollBarVisibility ? e2.$.scrollViewerContainer.classList.add("hscroll") : e2.$.scrollViewerContainer.classList.remove("hscroll"), t3 && e2.$.scrollViewerContainer.classList.add("vscroll"), n3;
              }
              function n2() {
                let t3;
                const n3 = e2.$.scrollViewerContainer.classList.contains("hscroll");
                if (e2.$.scrollViewerContainer.classList.remove("hscroll"), Smart.Utilities.Core.Browser.Safari) {
                  const n4 = e2.$.scrollViewerContentContainer.getBoundingClientRect().height, r3 = e2.$.scrollViewerContainer.getBoundingClientRect().height;
                  t3 = n4 && r3 ? parseInt(n4) - parseInt(r3) : e2.$.scrollViewerContentContainer.offsetHeight - e2.$.scrollViewerContainer.offsetHeight;
                } else
                  t3 = e2.$.scrollViewerContentContainer.offsetHeight - e2.$.scrollViewerContainer.offsetHeight;
                return e2.virtualScrollHeight && (t3 = e2.virtualScrollHeight), t3 > 0 && "hidden" !== e2.verticalScrollBarVisibility || "visible" === e2.verticalScrollBarVisibility ? e2.$.scrollViewerContainer.classList.add("vscroll") : e2.$.scrollViewerContainer.classList.remove("vscroll"), n3 && e2.$.scrollViewerContainer.classList.add("hscroll"), t3;
              }
              if (!e2.$.scrollViewerContentContainer)
                return;
              "hidden" === e2.verticalScrollBarVisibility && e2.$.scrollViewerContentContainer.setAttribute("disable-vertical", ""), "hidden" === e2.horizontalScrollBarVisibility && e2.$.scrollViewerContentContainer.setAttribute("disable-horizontal", "");
              let r2 = e2.scrollWidth, o2 = e2.scrollHeight;
              e2.scrollWidth = t2(), e2.scrollHeight = n2(), e2.scrollHeight && o2 === e2.scrollHeight || (e2.scrollWidth = t2()), e2.scrollWidth && r2 === e2.scrollWidth || (e2.scrollHeight = n2()), e2.computedVerticalScrollBarVisibility && (e2.scrollHeight += e2._scrollView.hScrollBar.offsetHeight), e2.computedHorizontalScrollBarVisibility && (e2.scrollWidth += e2._scrollView.vScrollBar.offsetWidth), 0 === e2.scrollHeight && e2.scrollWidth > 0 && e2.$.container.offsetHeight - e2.$.content.offsetHeight < 5 && (e2.$.container.style.paddingBottom = e2._scrollView.hScrollBar.offsetHeight + "px"), e2.autoRefresh && (e2.$.scrollViewerContainer.scrollLeft = 0, e2.$.scrollViewerContainer.scrollTop = 0);
            }
            attached() {
              const e2 = this;
              super.attached(), e2._scrollView || e2._customScrollView || (e2._scrollView = new Smart.Utilities.Scroll(e2, e2.$.horizontalScrollBar, e2.$.verticalScrollBar));
            }
            detached() {
              const e2 = this;
              super.detached(), e2._scrollView && (e2._scrollView.unlisten(), delete e2._scrollView);
            }
            get scrollWidth() {
              const e2 = this;
              return e2._scrollView && e2._scrollView.hScrollBar ? 1 === e2._scrollView.hScrollBar.max && "visible" === e2.horizontalScrollBarVisibility ? 0 : e2._scrollView.hScrollBar.max : -1;
            }
            set scrollWidth(e2) {
              const t2 = this;
              e2 < 0 && (e2 = 0), t2._scrollView && t2._scrollView.hScrollBar && (0 === e2 && "visible" === t2.horizontalScrollBarVisibility ? t2._scrollView.hScrollBar.max = 0 : t2._scrollView.hScrollBar.max = e2, t2.refreshScrollBarsVisibility());
            }
            get scrollHeight() {
              const e2 = this;
              return e2._scrollView && e2._scrollView.vScrollBar ? 1 === e2._scrollView.vScrollBar.max && "visible" === e2.verticalScrollBarVisibility ? 0 : e2._scrollView.vScrollBar.max : 0;
            }
            set scrollHeight(e2) {
              const t2 = this;
              e2 < 0 && (e2 = 0), t2._scrollView && t2._scrollView.vScrollBar && (0 === e2 && "visible" === t2.verticalScrollBarVisibility ? t2._scrollView.vScrollBar.max = 1 : t2._scrollView.vScrollBar.max = e2, t2.refreshScrollBarsVisibility());
            }
            get scrollLeft() {
              const e2 = this;
              return e2._scrollView && e2._scrollView.hScrollBar ? e2._scrollView.hScrollBar.value : 0;
            }
            set scrollLeft(e2) {
              const t2 = this;
              e2 < 0 && (e2 = 0), t2._scrollView && t2._scrollView.hScrollBar && (t2._scrollView.hScrollBar.value = e2);
            }
            get scrollTop() {
              const e2 = this;
              return e2._scrollView && e2._scrollView.vScrollBar ? e2._scrollView.vScrollBar.value : 0;
            }
            set scrollTop(e2) {
              const t2 = this;
              e2 < 0 && (e2 = 0), t2._scrollView && t2._scrollView.vScrollBar && (t2._scrollView.vScrollBar.value = e2);
            }
            propertyChangedHandler(e2, t2, n2) {
              const r2 = this;
              super.propertyChangedHandler(e2, t2, n2), "animation" !== e2 && "theme" !== e2 && r2.refresh();
            }
          }), window[n].Utilities.Assign("PositionDetection", class {
            constructor(e2, t2, n2, r2) {
              const o2 = this;
              if (t2) {
                const n3 = "dropDown" + Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
                t2.id = n3, e2.setAttribute("aria-owns", n3);
              }
              o2.context = e2, o2.dropDown = t2, o2.defaultParent = n2, o2.closeMethod = r2;
            }
            handleAutoPositioning() {
              const e2 = this, t2 = e2.context;
              if ("auto" !== t2.dropDownPosition || t2.disabled || t2.isHidden)
                return;
              const n2 = window.requestAnimationFrame;
              let r2, o2 = Date.now();
              return r2 = n2(function i2() {
                t2.isHidden || document.hidden || (r2 = n2(i2), "auto" === t2.dropDownPosition && !t2.disabled && (t2.isInShadowDOM ? document.body.contains(t2.shadowParent) : document.body.contains(t2)) || cancelAnimationFrame(r2), t2.isHidden && cancelAnimationFrame(r2), Date.now() - o2 >= 200 && (e2.scrollHandler(), o2 = Date.now()));
              });
            }
            checkBrowserBounds(e2) {
              const t2 = this.context;
              if ("auto" === t2.dropDownPosition && !t2.disabled)
                switch (e2) {
                  case "vertically":
                    this.checkBrowserBoundsVertically();
                    break;
                  case "horizontally":
                    this.checkBrowserBoundsHorizontally();
                    break;
                  default:
                    this.checkBrowserBoundsVertically(), this.checkBrowserBoundsHorizontally();
                }
            }
            checkBrowserBoundsHorizontally() {
              const e2 = this.context, t2 = this.dropDown;
              let n2, r2 = 0;
              a.isMobile || window.innerWidth === document.documentElement.clientWidth || (r2 = window.innerWidth - document.documentElement.clientWidth), null !== e2._dropDownParent ? n2 = true : t2.style.left = "";
              const o2 = window.innerWidth - r2;
              let i2 = e2.getBoundingClientRect().left;
              if (i2 < 0 && (t2.style.left = (n2 ? 0 : Math.abs(i2)) + "px", i2 = parseFloat(t2.style.left)), i2 + t2.offsetWidth > o2) {
                let e3 = i2 - Math.abs(o2 - i2 - t2.offsetWidth);
                n2 && (e3 += window.pageXOffset), t2.style.left = (n2 ? e3 : e3 - i2) + "px", window.innerWidth === document.documentElement.clientWidth && (t2.style.left = parseFloat(t2.style.left) + r2 + "px"), n2 && window.innerHeight === document.documentElement.clientHeight && this.positionDropDown(true);
              }
            }
            checkBrowserBoundsVertically(e2) {
              const t2 = this.context, n2 = this.dropDown, r2 = t2._dropDownListPosition;
              e2 || (e2 = t2.getBoundingClientRect()), 0 !== e2.height && (document.documentElement.clientHeight - Math.abs(e2.top + e2.height + n2.offsetHeight) >= 0 ? t2._dropDownListPosition = "bottom" : e2.top - n2.offsetHeight >= 0 ? t2._dropDownListPosition = "top" : t2._dropDownListPosition = "overlay-center", this.updatePositionAttribute(r2, t2._dropDownListPosition));
            }
            scrollHandler() {
              const e2 = this.context;
              if (!e2.parentElement)
                return;
              const t2 = e2.getBoundingClientRect();
              if (t2.top === e2._positionTop)
                return;
              const n2 = e2._dropDownListPosition;
              this.checkBrowserBoundsVertically(t2), e2._dropDownListPosition !== n2 && this.positionDropDown(), e2._positionTop = t2.top;
            }
            getDropDownParent(e2) {
              const t2 = this.context, n2 = this.dropDown;
              let r2 = t2.dropDownAppendTo;
              t2._positionedParent = null, null === r2 ? t2._dropDownParent = null : "body" === r2 || r2 === document.body ? t2.getRootNode().host ? t2._dropDownParent = t2.getRootNode().host.shadowRoot : t2._dropDownParent = document.body : r2 instanceof HTMLElement ? t2._dropDownParent = r2 : "string" == typeof r2 ? (r2 = document.getElementById(r2), r2 instanceof HTMLElement ? t2._dropDownParent = r2 : (t2.dropDownAppendTo = null, t2._dropDownParent = null)) : (t2.dropDownAppendTo = null, t2._dropDownParent = null);
              let o2 = t2._dropDownParent;
              if (null !== o2) {
                for (; o2 && o2 instanceof HTMLElement && "static" === window.getComputedStyle(o2).position && o2 !== t2.getShadowRootOrBody(); )
                  o2 = o2.parentElement;
                o2 === document.body ? t2._positionedParent = null : t2._positionedParent = o2, n2 && (n2.setAttribute("animation", t2.animation), "" !== t2.theme && n2.$.addClass(t2.theme), e2 && (t2._dropDownParent.appendChild(n2), n2.$.addClass("smart-drop-down-repositioned")), -1 === t2.detachedChildren.indexOf(n2) && t2.detachedChildren.push(n2));
              }
            }
            dropDownAppendToChangedHandler() {
              const e2 = this.context, t2 = this.dropDown, n2 = e2._dropDownParent;
              this.getDropDownParent(), e2._dropDownParent !== n2 && (e2[this.closeMethod](), ["left", "top", "font-size", "font-family", "font-style", "font-weight"].forEach((e3) => t2.style[e3] = null), null === e2._dropDownParent ? (this.defaultParent.appendChild(t2), t2.$.removeClass("smart-drop-down-repositioned")) : (e2._dropDownParent.appendChild(t2), t2.$.addClass("smart-drop-down-repositioned")));
            }
            dropDownPositionChangedHandler() {
              const e2 = this;
              e2.dropDown.style.transition = "none", e2.context[e2.closeMethod](), e2.setDropDownPosition(), e2.handleAutoPositioning();
            }
            dropDownAttached(e2) {
              const t2 = this.context;
              null !== t2._dropDownParent && (t2._dropDownParent.appendChild(this.dropDown), this.handleAutoPositioning(), e2 && t2[e2]());
            }
            dropDownDetached() {
              const e2 = this.context;
              null !== e2._dropDownParent && document.body.contains(this.dropDown) && document.body.contains(e2._dropDownParent) && e2._dropDownParent.removeChild(this.dropDown);
            }
            setDropDownPosition() {
              const e2 = this.context, t2 = e2.dropDownPosition, n2 = e2._dropDownListPosition;
              "auto" === t2 ? this.checkBrowserBounds() : e2._dropDownListPosition = t2, this.updatePositionAttribute(n2, e2._dropDownListPosition);
            }
            updatePositionAttribute(e2, t2) {
              const n2 = this.context, r2 = this.dropDown;
              n2.$.dropDownButton && !n2.$.dropDownButton.hasAttribute(t2) && (n2.$.dropDownButton.removeAttribute(e2), n2.$.dropDownButton.setAttribute(t2, "")), r2.hasAttribute(t2) || (r2.style.transition = "none", r2.removeAttribute(e2), r2.setAttribute(t2, ""), requestAnimationFrame(function() {
                r2.style.transition = null;
              }));
            }
            positionDropDown(e2) {
              const t2 = this.context, n2 = this.dropDown;
              if (!t2.opened || null === t2._dropDownParent)
                return;
              const r2 = t2.getBoundingClientRect();
              let o2, i2;
              if (this.customPositionDropDown) {
                const e3 = this.customPositionDropDown(r2);
                o2 = e3.left, i2 = e3.top;
              } else
                switch (o2 = r2.left, i2 = r2.top, t2._dropDownListPosition) {
                  case "bottom":
                    i2 += t2.$.container.offsetHeight - 1;
                    break;
                  case "center-bottom":
                    i2 += t2.$.container.offsetHeight - 1, o2 += t2.offsetWidth - n2.offsetWidth / 2;
                    break;
                  case "center-top":
                    i2 -= n2.offsetHeight - 1, o2 += t2.offsetWidth - n2.offsetWidth / 2;
                    break;
                  case "top":
                    i2 -= n2.offsetHeight - 1;
                    break;
                  case "overlay-bottom":
                    break;
                  case "overlay-center":
                    i2 -= n2.offsetHeight / 2 - t2.offsetHeight / 2;
                    break;
                  case "overlay-top":
                    i2 -= n2.offsetHeight - t2.offsetHeight;
                }
              const s2 = this.getDropDownOffset();
              n2.style.top = i2 + s2.y + "px", e2 || (n2.style.left = o2 + s2.x + "px");
            }
            getDropDownOffset() {
              const e2 = this.context._positionedParent;
              let t2, n2;
              if (e2 && "#document-fragment" !== e2.nodeName) {
                const r2 = e2.getBoundingClientRect();
                t2 = -r2.left, n2 = -r2.top;
              } else
                t2 = window.pageXOffset, n2 = window.pageYOffset;
              return { x: t2, y: n2 };
            }
            placeOverlay() {
              const e2 = this.context;
              if (!e2.dropDownOverlay || e2._overlay)
                return;
              const t2 = document.createElement("div");
              t2.classList.add("smart-drop-down-overlay"), t2.style.width = document.documentElement.scrollWidth + "px", t2.style.height = document.documentElement.scrollHeight + "px", document.body.appendChild(t2), e2._overlay = t2;
            }
            removeOverlay(e2) {
              const t2 = this, n2 = t2.context;
              n2._overlay && (n2.hasAnimation && e2 ? requestAnimationFrame(function e3() {
                t2.dropDown.getBoundingClientRect().height > 0 ? requestAnimationFrame(e3) : (document.body.removeChild(n2._overlay), delete n2._overlay);
              }) : (document.body.removeChild(n2._overlay), delete n2._overlay));
            }
          }), window.Smart.Color = class {
            constructor(e2) {
              if (window.Smart._colors || (window.Smart._colors = []), window.Smart._colors[e2]) {
                const t3 = window.Smart._colors[e2];
                return this.hex = t3.hex, this.r = t3.r, this.g = t3.g, void (this.b = t3.b);
              }
              this.r = this.g = this.b = 0, this.hex = "";
              const t2 = this.getStandardizedColor(e2);
              t2 && (this.setHex(t2.substring(1)), window.Smart._colors[e2] = { hex: this.hex, r: this.r, g: this.g, b: this.b });
            }
            getStandardizedColor(e2) {
              const t2 = document.createElement("canvas").getContext("2d");
              return t2.fillStyle = e2, t2.fillStyle;
            }
            getInvertedColor() {
              return "" === this.hex ? "transparent" : 255 - (0.299 * this.r + 0.587 * this.g + 0.114 * this.b) < 105 ? "Black" : "White";
            }
            hexToRgb(e2) {
              let t2 = "00", n2 = "00", r2 = "00";
              return 6 === (e2 = this.validateHex(e2)).length ? (t2 = e2.substring(0, 2), n2 = e2.substring(2, 4), r2 = e2.substring(4, 6)) : (e2.length > 4 && (t2 = e2.substring(4, e2.length), e2 = e2.substring(0, 4)), e2.length > 2 && (n2 = e2.substring(2, e2.length), e2 = e2.substring(0, 2)), e2.length > 0 && (r2 = e2.substring(0, e2.length))), { r: this.hexToInt(t2), g: this.hexToInt(n2), b: this.hexToInt(r2) };
            }
            validateHex(e2) {
              return (e2 = (e2 = new String(e2).toUpperCase()).replace(/[^A-F0-9]/g, "0")).length > 6 && (e2 = e2.substring(0, 6)), e2;
            }
            webSafeDec(e2) {
              return e2 = Math.round(e2 / 51), e2 *= 51;
            }
            hexToWebSafe(e2) {
              let t2, n2, r2;
              return 3 === e2.length ? (t2 = e2.substring(0, 1), n2 = e2.substring(1, 1), r2 = e2.substring(2, 1)) : (t2 = e2.substring(0, 2), n2 = e2.substring(2, 4), r2 = e2.substring(4, 6)), this.intToHex(this.webSafeDec(this.hexToInt(t2))) + this.intToHex(this.webSafeDec(this.hexToInt(n2))) + this.intToHex(this.webSafeDec(this.hexToInt(r2)));
            }
            rgbToWebSafe(e2) {
              return { r: this.webSafeDec(e2.r), g: this.webSafeDec(e2.g), b: this.webSafeDec(e2.b) };
            }
            rgbToHex(e2) {
              return this.intToHex(e2.r) + this.intToHex(e2.g) + this.intToHex(e2.b);
            }
            intToHex(e2) {
              let t2 = parseInt(e2).toString(16);
              return 1 === t2.length && (t2 = "0" + t2), t2.toUpperCase();
            }
            hexToInt(e2) {
              return parseInt(e2, 16);
            }
            setRgb(e2, t2, n2) {
              let r2 = function(e3) {
                return e3 < 0 || e3 > 255 || isNaN(parseInt(e3)) ? 0 : e3;
              };
              this.r = r2(e2), this.g = r2(t2), this.b = r2(n2), this.hex = this.rgbToHex(this);
            }
            setHex(e2) {
              this.hex = e2;
              let t2 = this.hexToRgb(this.hex);
              this.r = t2.r, this.g = t2.g, this.b = t2.b;
            }
          };
        }();
      }
    ),
    /***/
    6802: (
      /***/
      () => {
        Smart.Utilities.Assign("DataExporter", class {
          constructor(e, t, a, o) {
            const l = this;
            e || (e = {}), l.style = e.style, l.header = e.header, l.exportHeader = void 0 === e.exportHeader || e.exportHeader, l.hierarchical = e.hierarchical, l.expandChar = e.expandChar || "+", l.collapseChar = e.collapseChar || "-", l.pageOrientation = e.pageOrientation, l.allowNull = e.allowNull || false, !l.hierarchical && t && t.length > 0 ? l.groupBy = t : l.mergedCells = e.mergedCells, !l.groupBy && a && Object.keys(a).length > 0 && (l.filterBy = a), o && (l.conditionalFormatting = o), l.timeBetween1900And1970 = new Date(1970, 0, 1, 0, 0, 0).getTime() - new Date(1900, 0, 1, 0, 0, 0).getTime();
          }
          downloadFile(e, t, a) {
            let o;
            if (!a)
              return e;
            if (o = e instanceof Blob ? e : new Blob([e], { type: t }), window.navigator.msSaveOrOpenBlob)
              window.navigator.msSaveOrOpenBlob(o, a);
            else {
              const e2 = document.createElement("a"), t2 = URL.createObjectURL(o);
              e2.href = t2, e2.download = a, e2.style.position = "absolute", e2.style.visibility = "hidden", document.body.appendChild(e2), e2.click(), setTimeout(function() {
                document.body.removeChild(e2), window.URL.revokeObjectURL(t2);
              }, 100);
            }
          }
          exportData(e, t, a, o) {
            const l = this;
            if (l.actualHierarchy = l.hierarchical, t = t.toLowerCase(), l.exportHeader && (l.header ? (0 === (e = e.slice(0)).length && (l.actualHierarchy = false), l.processComplexHeader(l.header, e, t)) : 1 === e.length && (l.actualHierarchy = false)), 0 === e.length)
              return void console.warn("No data to export.");
            "xlsx" === t && (l.xlsxStartIndex = l.complexHeader ? l.complexHeader.length : +l.exportHeader), l.actualHierarchy && (e = l.processHierarchicalData(e, t)), l.getDatafields(e), a && a.slice(a.length - t.length - 1, a.length) !== "." + t && (a += "." + t);
            let r = null;
            switch (t) {
              case "csv":
                r = l.exportToCSVAndTSV(e, { delimiter: ", ", MIME: "text/csv", toRemove: 2 }, a);
                break;
              case "html":
                r = l.exportToHTML(e, a);
                break;
              case "jpeg":
              case "png":
                l.exportToImage(e, a, t, o);
                break;
              case "json":
                r = l.exportToJSON(e, a);
                break;
              case "pdf":
                r = l.exportToPDF(e, a);
                break;
              case "tsv":
                r = l.exportToCSVAndTSV(e, { delimiter: "	", MIME: "text/tab-separated-values", toRemove: 1 }, a);
                break;
              case "xlsx":
                r = l.exportToXLSX(e, a, o);
                break;
              case "xml":
                r = l.exportToXML(e, a);
                break;
              case "md":
                r = l.exportToMD(e, a);
            }
            return o && r && o(r), delete l.complexHeader, r;
          }
          exportToCSVAndTSV(e, t, a) {
            const o = this, l = o.datafields;
            let r = "";
            for (let a2 = 0; a2 < e.length; a2++) {
              const n = e[a2];
              let s = "";
              for (let e2 = 0; e2 < l.length; e2++)
                o.actualHierarchy && 0 === e2 ? s += ('""' + t.delimiter).repeat(n._level - 1) + '"' + n[l[e2]] + '"' + t.delimiter + ('""' + t.delimiter).repeat(o.maxLevel - n._level) : s += '"' + n[l[e2]] + '"' + t.delimiter;
              s = s.slice(0, s.length - t.toRemove) + "\n", r += s;
            }
            return a ? this.downloadFile(r, t.MIME, a) : r;
          }
          exportToHTML(e, t) {
            const a = this, o = a.datafields, l = a.style;
            let r = "", n = 0, s = "";
            e = a.processGroupingInformation(e), a.data = e, a.exportHeader && (r = a.getHTMLHeader(o, e), n = 1), arguments[2] && (s = `<script type="text/javascript" src="${Array.from(document.getElementsByTagName("script")).find((e2) => -1 !== e2.src.indexOf("html2canvas")).src}"><\/script>`);
            let i = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style type="text/css">
${a.getRowStyle()}${a.getColumnStyle()}
    </style>${s}${a.toggleableFunctionality()}
</head>
<body>
    <table${a.getTableStyle()}>${r}
        <tbody>
`;
            const c = {}, p = {}, m = [];
            a.getMergedCellsInfo(c, p);
            e:
              for (let r2 = n; r2 < e.length; r2++) {
                const s2 = e[r2], f = r2 - n;
                let d = a.getAlternationIndex(f, " rowN"), h = "", g = "", u = "", y = 0;
                if (a.actualHierarchy)
                  s2._collapsed && (h = " collapsed"), g = ` level="${s2._level}"`;
                else if (a.groupBy)
                  for (let e2 = 0; e2 < a.groupBy.length; e2++) {
                    const t2 = a.groupBy[e2], o2 = s2[t2], l2 = a.groups[t2][o2];
                    if (u += o2, -1 === m.indexOf(u)) {
                      i += `            <tr class="row">
                <td class="column group" style="padding-left: ${25 * y}px;" colspan="${a.datafields.length}">${l2}</td>
            </tr>`, m.push(u), r2--;
                      continue e;
                    }
                    y++;
                  }
                let x = `            <tr class="row row${f}${d}${h}"${g}`;
                t || (x += ' style="page-break-inside: avoid;"'), x += ">\n";
                for (let e2 = 0; e2 < o.length; e2++) {
                  const t2 = e2 + "," + f;
                  let r3 = 1, n2 = 1;
                  if (c[t2])
                    r3 = c[t2].colspan, n2 = c[t2].rowspan;
                  else if (p[t2])
                    continue;
                  const i2 = o[e2];
                  let m2 = s2[i2], d2 = "";
                  if (a.actualHierarchy && 0 === e2) {
                    let e3 = "";
                    s2._expanded ? e3 = a.collapseChar : false === s2._expanded && (e3 = a.expandChar), d2 = `<div class="toggle-element" style="margin-left: ${25 * (s2._level - 1) + 5}px;" expanded>${e3}</div>`;
                  }
                  m2 = a.getFormattedValue(m2, i2);
                  let h2 = "";
                  if (l && l.columns && l.columns[i2] && l.columns[i2][f]) {
                    const e3 = l.columns[i2][f];
                    h2 += `border-color: ${e3.border}; background-color: ${e3.background}; color: ${e3.color};"`;
                  }
                  0 === e2 && y > 1 && (h2 += `padding-left: ${25 * (y - 1)}px;"`), h2 && (h2 = ` style="${h2}"`), x += `                <td class="column column${i2}"${h2} colspan="${r3}" rowspan="${n2}">${d2 + m2}</td>
`;
                }
                i += x + "            </tr>\n";
              }
            return i += "        </tbody>\n    </table>\n</body>\n</html>", arguments[2] ? i : this.downloadFile(i, "text/html", t);
          }
          exportToImage(e, t, a, o) {
            try {
              html2canvas;
            } catch (e2) {
              throw new Error("smart-grid: Missing reference to 'html2canvas.min.js'.");
            }
            let l = null;
            const r = this.exportToHTML(e, t, true), n = document.createElement("iframe");
            return n.style.position = "absolute", n.style.top = 0, n.style.left = 0, n.style.border = "none", n.style.width = "100%", n.style.height = "100%", n.style.opacity = 0, n.style.pointerEvents = "none", document.body.appendChild(n), n.contentDocument.write(r), function e2() {
              n.contentDocument.body && n.contentDocument.body.firstElementChild ? n.contentWindow.html2canvas(n.contentDocument.body.firstElementChild).then((e3) => {
                const r2 = new Smart.Utilities.Draw(document.createElement("div"));
                l = e3.toDataURL("image/png"), o ? o(l) : (document.body.appendChild(e3), r2.exportImage(void 0, e3, a, t)), n.remove(), e3.remove();
              }) : requestAnimationFrame(e2);
            }(), l;
          }
          getMergedCellsInfo(e, t, a) {
            const o = this;
            if (!o.mergedCells)
              return;
            const l = a && 0 !== a[o.datafields.length - 1];
            o.mergedCellsPDF = o.mergedCells.slice(0);
            for (let r = 0; r < o.mergedCellsPDF.length; r++) {
              const n = o.mergedCellsPDF[r];
              let s = n.colspan, i = n.rowspan;
              if (i < 2 && s < 2)
                continue;
              const c = n.cell[1];
              let p = n.cell[0];
              if (l && s > 1) {
                const e2 = a[p], t2 = a[p + s - 1], l2 = [];
                if (t2 > e2) {
                  let r2 = e2, n2 = p, m = 0;
                  e:
                    for (let o2 = e2; o2 <= t2; o2++) {
                      let e3 = n2, t3 = 0;
                      for (; a[n2] === r2; )
                        if (n2++, m++, t3++, m === s) {
                          l2.push({ start: e3, span: t3 });
                          break e;
                        }
                      l2.push({ start: e3, span: t3 }), r2 = a[n2];
                    }
                  s = l2[0].span;
                  for (let e3 = 1; e3 < l2.length; e3++)
                    o.mergedCellsPDF.push({ cell: [l2[e3].start, c], colspan: l2[e3].span, rowspan: i, originalCell: p });
                }
              }
              for (let a2 = p; a2 < p + s; a2++)
                for (let o2 = c; o2 < c + i; o2++) {
                  const l2 = a2 + "," + o2;
                  a2 !== p || o2 !== c ? t[l2] = true : e[l2] = { colspan: s, rowspan: i, originalCell: n.originalCell };
                }
            }
          }
          getAlternationIndex(e, t) {
            if (!this.style)
              return "";
            const a = this.style.rows;
            return a && a.alternationCount && ((void 0 === a.alternationStart || e >= a.alternationStart) && (void 0 === a.alternationEnd || e <= a.alternationEnd) || a.alternationStart === a.alternationEnd) ? t + e % a.alternationCount : "";
          }
          getFormattedValue(e, t) {
            const a = this, o = a.style;
            if (null === e)
              return a.allowNull ? "null" : "";
            if (t && o && o.columns && o.columns[t] && o.columns[t].format) {
              if ("number" == typeof e)
                return a.formatNumber(e, o.columns[t].format);
              if (e instanceof Date)
                return a.formatDate(e, o.columns[t].format);
            } else if (e instanceof Date)
              return a.formatDate(e, "d");
            return e;
          }
          exportToJSON(e, t) {
            return this.downloadFile(JSON.stringify(e, this.datafields.concat("rows")), "application/json", t);
          }
          exportToMD(e, t) {
            const a = this.datafields;
            let o = "";
            for (let t2 = 0, l = e.length; t2 < l; t2 += 1)
              for (let l2 = 0, r = a.length; l2 < r; l2 += 1) {
                const r2 = e[t2][a[l2]];
                "string" == typeof r2 && (o += r2);
              }
            return this.downloadFile(o, "application/text", t);
          }
          exportToPDF(e, t) {
            try {
              pdfMake;
            } catch (e2) {
              throw new Error("Missing reference to 'pdfmake.min.js'.");
            }
            const a = this, o = a.datafields, l = +a.exportHeader, r = [], n = {}, s = {}, i = {}, c = l ? a.complexHeader ? a.complexHeader.length : 1 : 0, p = { pageOrientation: a.pageOrientation || "portrait" };
            let m, f = [], d = [];
            function h() {
              let e2 = [];
              for (let t2 = 0; t2 < m.length; t2++)
                e2.push([]);
              return e2;
            }
            e = a.processGroupingInformation(e), a.data = e, a.headerRows = c, a.getPDFStyle();
            const g = a.styleInfo;
            m = g ? a.wrapPDFColumns(p, i) : [{ body: f, datafields: o }], l && (f = a.getPDFHeader(o, m, i)), a.getMergedCellsInfo(n, s, i);
            e:
              for (let t2 = l; t2 < e.length; t2++) {
                const c2 = e[t2];
                let p2 = "", f2 = 0;
                if (a.groupBy)
                  for (let e2 = 0; e2 < a.groupBy.length; e2++) {
                    const o2 = a.groupBy[e2], l2 = c2[o2], n2 = a.groups[o2][l2];
                    if (p2 += l2, -1 === r.indexOf(p2)) {
                      a.createGroupHeaderRow(m, { text: n2, style: ["row", "cell", "group"], marginLeft: 7.5 * f2 }), r.push(p2), t2--;
                      continue e;
                    }
                    f2++;
                  }
                const d2 = h(), g2 = t2 - l;
                let u = a.getAlternationIndex(g2, "");
                for (let e2 = 0; e2 < o.length; e2++) {
                  const t3 = o[e2], l2 = { style: ["row", "row" + g2, "cell", "cell" + t3] }, r2 = i[e2] || 0;
                  if (void 0 !== u && l2.style.splice(1, 0, "rowN" + u), a.mergedCellsPDF) {
                    const t4 = e2 + "," + g2, a2 = n[t4];
                    if (a2) {
                      if (l2.colSpan = a2.colspan, l2.rowSpan = a2.rowspan, void 0 !== a2.originalCell) {
                        l2.text = "", l2.style[l2.style.length - 1] = "cell" + o[a2.originalCell], d2[r2].push(l2);
                        continue;
                      }
                    } else if (s[t4]) {
                      d2[r2].push({});
                      continue;
                    }
                  }
                  const p3 = a.getFormattedValue(c2[t3], t3);
                  l2.text = p3.toString(), a.getUniqueStylePDF(l2, t3, g2), a.setIndentation(l2, { j: e2, currentRecord: c2, value: p3, outlineLevel: f2 }), d2[r2].push(l2);
                }
                for (let e2 = 0; e2 < m.length; e2++)
                  m[e2].body.push(d2[e2]);
              }
            if (g) {
              for (let e2 = 0; e2 < m.length; e2++) {
                const t2 = m[e2].body;
                for (let a2 = c - 1; a2 >= 0; a2--)
                  t2.unshift(f[e2][a2]);
                d.push({ table: { headerRows: c, widths: m[e2].widths, heights: function(e3) {
                  return g.heights[e3] ? g.heights[e3] : g.defaultHeight ? g.defaultHeight : void 0;
                }, body: t2 }, pageBreak: "after" });
              }
              delete d[m.length - 1].pageBreak, p.styles = g.styles;
            } else {
              const e2 = m[0].body;
              for (let t2 = c - 1; t2 >= 0; t2--)
                e2.unshift(f[0][t2]);
              d = [{ table: { headerRows: c, body: e2 } }], p.styles = { header: { bold: true }, group: { bold: true } };
            }
            if (p.content = d, !t) {
              const e2 = pdfMake.createPdf(p);
              return delete a.mergedCellsPDF, delete a.styleInfo, e2;
            }
            pdfMake.createPdf(p).download(t), delete a.mergedCellsPDF, delete a.styleInfo;
          }
          getPDFStyle() {
            const e = this, t = e.style;
            if (!t)
              return "";
            const a = e.data[0], o = t.header, l = t.columns, r = t.rows, n = { heights: [], widths: Array(e.datafields.length).fill("*"), styles: { header: {}, row: {}, cell: {}, group: { fillColor: "#FFFFFF", color: "#000000", bold: true } } };
            function s(t2, o2) {
              if (t2) {
                for (let l2 in t2)
                  if (Object.prototype.hasOwnProperty.call(t2, l2))
                    if (void 0 === a[l2])
                      if ("height" === l2 && "header" === o2)
                        for (let a2 = 0; a2 < e.headerRows; a2++)
                          n.heights[a2] = parseInt(t2[l2], 10) / e.headerRows / 1.4;
                      else
                        e.storePDFStyle({ prop: l2, value: t2[l2], toUpdate: o2 });
                    else
                      for (let a2 in t2[l2]) {
                        if (!isNaN(a2) || !Object.prototype.hasOwnProperty.call(t2[l2], a2))
                          continue;
                        const r2 = t2[l2][a2], s2 = e.datafields.indexOf(l2);
                        "width" === a2 && "*" === n.widths[s2] ? n.widths[s2] = r2 : e.storePDFStyle({ prop: a2, value: r2, toUpdate: o2 + l2 });
                      }
              }
            }
            if (e.styleInfo = n, s(o, "header"), s(l, "cell"), r) {
              for (let t2 in r) {
                if (!Object.prototype.hasOwnProperty.call(r, t2) || -1 !== t2.indexOf("alt"))
                  continue;
                const a2 = r[t2];
                if (isNaN(t2))
                  "height" === t2 ? n.defaultHeight = parseFloat(a2) / 1.4 : e.storePDFStyle({ prop: t2, value: a2, toUpdate: "row" });
                else
                  for (let o2 in a2)
                    Object.prototype.hasOwnProperty.call(a2, o2) && ("height" === o2 ? n.heights[parseFloat(t2) + e.headerRows] = parseFloat(a2[o2]) / 1.4 : e.storePDFStyle({ prop: o2, value: a2[o2], toUpdate: "row" + t2 }));
              }
              if (r.alternationCount)
                for (let e2 = 0; e2 < r.alternationCount; e2++) {
                  const t2 = {};
                  r[`alternationIndex${e2}Color`] && (t2.color = r[`alternationIndex${e2}Color`]), r[`alternationIndex${e2}BackgroundColor`] && (t2.fillColor = r[`alternationIndex${e2}BackgroundColor`]), n.styles["rowN" + e2] = t2;
                }
            }
          }
          storePDFStyle(e) {
            const t = this;
            let a = t.styleInfo.styles[e.toUpdate];
            a || (a = {}, t.styleInfo.styles[e.toUpdate] = a);
            let o = e.value;
            switch (e.prop) {
              case "backgroundColor":
                a.fillColor = o;
                break;
              case "color":
                a.color = o;
                break;
              case "fontSize":
                a.fontSize = parseFloat(o);
                break;
              case "fontStyle":
                "italic" === o && (a.italics = true);
                break;
              case "fontWeight":
                "bold" === o && (a.bold = true);
                break;
              case "textAlign":
                a.alignment = o;
            }
          }
          wrapPDFColumns(e, t) {
            const a = this, o = this.styleInfo, l = "portrait" === e.pageOrientation ? 655 : 1155, r = [];
            let n = 0;
            for (let e2 = 0; e2 < o.widths.length; e2++) {
              let s, i = o.widths[e2];
              if ("*" === i ? s = l / 6 : "string" == typeof i && -1 !== i.indexOf("%") ? (s = Math.min(l, Math.floor(parseFloat(i) / 100 * l)), s === l && (i = "*")) : (i = parseFloat(i), i >= l ? (s = l, i = "*") : (s = i, i /= 1.4)), void 0 === r[n]) {
                const o2 = [];
                r[n] = { body: o2, width: s, widths: [i], datafields: [a.datafields[e2]] }, t[e2] = n;
                continue;
              }
              const c = r[n];
              c.width + s > l ? (n++, e2--) : (t[e2] = n, c.width += s, c.widths.push(i), c.datafields.push(a.datafields[e2]));
            }
            return r;
          }
          getPDFHeader(e, t, a) {
            const o = this, l = [], r = o.headerRows, n = [], s = [];
            let i, c, p = [];
            o.complexHeader ? (i = o.complexHeader, c = o.complexDataFieldsHeader) : (i = [Object.values(o.data[0])], c = i);
            for (let e2 = 0; e2 < r; e2++) {
              const t2 = i[e2], o2 = c[e2];
              for (let l2 = 0; l2 < t2.length; l2++) {
                let r2 = a[l2] || 0;
                n[r2] || (n[r2] = [], s[r2] = []), n[r2][e2] || (n[r2][e2] = [], s[r2][e2] = []), n[r2][e2].push(t2[l2]), s[r2][e2].push(o2[l2]);
              }
            }
            function m(e2, t2, a2, o2) {
              for (let l2 = 0; l2 < r; l2++) {
                const n2 = e2[l2], s2 = t2[l2], i2 = [];
                for (let e3 = 0; e3 < n2.length; e3++) {
                  const a3 = s2[e3];
                  let c2 = 1, p2 = 1;
                  if (s2[e3 - 1] && s2[e3 - 1] === a3 || t2[l2 - 1] && t2[l2 - 1][e3] === a3) {
                    i2.push({});
                    continue;
                  }
                  let m2 = e3 + 1;
                  for (; s2[m2] && s2[m2] === s2[m2 - 1]; )
                    c2++, m2++;
                  for (m2 = l2 + 1; t2[m2] && t2[m2][e3] === a3; )
                    p2++, m2++;
                  const f = l2 === r - 1 || p2 + l2 === r ? o2.datafields[e3] : null, d = { text: n2[e3], colSpan: c2, rowSpan: p2 };
                  f ? d.style = ["header", "header" + f] : (d.alignment = "center", d.style = "header"), i2.push(d);
                }
                a2.push(i2);
              }
            }
            for (let e2 = 0; e2 < t.length; e2++)
              p = [], m(n[e2], s[e2], p, t[e2]), l.push(p);
            return l;
          }
          createGroupHeaderRow(e, t) {
            for (let a = 0; a < e.length; a++) {
              const o = Object.assign({}, t), l = e[a].datafields.length, r = [o];
              o.colSpan = l, r.length = l, r.fill({}, 1, l - 1), e[a].body.push(r);
            }
          }
          getUniqueStylePDF(e, t, a) {
            const o = this.style;
            if (!o || !o.columns || !o.columns[t])
              return;
            const l = o.columns[t][a];
            l && (e.fillColor = function(e2) {
              const t2 = /rgba\((\d+),(\d+),(\d+)\,(\d*.\d+|\d+)\)/gi.exec(e2.replace(/\s/g, ""));
              if (null === t2)
                return e2;
              const a2 = parseFloat(t2[1]).toString(16).toUpperCase(), o2 = parseFloat(t2[2]).toString(16).toUpperCase(), l2 = parseFloat(t2[3]).toString(16).toUpperCase();
              return "#" + "0".repeat(2 - a2.length) + a2 + "0".repeat(2 - o2.length) + o2 + "0".repeat(2 - l2.length) + l2;
            }(l.background), e.color = l.color.toLowerCase());
          }
          setIndentation(e, t) {
            if (0 !== t.j)
              return;
            const a = this;
            if (a.actualHierarchy) {
              const o = t.currentRecord;
              void 0 !== o._expanded ? (e.marginLeft = 25 * (o._level - 1), e.text = a.collapseChar + " " + t.value) : e.marginLeft = 25 * (o._level - 1) + 6;
            } else
              t.outlineLevel > 1 && (e.marginLeft = 7.5 * (t.outlineLevel - 1));
          }
          exportToXLSX(e, t, a) {
            try {
              JSZip;
            } catch (e2) {
              throw new Error("Missing reference to 'jszip.min.js'.");
            }
            const o = this;
            let l = o.style;
            if (e = o.processGroupingInformation(e, true), o.data = e, o.getColumnsArray(), o.complexHeaderMergedCells = [], o.complexHeaderMergeInfo) {
              for (let e2 in o.complexHeaderMergeInfo)
                if (Object.prototype.hasOwnProperty.call(o.complexHeaderMergeInfo, e2)) {
                  const t2 = o.complexHeaderMergeInfo[e2];
                  if (t2.from[0] === t2.to[0] && t2.from[1] === t2.to[1])
                    continue;
                  o.complexHeaderMergedCells.push({ from: o.columnsArray[t2.from[1]] + (t2.from[0] + 1), to: o.columnsArray[t2.to[1]] + (t2.to[0] + 1) });
                }
            }
            o.getConditionalFormatting(), l || (l = o.generateDefaultStyle(e));
            const r = o.generateSharedStrings(e), n = r.collection, s = r.xml, i = o.generateStyles(l), c = o.groupBy ? o.generateSheet1WithGrouping(e, n) : o.generateSheet1(e, n), p = o.generateAuxiliaryFiles(), m = new JSZip(), f = m.folder("_rels"), d = m.folder("docProps"), h = m.folder("xl"), g = h.folder("_rels"), u = h.folder("theme"), y = h.folder("worksheets");
            f.file(".rels", p._relsRels), d.file("app.xml", p.docPropsAppXml), d.file("core.xml", p.docPropsCoreXml), g.file("workbook.xml.rels", p.xl_relsWorkbookXmlRels), u.file("theme1.xml", p.xlThemeTheme1Xml), y.file("sheet1.xml", c), h.file("sharedStrings.xml", s), h.file("styles.xml", i), h.file("workbook.xml", p.xlWorkbookXml), m.file("[Content_Types].xml", p.Content_TypesXml), m.generateAsync({ type: "blob", mimeType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" }).then(function(e2) {
              return !t && a && a(e2), o.downloadFile(e2, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", t);
            }), delete o.conditionalFormattingXLSX, delete o.complexHeaderMergeInfo, delete o.defaultRowHeight, delete o.rowHeight;
          }
          processGroupingInformation(e, t) {
            const a = this;
            if (!a.groupBy)
              return e;
            let o;
            if (e = e.slice(0), a.exportHeader && (t && a.complexHeader ? (o = e.slice(0, a.complexHeader.length), e.splice(0, a.complexHeader.length)) : (o = [e[0]], e.splice(0, 1))), e.length > 1) {
              const t2 = function(e2, t3) {
                let a2;
                switch (t3 || typeof e2) {
                  case "string":
                    a2 = new Intl.Collator().compare;
                    break;
                  case "number":
                    a2 = function(e3, t4) {
                      return e3 - t4;
                    };
                    break;
                  case "boolean":
                  case "bool":
                    a2 = function(e3, t4) {
                      return e3 === t4 ? 0 : false === e3 ? -1 : 1;
                    };
                    break;
                  case "date":
                  case "time":
                  case "dateTime":
                    e2 instanceof Date ? a2 = function(e3, t4) {
                      return e3.getTime() - t4.getTime();
                    } : (e2 instanceof Smart.Utilities.DateTime || e2 instanceof Smart.Utilities.BigNumber) && (a2 = function(e3, t4) {
                      return e3.compare(t4);
                    });
                    break;
                  case "object":
                    if (e2 instanceof Date)
                      a2 = function(e3, t4) {
                        return e3.getTime() - t4.getTime();
                      };
                    else if (e2 instanceof Smart.Utilities.DateTime || e2 instanceof Smart.Utilities.BigNumber)
                      a2 = function(e3, t4) {
                        return e3.compare(t4);
                      };
                    else if (e2 instanceof Smart.Utilities.Complex || window.NIComplex && e2 instanceof window.NIComplex) {
                      const e3 = new Smart.Utilities.ComplexNumericProcessor();
                      a2 = function(t4, a3) {
                        return e3.compareComplexNumbers(t4, a3);
                      };
                    }
                }
                return a2;
              };
              !function(e2, a2, o2, l) {
                if (!e2 || !Array.isArray(e2) || 0 === e2.length || !a2 || Array.isArray(a2) && 0 === a2.length)
                  return;
                "string" == typeof a2 && (a2 = [a2]);
                const r = [], n = [];
                void 0 === o2 && (o2 = []);
                for (let l2 = 0; l2 < a2.length; l2++)
                  void 0 === o2[l2] || "asc" === o2[l2] || "ascending" === o2[l2] ? r[l2] = 1 : r[l2] = -1, n[l2] = t2(e2[0][a2[l2]]);
                l ? l(e2, a2, o2, n) : e2.sort(function(e3, t3) {
                  for (let o3 = 0; o3 < a2.length; o3++) {
                    const l2 = n[o3](e3[a2[o3]], t3[a2[o3]]);
                    if (0 === l2) {
                      if (a2[o3 + 1])
                        continue;
                      return void 0 !== e3._index ? (e3._index - t3._index) * r[o3] : 0;
                    }
                    return l2 * r[o3];
                  }
                });
              }(e, a.groupBy);
            }
            return o && (e = o.concat(e)), a.getGroupLabels(e), e;
          }
          exportToXML(e, t) {
            const a = this.datafields.slice(0);
            let o = '<?xml version="1.0" encoding="UTF-8" ?>\n<table>\n';
            return -1 === a.indexOf("rows") && a.push("rows"), o += function e2(t2, o2) {
              let l = "";
              for (let r = 0; r < t2.length; r++) {
                const n = t2[r];
                l += o2 + "<row>\n";
                for (let t3 = 0; t3 < a.length; t3++) {
                  const r2 = a[t3];
                  if ("rows" !== r2)
                    l += o2 + `    <${r2}>${n[r2]}</${r2}>
`;
                  else {
                    if (!n.rows)
                      continue;
                    l += `${o2}    <rows>
${e2(n.rows, o2 + "        ")}${o2}    </rows>
`;
                  }
                }
                l += o2 + "</row>\n";
              }
              return l;
            }(e, "    ") + "</table>", t ? this.downloadFile(o, "application/xml", t) : o;
          }
          formatDate(e, t) {
            if (!Smart.Utilities.DateTime)
              return e;
            try {
              return new Smart.Utilities.DateTime(e).toString(t);
            } catch (t2) {
              return e;
            }
          }
          formatNumber(e, t) {
            if (!Smart.Utilities.NumberRenderer)
              return e;
            const a = new Smart.Utilities.NumberRenderer().formatNumber(e, t);
            return void 0 === a ? e : a;
          }
          generateAuxiliaryFiles() {
            const e = (/* @__PURE__ */ new Date()).toISOString();
            return { _relsRels: '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>', docPropsAppXml: '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>', docPropsCoreXml: `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator>Smart HTML Elements</dc:creator><cp:lastModifiedBy>Smart HTML Elements</cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">${e}</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">${e}</dcterms:modified></cp:coreProperties>`, xl_relsWorkbookXmlRels: '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/><Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml"/></Relationships>', xlThemeTheme1Xml: '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="4472C4"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="5B9BD5"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック Light"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线 Light"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>', xlWorkbookXml: '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15 xr xr6 xr10 xr2" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr6="http://schemas.microsoft.com/office/spreadsheetml/2016/revision6" xmlns:xr10="http://schemas.microsoft.com/office/spreadsheetml/2016/revision10" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2"><fileVersion appName="xl" lastEdited="7" lowestEdited="7" rupBuild="20325"/><workbookPr defaultThemeVersion="166925"/><mc:AlternateContent xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"><mc:Choice Requires="x15"><x15ac:absPath url="C:UsersjqwidgetsDesktop" xmlns:x15ac="http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac"/></mc:Choice></mc:AlternateContent><xr:revisionPtr revIDLastSave="0" documentId="13_ncr:1_{0DEDCB6D-5403-4CD8-AAA5-59B6D238A8B6}" xr6:coauthVersionLast="34" xr6:coauthVersionMax="34" xr10:uidLastSave="{00000000-0000-0000-0000-000000000000}"/><bookViews><workbookView xWindow="0" yWindow="0" windowWidth="19200" windowHeight="6950" xr2:uid="{0CB664E6-3800-4A88-B158-B46A682E7484}"/></bookViews><sheets><sheet name="Sheet1" sheetId="1" r:id="rId1"/></sheets><calcPr calcId="179021"/><extLst><ext uri="{140A7094-0E35-4892-8432-C4D2E57EDEB5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:workbookPr chartTrackingRefBase="1"/></ext></extLst></workbook>', Content_TypesXml: '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="bin" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings"/><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="xml" ContentType="application/xml"/><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/><Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/><Override PartName="/xl/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/><Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/><Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/><Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/></Types>' };
          }
          generateDefaultStyle(e) {
            const t = this, a = {}, o = t.datafields, l = t.complexHeader ? e[t.complexHeader.length] : e[+t.exportHeader];
            if (!l)
              return a;
            for (let e2 = 0; e2 < o.length; e2++)
              l[o[e2]] instanceof Date && (a.columns || (a.columns = []), a.columns[o[e2]] = { format: "d" });
            return a;
          }
          generateGroupRow(e) {
            const t = e.rowNumber, a = "A" + t, o = `        <row r="${t}" outlineLevel="${e.outlineLevel}" spans="1:${e.numberOfColumns}"${this.getCustomRowHeight(t - 1)} x14ac:dyDescent="0.45">
            <c r="${a}" t="s" s="0">
                <v>${e.sharedStringIndex}</v>
            </c>
        </row>
`;
            return e.mergedCells.push({ from: a, to: this.columnsArray[e.numberOfColumns - 1] + t }), o;
          }
          generateSharedStrings(e) {
            const t = this, a = t.datafields, o = [];
            let l = "", r = 0, n = 0;
            function s(e2) {
              r++, -1 === o.indexOf(e2) && (n++, o.push(e2), e2 = (e2 = (e2 = (e2 = (e2 = e2.replace(/&(?!amp;)/g, "&amp;")).replace(/'/g, "&apos;")).replace(/"/g, "&quot;")).replace(/>/g, "&gt;")).replace(/</g, "&lt;"), l += `<si><t>${e2}</t></si>`);
            }
            for (let o2 = 0; o2 < e.length; o2++) {
              const l2 = e[o2];
              for (let e2 = 0; e2 < a.length; e2++) {
                let o3 = l2[a[e2]];
                null !== o3 || t.allowNull || (o3 = ""), "string" == typeof o3 && s(o3);
              }
            }
            if (t.groupLabels)
              for (let e2 = 0; e2 < t.groupLabels.length; e2++)
                s(t.groupLabels[e2]);
            return l = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="${r}" uniqueCount="${n}">${l}</sst>`, { collection: o, xml: l };
          }
          generateSheet1(e, t) {
            const a = this, o = a.columnsArray.length, l = e.length, r = a.columnsArray[o - 1] + l, n = a.datafields, s = a.getFilters(), i = [].concat(a.complexHeaderMergedCells);
            let c = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac xr xr2 xr3" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2" xmlns:xr3="http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" xr:uid="{7F25248B-C640-4C64-AD47-C0EA0E5D90D0}">
    <sheetPr filterMode="${"" !== s}" />
    <dimension ref="A1:${r}" />
    <sheetViews>
        <sheetView tabSelected="1" workbookViewId="0" />
    </sheetViews>
    <sheetFormatPr defaultRowHeight="14.5" x14ac:dyDescent="0.35" />${a.getCustomColumnWidths()}
    <sheetData>
`;
            function p(e2, t2) {
              return a.columnsArray[e2] + t2;
            }
            for (let l2 = 0; l2 <= e.length; l2++) {
              const r2 = e[l2], s2 = l2 + 1;
              let i2 = "";
              if (a.actualHierarchy) {
                const t2 = e[l2 - 1];
                t2 && t2._collapsed && (!r2 || t2._level > r2._level) && (i2 = ' collapsed="true"');
              }
              if (l2 === e.length) {
                i2 && (c += `        <row r="${s2}" outlineLevel="${Math.max(e[l2 - 1]._level - 2, 0)}" hidden="false" collapsed="true" />
`);
                break;
              }
              let m = `        <row r="${s2}"${a.getOutlineLevel(r2)} hidden="${r2._hidden || r2._collapsed || false}"${i2} spans="1:${o}"${a.getCustomRowHeight(s2 - 1)} x14ac:dyDescent="0.45">
`;
              for (let e2 = 0; e2 < n.length; e2++) {
                const o2 = a.getXLSXCellStyle(p(e2, s2));
                m += a.getActualCellData(r2[n[e2]], { r: p(e2, s2), s: o2 }, t);
              }
              m += "        </row>\n", c += m;
            }
            return c += `    </sheetData>${a.conditionalFormattingXLSX.conditions}${s}${a.getMergedCells(i)}
    <pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3" />
    <pageSetup paperSize="9" orientation="portrait" r:id="rId1" />
</worksheet>`, c;
          }
          generateSheet1WithGrouping(e, t) {
            const a = this, o = a.columnsArray.length, l = e.length, r = a.columnsArray[o - 1] + l, n = a.datafields, s = [].concat(a.complexHeaderMergedCells);
            let i = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac xr xr2 xr3" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2" xmlns:xr3="http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" xr:uid="{7F25248B-C640-4C64-AD47-C0EA0E5D90D0}">
    <dimension ref="A1:${r}" />
    <sheetViews>
        <sheetView tabSelected="1" workbookViewId="0" />
    </sheetViews>
    <sheetFormatPr defaultRowHeight="14.5" x14ac:dyDescent="0.35" />${a.getCustomColumnWidths()}
    <sheetData>
`, c = 0, p = [];
            function m(e2, t2) {
              return a.columnsArray[e2] + t2;
            }
            e:
              for (let l2 = 0; l2 < e.length; l2++) {
                const r2 = e[l2], f = l2 + 1 + c;
                let d = 0, h = "";
                if (!a.exportHeader || !a.complexHeader && 0 !== l2 || a.complexHeader && l2 >= a.complexHeader.length) {
                  let e2 = "";
                  for (let n2 = 0; n2 < a.groupBy.length; n2++) {
                    const m2 = a.groupBy[n2], h2 = r2[m2], g2 = a.groups[m2][h2];
                    if (e2 += h2, -1 === p.indexOf(e2)) {
                      let r3 = t.indexOf(g2);
                      i += a.generateGroupRow({ rowNumber: f, outlineLevel: d, numberOfColumns: o, sharedStringIndex: r3, mergedCells: s }), p.push(e2), l2--, c++;
                      continue e;
                    }
                    d++;
                  }
                  h = ` outlineLevel="${d}"`;
                }
                let g = `        <row r="${f}"${h} spans="1:${o}"${a.getCustomRowHeight(f - 1)} x14ac:dyDescent="0.45">
`;
                for (let e2 = 0; e2 < n.length; e2++) {
                  const o2 = a.getXLSXCellStyle(m(e2, l2 + 1));
                  g += a.getActualCellData(r2[n[e2]], { r: m(e2, f), s: o2 }, t);
                }
                g += "        </row>\n", i += g;
              }
            return i += `    </sheetData>${a.getMergedCells(s)}
    <pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3" />
    <pageSetup paperSize="9" orientation="portrait" r:id="rId1" />
</worksheet>`, i;
          }
          getActualCellData(e, t, a) {
            const o = t.r, l = t.s || ' s="0"';
            return null !== e || this.allowNull || (e = ""), "string" == typeof e ? `            <c r="${o}" t="s"${l}>
                <v>${a.indexOf(e)}</v>
            </c>
` : "boolean" == typeof e ? `            <c r="${o}" t="b"${l}>
                <v>${+e}</v>
            </c>
` : e instanceof Date ? `            <c r="${o}"${l}>
                <v>${2 + Math.round(this.timeBetween1900And1970 / 864e5) + (e.getTime() - 60 * e.getTimezoneOffset() * 1e3) / 864e5}</v>
            </c>
` : `            <c r="${o}"${l}>
                <v>${e}</v>
            </c>
`;
          }
          getColumnsArray() {
            const e = this.datafields.length, t = [];
            function a(e2) {
              return e2 < 26 ? "" : String.fromCharCode(64 + Math.floor(e2 / 26));
            }
            for (let o = 0; o < e; o++)
              t.push(a(o) + String.fromCharCode(65 + (o < 26 ? o : o % 26)));
            this.columnsArray = t;
          }
          getColumnStyle() {
            const e = this, t = e.style;
            if (!t)
              return "        .header { border: 1px solid black; padding: 5px; }\n        .column { border: 1px solid black; padding: 5px; }\n        .group { background-color: #FFFFFF; color: #000000; font-weight: bold; }";
            let a;
            a = t.removeDefault ? { header: "", column: "", group: "" } : { header: "border: 1px solid black; padding: 5px; ", column: "white-space: nowrap; overflow: hidden; border: 1px solid black; padding: 5px; ", group: "background-color: #FFFFFF; color: #000000; font-weight: bold; " };
            const o = e.data[0];
            let l = "";
            const r = t.header || {};
            for (let t2 in r) {
              if (!Object.prototype.hasOwnProperty.call(r, t2))
                continue;
              const l2 = r[t2];
              if (o[t2]) {
                a["header" + t2] || (a["header" + t2] = "");
                for (let e2 in l2)
                  if (Object.prototype.hasOwnProperty.call(l2, e2)) {
                    const o2 = Smart.Utilities.Core.toDash(e2) + ": " + l2[e2] + "; ";
                    a["header" + t2] += o2, "width" === e2 && (a["column" + t2] || (a["column" + t2] = ""), a["column" + t2] += o2);
                  }
              } else
                "height" === t2 && e.complexHeader ? a.header += "height: " + parseInt(r[t2], 10) / e.complexHeader.length + "px; " : a.header += Smart.Utilities.Core.toDash(t2) + ": " + r[t2] + "; ";
            }
            const n = t.columns || {};
            for (let e2 in n) {
              if (!Object.prototype.hasOwnProperty.call(n, e2))
                continue;
              const t2 = n[e2];
              if (o[e2]) {
                a["column" + e2] || (a["column" + e2] = "");
                for (let o2 in t2)
                  isNaN(o2) && Object.prototype.hasOwnProperty.call(t2, o2) && "format" !== o2 && (a["column" + e2] += Smart.Utilities.Core.toDash(o2) + ": " + t2[o2] + "; ");
              } else
                a.column += Smart.Utilities.Core.toDash(e2) + ": " + t2 + "; ";
            }
            for (let e2 in a)
              Object.prototype.hasOwnProperty.call(a, e2) && (l += `        .${e2} { ${a[e2]}}
`);
            return t.custom && (l += `${t.custom}
`), l;
          }
          getCustomColumnWidths() {
            const e = this;
            if (!e.style || !e.columnWidth || 0 === e.columnWidth.length)
              return "";
            let t = "\n    <cols>\n";
            for (let a = 0; a < e.columnWidth.length; a++) {
              let o = e.columnWidth[a];
              void 0 !== o && (o = Math.round(parseFloat(o)) / 7, t += `        <col min="${a + 1}" max="${a + 1}" width="${o}" customWidth="1" />
`);
            }
            return t += "    </cols>", t;
          }
          getCustomFilter(e, t) {
            let a, o = "equal";
            switch (e instanceof Date && (e = (e.getTime() + this.timeBetween1900And1970) / 864e5 + 2), t = t.toUpperCase()) {
              case "EMPTY":
                a = "";
                break;
              case "NOT_EMPTY":
                a = "", o = "notEqual";
                break;
              case "CONTAINS":
              case "CONTAINS_CASE_SENSITIVE":
                a = `*${e}*`;
                break;
              case "DOES_NOT_CONTAIN":
              case "DOES_NOT_CONTAIN_CASE_SENSITIVE":
                a = `*${e}*`, o = "notEqual";
                break;
              case "STARTS_WITH":
              case "STARTS_WITH_CASE_SENSITIVE":
                a = `${e}*`;
                break;
              case "ENDS_WITH":
              case "ENDS_WITH_CASE_SENSITIVE":
                a = `*${e}`;
                break;
              case "EQUAL":
              case "EQUAL_CASE_SENSITIVE":
                a = e;
                break;
              case "NULL":
                a = null;
                break;
              case "NOT_NULL":
                a = null, o = "notEqual";
                break;
              case "NOT_EQUAL":
                a = e, o = "notEqual";
                break;
              case "LESS_THAN":
                a = e, o = "lessThan";
                break;
              case "LESS_THAN_OR_EQUAL":
                a = e, o = "lessThanOrEqual";
                break;
              case "GREATER_THAN":
                a = e, o = "greaterThan";
                break;
              case "GREATER_THAN_OR_EQUAL":
                a = e, o = "greaterThanOrEqual";
            }
            return `                <customFilter val="${a}" operator="${o}"/>
`;
          }
          getCustomRowHeight(e) {
            const t = this;
            return t.style && (t.rowHeight[e] || t.defaultRowHeight) || "";
          }
          getDatafields(e) {
            const t = e[0], a = [];
            for (let e2 in t)
              Object.prototype.hasOwnProperty.call(t, e2) && "_" !== e2.charAt(0) && a.push(e2);
            this.datafields = a;
          }
          getFilters() {
            const e = this, t = e.filterBy;
            if (!t)
              return "";
            let a = "";
            for (let o in t)
              if (Object.prototype.hasOwnProperty.call(t, o)) {
                const l = e.datafields.indexOf(o);
                if (-1 === l)
                  continue;
                const r = t[o], n = r.filters;
                a += `        <filterColumn colId="${l}">
            <customFilters and="${!r.operator}">
`;
                for (let t2 = 0; t2 < n.length; t2++)
                  a += e.getCustomFilter(n[t2].value, n[t2].condition);
                a += "            </customFilters>\n        </filterColumn>";
              }
            return a ? (a = `
    <autoFilter ref="A1:${e.columnsArray[e.columnsArray.length - 1] + e.data.length}">
${a}
    </autoFilter>`, a) : "";
          }
          getGroupLabels(e) {
            const t = this, a = void 0 !== t.xlsxStartIndex ? t.xlsxStartIndex : +t.exportHeader, o = {}, l = [];
            for (let r = a; r < e.length; r++) {
              const n = e[r];
              for (let r2 = 0; r2 < t.groupBy.length; r2++) {
                const s = t.groupBy[r2], i = n[s];
                let c = o[s];
                void 0 === c && (o[s] = {}, c = o[s]), void 0 === c[i] && (c[i] = (t.exportHeader ? e[a - 1][s] : s) + ": " + i, l.push(c[i]));
              }
            }
            t.groups = o, t.groupLabels = l;
          }
          getHTMLHeader(e, t) {
            const a = this;
            let o = "\n        <thead>\n";
            if (!a.complexHeader) {
              o += "            <tr>\n";
              for (let a2 = 0; a2 < e.length; a2++) {
                const l = e[a2];
                o += `                <th class="header header${l}">${t[0][l]}</th>
`;
              }
              return o += "            </tr>\n        </thead>", o;
            }
            for (let t2 = 0; t2 < a.complexDataFieldsHeader.length; t2++) {
              const l = a.complexDataFieldsHeader[t2];
              o += "            <tr>\n";
              for (let r = 0; r < l.length; r++) {
                const n = l[r];
                let s = 1, i = 1;
                if (l[r - 1] && l[r - 1] === n || a.complexDataFieldsHeader[t2 - 1] && a.complexDataFieldsHeader[t2 - 1][r] === n)
                  continue;
                let c = r + 1;
                for (; l[c] && l[c] === l[c - 1]; )
                  s++, c++;
                for (c = t2 + 1; a.complexDataFieldsHeader[c] && a.complexDataFieldsHeader[c][r] === n; )
                  i++, c++;
                o += `                <th class="header${t2 === a.complexHeader.length - 1 || i + t2 === a.complexHeader.length ? " header" + e[r] : ""}" colspan="${s}" rowspan="${i}">${a.complexHeader[t2][r]}</th>
`;
              }
              o += "            </tr>\n";
            }
            return o += "        </thead>", o;
          }
          getConditionalFormatting() {
            const e = this, t = e.conditionalFormatting;
            if (!t)
              return void (e.conditionalFormattingXLSX = { conditions: "", styles: "" });
            const a = [];
            let o = "", l = "";
            for (let r = t.length - 1; r >= 0; r--) {
              const n = t[r], s = e.columnsArray[e.datafields.indexOf(n.column)], i = s + (e.xlsxStartIndex + 1), c = i + ":" + s + e.data.length, p = n.background + n.color, m = e.getConditionalAttributes(n, i);
              let f = a.indexOf(p);
              -1 === f && (l += `        <dxf>
            <font>
                <b val="0"/>
                <i val="0"/>
                <color rgb="${"White" === n.color ? "FFFFFFFF" : "FF000000"}"/>
                <sz val="10"/>
            </font>
            <fill>
                <patternFill>
                    <bgColor rgb="${e.toARGB(n.background)}"/>
                </patternFill>
            </fill>
        </dxf>
`, f = a.length, a.push(p)), o += `    <conditionalFormatting sqref="${c}">
        <cfRule dxfId="${f}" text="${m.text}" rank="${m.rank}" percent="${m.percent}" bottom="${m.bottom}" equalAverage="${m.equalAverage}" aboveAverage="${m.aboveAverage}"${m.operator}${m.timePeriod} priority="${r + 2}" type="${m.type}">
${m.formula}        </cfRule>
    </conditionalFormatting>
`;
            }
            l = `    <dxfs count="${a.length}">
${l}    </dxfs>`, e.conditionalFormattingXLSX = { conditions: o, styles: l };
          }
          getConditionalAttributes(e, t) {
            let a = e.condition, o = e.comparator, l = "", r = 0, n = 0, s = 0, i = 0, c = "", p = "", m = "", f = "";
            switch (a) {
              case "equal":
                c = "equal", m = "cellIs", f = `            <formula>${o}</formula>
`;
                break;
              case "lessThan":
                c = "lessThan", m = "cellIs", f = `            <formula>${o}</formula>
`;
                break;
              case "greaterThan":
                c = "greaterThan", m = "cellIs", f = `            <formula>${o}</formula>
`;
                break;
              case "notEqual":
                c = "notEqual", m = "cellIs", f = `            <formula>${o}</formula>
`;
                break;
              case "between":
                c = "between", m = "cellIs", f = `            <formula>${e.min}</formula>
            <formula>${e.max}</formula>
`;
                break;
              case "duplicate":
                m = "duplicateValues", f = "            <formula>0</formula>\n";
                break;
              case "topNItems":
                r = o, m = "top10";
                break;
              case "bottomNItems":
                r = o, s = 1, m = "top10";
                break;
              case "topNPercent":
                r = o, n = 1, m = "top10";
                break;
              case "bottomNPercent":
                r = o, n = 1, s = 1, m = "top10";
                break;
              case "aboveAverage":
                i = 1, m = "aboveAverage", f = "            <formula>0</formula>\n";
                break;
              case "belowAverage":
                m = "aboveAverage", f = "            <formula>0</formula>\n";
                break;
              case "contains":
                l = o, c = "containsText", m = "containsText", f = `            <formula>NOT(ISERROR(SEARCH("${o}",${t})))</formula>
`;
                break;
              case "doesNotContain":
                l = o, c = "notContains", m = "notContainsText", f = `            <formula>ISERROR(SEARCH("${o}",${t}))</formula>
`;
                break;
              case "dateOccur":
                p = ` timePeriod="${o}"`, m = "timePeriod";
            }
            return c && (c = ` operator="${c}" `), { text: l, rank: r, percent: n, bottom: s, equalAverage: 0, aboveAverage: i, operator: c, timePeriod: p, type: m, formula: f };
          }
          getMergedCells(e) {
            const t = this;
            let a = "";
            for (let t2 = 0; t2 < e.length; t2++)
              e[t2].from !== e[t2].to && (a += `
        <mergeCell ref="${e[t2].from}:${e[t2].to}" />
`);
            if (t.mergedCells)
              for (let e2 = 0; e2 < t.mergedCells.length; e2++) {
                const o = t.mergedCells[e2];
                o.rowspan < 2 && o.colspan < 2 || (a += `
        <mergeCell ref="${t.columnsArray[o.cell[0]] + (o.cell[1] + t.xlsxStartIndex + 1)}:${t.columnsArray[o.cell[0] + o.colspan - 1] + (o.cell[1] + t.xlsxStartIndex + o.rowspan)}" />
`);
              }
            return a && (a = `
    <mergeCells count="${e.length}">${a}    </mergeCells>`), a;
          }
          getNumFmtIndex(e, t) {
            let a = t.collection.indexOf(e);
            return -1 === a ? (a = t.collection.length + 100, t.collection.push(e), t.xml += `<numFmt numFmtId="${a}" formatCode="${e}"/>`) : a += 100, a;
          }
          getOutlineLevel(e) {
            return this.actualHierarchy && 1 !== e._level ? ` outlineLevel="${e._level - 1}"` : "";
          }
          getRowStyle() {
            const e = this.style;
            if (!e)
              return "";
            const t = e.rows;
            if (!t)
              return "";
            const a = { row: "" };
            let o = "";
            for (let e2 in t) {
              if (!Object.prototype.hasOwnProperty.call(t, e2) || "alternationCount" === e2 || "alternationStart" === e2 || "alternationEnd" === e2)
                continue;
              const o2 = t[e2];
              if (-1 === e2.indexOf("alt"))
                if (isNaN(e2))
                  a.row += Smart.Utilities.Core.toDash(e2) + ": " + t[e2] + "; ";
                else {
                  a["row" + e2] || (a["row" + e2] = "");
                  for (let t2 in o2)
                    Object.prototype.hasOwnProperty.call(o2, t2) && (a["row" + e2] += Smart.Utilities.Core.toDash(t2) + ": " + o2[t2] + "; ");
                }
              else {
                const t2 = e2.slice(16, 17), l2 = e2.slice(17);
                a["rowN" + t2] || (a["rowN" + t2] = ""), a["rowN" + t2] += "Color" === l2 ? "color : " + o2 + "; " : "BorderColor" === l2 ? "border-color : " + o2 + "; " : "background-color : " + o2 + "; ";
              }
            }
            let l = Object.keys(a);
            l.sort(function(e2, t2) {
              if ("row" === e2)
                return -1;
              if ("row" === t2)
                return 1;
              const a2 = !isNaN(e2.slice(3)), o2 = !isNaN(t2.slice(3));
              return a2 && !o2 ? 1 : !a2 && o2 ? -1 : +(e2 < t2);
            });
            for (let e2 = 0; e2 < l.length; e2++)
              o += `        .${l[e2]} { ${a[l[e2]]}}
`;
            return o;
          }
          getTableStyle() {
            const e = this.style;
            if (!e)
              return ' style="table-layout: fixed; border: 1px solid black; border-collapse: collapse;"';
            let t = "table-layout: fixed; ";
            for (let a in e)
              Object.prototype.hasOwnProperty.call(e, a) && -1 === ["header", "columns", "rows", "removeDefault", "custom"].indexOf(a) && (t += Smart.Utilities.Core.toDash(a) + ": " + e[a] + "; ");
            return t && (t = ' style="' + t + '"'), t;
          }
          getXLSXCellStyle(e) {
            const t = this;
            return void 0 !== t.cellStyleMapping[e] ? ` s="${t.cellStyleMapping[e]}"` : "";
          }
          getXLSXFormat(e, t) {
            if ("number" == typeof t) {
              if (!/^([a-zA-Z]\d*)$/g.test(e))
                return e;
              let t2 = parseFloat(e.slice(1)) || 0, a = t2 > 0 ? "." + "0".repeat(t2) : "";
              switch (e = e.slice(0, 1)) {
                case "C":
                case "c":
                  return "$#,0" + a;
                case "D":
                case "d":
                  return t2 ? "0".repeat(t2) : "0";
                case "E":
                case "e":
                  return "0" + a + e + "000";
                case "F":
                case "f":
                  return "0" + a;
                case "N":
                case "n":
                  return "#,0" + a;
                case "P":
                case "p":
                  return "#,0" + a + " %";
                default:
                  return;
              }
            } else if (t instanceof Date) {
              switch (e) {
                case "d":
                  return "m/d/yyyy";
                case "D":
                  return "nnnnmmmm dd, yyyy";
                case "t":
                  return "h:m AM/PM";
                case "T":
                  return "h:mm:ss AM/PM";
                case "f":
                  return "nnnnmmmm dd, yyyy h:m AM/PM";
                case "F":
                  return "nnnnmmmm dd, yyyy h:mm:ss AM/PM";
                case "M":
                  return "mmmm d";
                case "Y":
                  return "yyyy mmmm";
                case "FP":
                case "PP":
                  return "yyyy-mm-dd hh:mm:ss";
                case "FT":
                case "PT":
                  return "hh:mm:ss";
              }
              return e = (e = (e = (e = e.replace(/f|u|n|p|e|a|x|o/gi, "")).replace(/tt/gi, "AM/PM")).replace(/:{2,}|:\s|:$|\.$/g, "")).trim();
            }
          }
          processColumnStyle(e) {
            const t = this, a = e.header, o = e.columns, l = t.data[0], r = t.xlsxStartIndex;
            if (t.columnWidth = [], r && a)
              for (let e2 = 0; e2 < t.columnsArray.length; e2++) {
                const o2 = t.columnsArray[e2], n = o2 + r, s = a[t.datafields[e2]];
                for (let e3 in a)
                  if (Object.prototype.hasOwnProperty.call(a, e3) && void 0 === l[e3])
                    if (t.complexHeader)
                      for (let l2 = 0; l2 < t.complexHeader.length; l2++)
                        "height" !== e3 ? t.storeCellStyle(o2 + (l2 + 1), e3, a[e3]) : t.rowHeight[l2] = ` ht="${parseFloat(a.height) / t.complexHeader.length / 2}"`;
                    else {
                      if ("height" === e3) {
                        t.rowHeight[0] = ` ht="${parseFloat(a.height) / 2}"`;
                        continue;
                      }
                      t.storeCellStyle(n, e3, a[e3]);
                    }
                if (s) {
                  for (let a2 in s)
                    if (Object.prototype.hasOwnProperty.call(s, a2)) {
                      if ("width" === a2) {
                        t.columnWidth[e2] = s.width;
                        continue;
                      }
                      t.storeCellStyle(n, a2, s[a2]);
                    }
                }
              }
            else if (a)
              for (let e2 = 0; e2 < t.columnsArray.length; e2++) {
                const o2 = a[t.datafields[e2]];
                o2 && void 0 !== o2.width && (t.columnWidth[e2] = o2.width);
              }
            if (!o)
              return "";
            for (let e2 = r; e2 < t.data.length; e2++)
              for (let a2 = 0; a2 < t.columnsArray.length; a2++) {
                const r2 = t.columnsArray[a2] + (e2 + 1), n = t.datafields[a2], s = o[n];
                for (let e3 in o)
                  Object.prototype.hasOwnProperty.call(o, e3) && void 0 === l[e3] && t.storeCellStyle(r2, e3, o[e3]);
                if (s)
                  for (let a3 in s)
                    isNaN(a3) && Object.prototype.hasOwnProperty.call(s, a3) && t.storeCellStyle(r2, a3, s[a3], t.data[e2][n]);
              }
          }
          processComplexHeader(e, t, a) {
            const o = this, l = {}, r = -1 !== ["html", "jpeg", "pdf", "png", "xlsx"].indexOf(a) && e.columngroups, n = [], s = {}, i = {}, c = [], p = [];
            let m = 0;
            function f(t2) {
              for (let a2 = 0; a2 < e.columngroups.length; a2++) {
                const o2 = e.columngroups[a2];
                if (o2.name === t2)
                  return o2;
              }
            }
            function d(e2, t2) {
              const a2 = [];
              for (; e2; ) {
                if (a2.unshift(e2[t2]), !e2.parentGroup)
                  return a2;
                e2 = f(e2.parentGroup);
              }
            }
            if (r) {
              for (let t2 = 0; t2 < e.columngroups.length; t2++) {
                const a2 = e.columngroups[t2], o2 = d(a2, "label");
                s[a2.name] = o2, i[a2.name] = d(a2, "name"), m = Math.max(m, o2.length);
              }
              m++;
              for (let e2 = 0; e2 < m; e2++)
                c[e2] = [], p[e2] = [];
            }
            for (let t2 = 0; t2 < e.columns.length; t2++) {
              const a2 = e.columns[t2];
              if (l[a2.dataField] = a2.label, !r)
                continue;
              if (n[t2] = a2.dataField, c[m - 1][t2] = a2.label, p[m - 1][t2] = a2.dataField, !a2.columnGroup)
                continue;
              const o2 = s[a2.columnGroup], f2 = i[a2.columnGroup];
              if (o2)
                for (let e2 = 0; e2 < o2.length; e2++)
                  c[e2][t2] = o2[e2], p[e2][t2] = f2[e2];
            }
            if (c.length > 1) {
              const e2 = Object.keys(l).length;
              for (let o2 = 0; o2 < m - 1; o2++) {
                const l2 = {};
                for (let t2 = 0; t2 < e2; t2++) {
                  if (void 0 === c[o2][t2]) {
                    let e3 = o2 + 1;
                    for (; void 0 === c[e3][t2]; )
                      e3++;
                    c[o2][t2] = c[e3][t2], p[o2][t2] = p[e3][t2];
                  }
                  l2[n[t2]] = c[o2][t2];
                }
                "xlsx" === a && t.splice(o2, 0, l2);
              }
              if (o.complexHeader = c, o.complexDataFieldsHeader = p, "xlsx" !== a)
                t.unshift(l);
              else {
                t.splice(m - 1, 0, l);
                const a2 = {};
                for (let t2 = 0; t2 < m; t2++)
                  for (let o2 = 0; o2 < e2; o2++) {
                    const e3 = p[t2][o2];
                    if (a2[e3]) {
                      const l2 = a2[e3].to;
                      if (t2 - l2[0] > 1 || o2 - l2[1] > 1) {
                        a2[e3 + Math.random().toString(36)] = a2[e3], a2[e3] = { from: [t2, o2], to: [t2, o2] };
                        continue;
                      }
                      a2[e3].to = [t2, o2];
                    } else
                      a2[e3] = { from: [t2, o2] }, a2[e3].to = a2[e3].from;
                  }
                o.complexHeaderMergeInfo = a2;
              }
            } else
              t.unshift(l);
          }
          processHierarchicalData(e, t) {
            const a = this, o = "xlsx" !== t ? +a.exportHeader : a.xlsxStartIndex, l = {}, r = [];
            let n = 0, s = false;
            if (void 0 === e[o]._keyDataField)
              return a.processNestedData(e, t, o);
            for (let t2 = o; t2 < e.length; t2++) {
              const a2 = Object.assign({}, e[t2]);
              let o2 = a2._parentDataField;
              void 0 === o2 && (o2 = null), void 0 === l[o2] ? l[o2] = [a2] : l[o2].push(a2);
            }
            if (o)
              for (let a2 = 0; a2 < o; a2++)
                r.push(Object.assign({}, e[a2])), -1 === ["json", "pdf", "xml"].indexOf(t) && (r[a2]._level = 1);
            return "json" !== t && "xml" !== t ? function e2(t2, a2, o2) {
              const i = l[t2];
              if (n = Math.max(n, a2), void 0 !== i)
                for (let t3 = 0; t3 < i.length; t3++) {
                  const n2 = i[t3], c = n2._keyDataField;
                  n2._collapsed = o2, n2._level = a2, r.push(n2), l[c] && (s = true, n2._expanded = void 0 === n2._expanded || n2._expanded, e2(c, a2 + 1, o2 || !n2._expanded));
                }
            }(null, 1, false) : function e2(a2, o2, r2) {
              const i = l[a2];
              if (n = Math.max(n, o2), void 0 !== i)
                for (let a3 = 0; a3 < i.length; a3++) {
                  const n2 = i[a3], c = n2._keyDataField;
                  let p;
                  if ("json" === t) {
                    p = {};
                    for (let e3 in n2)
                      Object.prototype.hasOwnProperty.call(n2, e3) && "_" !== e3.charAt(0) && (p[e3] = n2[e3]);
                  } else
                    p = Object.assign({}, n2);
                  r2.push(p), l[c] && (s = true, p.rows = [], e2(c, o2 + 1, p.rows));
                }
            }(null, 1, r), s || (a.actualHierarchy = false), a.maxLevel = n, r;
          }
          processNestedData(e, t, a) {
            const o = this, l = [];
            let r = 0, n = false;
            if (a)
              for (let o2 = 0; o2 < a; o2++)
                l.push(Object.assign({}, e[o2])), -1 === ["json", "pdf", "xml"].indexOf(t) && (l[o2]._level = 1);
            return "json" !== t && "xml" !== t ? function e2(t2, a2, o2, s) {
              r = Math.max(r, o2);
              for (let r2 = t2; r2 < a2.length; r2++) {
                const t3 = Object.assign({}, a2[r2]);
                t3._collapsed = s, t3._level = o2, l.push(t3), t3.children && t3.children.length > 0 && (n = true, t3._expanded = void 0 === t3._expanded || t3._expanded, e2(0, t3.children, o2 + 1, s || !t3._expanded)), delete t3.children;
              }
            }(a, e, 1, false) : function e2(t2, a2, o2, s) {
              r = Math.max(r, s);
              for (let r2 = t2; r2 < a2.length; r2++) {
                const t3 = Object.assign({}, a2[r2]);
                1 === s ? l[r2] = t3 : o2[r2] = t3, t3.children && t3.children.length > 0 && (n = true, t3.rows = [], e2(0, t3.children, t3.rows, s + 1)), delete t3.children;
              }
            }(a, e, void 0, 1), n || (o.actualHierarchy = false), o.maxLevel = r, l;
          }
          processRowStyle(e) {
            const t = this, a = e.rows;
            if (t.rowHeight = [], !a)
              return;
            const o = t.xlsxStartIndex;
            function l(e2, a2, l2) {
              for (let r = 0; r < t.columnsArray.length; r++) {
                const n = t.columnsArray[r] + (e2 + 1 + o);
                t.storeCellStyle(n, a2, l2);
              }
            }
            a.height && (t.defaultRowHeight = ` ht="${parseFloat(a.height) / 2}"`);
            for (let e2 = o; e2 < t.data.length; e2++) {
              const r = e2 - o;
              for (let e3 in a)
                Object.prototype.hasOwnProperty.call(a, e3) && -1 === e3.indexOf("alt") && isNaN(e3) && "height" !== e3 && l(r, e3, a[e3]);
              if (a.alternationCount && ((void 0 === a.alternationStart || r >= a.alternationStart) && (void 0 === a.alternationEnd || r <= a.alternationEnd) || a.alternationStart === a.alternationEnd)) {
                const e3 = (r - (a.alternationStart || 0)) % a.alternationCount;
                a[`alternationIndex${e3}Color`] && l(r, "color", a[`alternationIndex${e3}Color`]), a[`alternationIndex${e3}BorderColor`] && l(r, "borderColor", a[`alternationIndex${e3}BorderColor`]), a[`alternationIndex${e3}BackgroundColor`] && l(r, "backgroundColor", a[`alternationIndex${e3}BackgroundColor`]);
              }
              if (a[r]) {
                for (let o2 in a[r])
                  if (Object.prototype.hasOwnProperty.call(a[r], o2)) {
                    if ("height" === o2) {
                      t.rowHeight[e2] = ` ht="${parseFloat(a[r].height) / 2}"`;
                      continue;
                    }
                    l(r, o2, a[r][o2]);
                  }
              }
            }
          }
          storeCellStyle(e, t, a) {
            const o = this.styleMap[e];
            switch (t) {
              case "backgroundColor":
                o.fills.fgColor = a;
                break;
              case "color":
                o.fonts.color = a;
                break;
              case "fontFamily":
                o.fonts.name = a.replace(/"/g, "'");
                break;
              case "fontSize":
                o.fonts.sz = parseFloat(a);
                break;
              case "fontStyle":
                "italic" === a ? o.fonts.i = true : delete o.fonts.i;
                break;
              case "fontWeight":
                "bold" === a ? o.fonts.b = true : delete o.fonts.b;
                break;
              case "numFmt":
                o.numFmt = a;
                break;
              case "textAlign":
                o.alignment.horizontal = a;
                break;
              case "textDecoration":
                "underline" === a ? o.fonts.u = true : delete o.fonts.u;
                break;
              case "verticalAlign":
                "middle" === a && (a = "center"), o.alignment.vertical = a;
            }
          }
          toARGB(e) {
            e = e.replace(/\s/g, "");
            const t = /rgb\((\d+),(\d+),(\d+)\)/gi.exec(e);
            if (null !== t) {
              const e2 = parseFloat(t[1]).toString(16).toUpperCase(), a2 = parseFloat(t[2]).toString(16).toUpperCase(), o2 = parseFloat(t[3]).toString(16).toUpperCase();
              return "FF" + "0".repeat(2 - e2.length) + e2 + "0".repeat(2 - a2.length) + a2 + "0".repeat(2 - o2.length) + o2;
            }
            const a = /rgba\((\d+),(\d+),(\d+)\,(\d*.\d+|\d+)\)/gi.exec(e);
            if (null !== a) {
              const e2 = Math.round(255 * parseFloat(a[4])).toString(16).toUpperCase(), t2 = parseFloat(a[1]).toString(16).toUpperCase(), o2 = parseFloat(a[2]).toString(16).toUpperCase(), l = parseFloat(a[3]).toString(16).toUpperCase();
              return "0".repeat(2 - e2.length) + e2 + "0".repeat(2 - t2.length) + t2 + "0".repeat(2 - o2.length) + o2 + "0".repeat(2 - l.length) + l;
            }
            const o = /^#(.)(.)(.)$/gi.exec(e);
            if (null !== o) {
              const e2 = o[1].toUpperCase(), t2 = o[2].toUpperCase(), a2 = o[3].toUpperCase();
              return "FF" + e2 + e2 + t2 + t2 + a2 + a2;
            }
            return "FF" + e.toUpperCase().slice(1);
          }
          toggleableFunctionality() {
            const e = this;
            return e.actualHierarchy ? `
    <style type="text/css">
        .toggle-element {
            width: 5px;
            height: 1px;
            padding-right: 5px;
            float: left;
            text-align: right;
            cursor: pointer;
            user-select: none;
        }

        .collapsed {
            display: none;
        }
    </style>
    <script type="text/javascript">
        window.onload = function () {
            var expandChar = '${e.expandChar}',
                collapseChar = '${e.collapseChar}',
                toggleElements = document.getElementsByClassName('toggle-element');

            function getParent(child) {
                var prevSibling = child.previousElementSibling;

                while (prevSibling) {
                    if (child.getAttribute('level') > prevSibling.getAttribute('level')) {
                        return prevSibling;
                    }

                    prevSibling = prevSibling.previousElementSibling;
                }

            }

            function getFirstCollapsedAncestor(child) {
                var parent = getParent(child);

                while (parent) {
                    if (parent.firstElementChild.firstElementChild.innerHTML === expandChar) {
                        return parent;
                    }

                    parent = getParent(parent);
                }
            }

            for (var i = 0; i < toggleElements.length; i++) {
                toggleElements[i].addEventListener('click', function (event) {
                    var expanded = this.innerHTML === collapseChar,
                        row = this.parentElement.parentElement,
                        sibling = row.nextElementSibling;

                    if (expanded) {
                        this.innerHTML = expandChar;
                    }
                    else {
                        this.innerHTML = collapseChar;
                    }

                    while (sibling && row.getAttribute('level') < sibling.getAttribute('level')) {
                        if (expanded) {
                            sibling.style.display = 'none';
                        }
                        else {
                            var firstCollapsedAncestor = getFirstCollapsedAncestor(sibling);

                            if (!firstCollapsedAncestor || firstCollapsedAncestor === row) {
                                sibling.classList.remove('collapsed');
                                sibling.style.display = null;
                            }

                        }

                        sibling = sibling.nextElementSibling;
                    }
                });
            }
        }
    <\/script>` : "";
          }
          generateStyles(e) {
            const t = this;
            if (t.cellStyleMapping = {}, 0 === Object.keys(e).length && !t.complexHeader)
              return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2 xr" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision"><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><charset val="204"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/></cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>${t.conditionalFormattingXLSX.styles || '<dxfs count="0"/>'}<tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>`;
            t.styleMap = {};
            for (let e2 = 0; e2 < t.data.length; e2++)
              for (let a2 = 0; a2 < t.columnsArray.length; a2++)
                t.styleMap[t.columnsArray[a2] + (e2 + 1)] = { numFmts: {}, fonts: {}, fills: {}, borders: {}, alignment: {} };
            if (e && e.columns)
              for (let a2 = 0; a2 < t.columnsArray.length; a2++) {
                const o2 = t.datafields[a2];
                if (!e.columns[o2] || !e.columns[o2].format)
                  continue;
                const l2 = t.getXLSXFormat(e.columns[o2].format, t.data[1][o2]), r2 = t.getXLSXFormat(e.columns[o2].format, t.data[t.data.length - 1][o2]);
                if (r2)
                  e.columns[o2].numFmt = r2;
                else if (l2)
                  e.columns[o2].numFmt = l2;
                else if (e.columns[o2].format && o2.toLowerCase().indexOf("date") >= 0) {
                  let t2 = e.columns[o2].format;
                  switch (t2) {
                    case "d":
                      t2 = "m/d/yyyy";
                      break;
                    case "D":
                      t2 = "nnnnmmmm dd, yyyy";
                      break;
                    case "t":
                      t2 = "h:m AM/PM";
                      break;
                    case "T":
                      t2 = "h:mm:ss AM/PM";
                      break;
                    case "f":
                      t2 = "nnnnmmmm dd, yyyy h:m AM/PM";
                      break;
                    case "F":
                      t2 = "nnnnmmmm dd, yyyy h:mm:ss AM/PM";
                      break;
                    case "M":
                      t2 = "mmmm d";
                      break;
                    case "Y":
                      t2 = "yyyy mmmm";
                      break;
                    case "FP":
                    case "PP":
                      t2 = "yyyy-mm-dd hh:mm:ss";
                      break;
                    case "FT":
                    case "PT":
                      t2 = "hh:mm:ss";
                  }
                  t2 = t2.replace(/f|u|n|p|e|a|x|o/gi, ""), t2 = t2.replace(/tt/gi, "AM/PM"), t2 = t2.replace(/:{2,}|:\s|:$|\.$/g, ""), t2 = t2.trim(), e.columns[o2].numFmt = t2;
                }
              }
            t.processRowStyle(e), t.processColumnStyle(e);
            const a = {};
            for (let e2 = 0; e2 < t.complexHeaderMergedCells.length; e2++) {
              const o2 = t.complexHeaderMergedCells[e2];
              parseFloat(o2.to[1]) !== t.complexHeader.length ? (t.styleMap[o2.from].alignment.horizontal = "center", t.styleMap[o2.from].alignment.vertical = "center") : a[o2.to] = o2.from;
            }
            const o = { xml: '<font><sz val="11" /><color theme="1" /><name val="Calibri" /><family val="2" /><charset val="204" /><scheme val="minor" /></font>', collection: ["default"] }, l = { xml: '<fill><patternFill patternType="none" /></fill><fill><patternFill patternType="gray125" /></fill>', collection: ["default", "gray125"] }, r = { xml: "", collection: [] }, n = { xml: '<xf fontId="0" fillId="0" borderId="1"/>', collection: ["default"] };
            for (let e2 = 0; e2 < t.data.length; e2++)
              for (let s = 0; s < t.columnsArray.length; s++) {
                const i = t.columnsArray[s] + (e2 + 1), c = t.styleMap[i];
                let p = "", m = "", f = "", d = [], h = [], g = [], u = [];
                for (let e3 in c.fonts)
                  if (Object.prototype.hasOwnProperty.call(c.fonts, e3)) {
                    const a2 = c.fonts[e3];
                    switch (e3) {
                      case "color":
                        d[0] = a2, p += `<color rgb="${t.toARGB(a2)}" />`;
                        break;
                      case "name":
                        d[1] = a2, p += `<name val="${a2}" />`;
                        break;
                      case "sz":
                        d[2] = a2, p += `<sz val="${a2}" />`;
                        break;
                      case "i":
                        d[3] = a2, p += "<i />";
                        break;
                      case "b":
                        d[4] = a2, p += "<b />";
                        break;
                      case "u":
                        d[5] = a2, p += "<u />";
                    }
                  }
                for (let e3 in c.fills)
                  if (Object.prototype.hasOwnProperty.call(c.fills, e3)) {
                    const a2 = c.fills[e3];
                    switch (e3) {
                      case "fgColor":
                        h[0] = a2, m += `<fgColor rgb="${t.toARGB(a2)}" />`;
                    }
                  }
                for (let e3 in c.alignment)
                  if (Object.prototype.hasOwnProperty.call(c.alignment, e3)) {
                    const t2 = c.alignment[e3];
                    switch (e3) {
                      case "horizontal":
                        g[0] = t2, f += `horizontal="${t2}" `;
                        break;
                      case "vertical":
                        g[1] = t2, f += `vertical="${t2}" `;
                    }
                  }
                if (d = d.toString(), h = h.toString(), "" !== p) {
                  let e3 = o.collection.indexOf(d);
                  -1 === e3 && (e3 = o.collection.length, o.xml += "<font>" + p + "</font>", o.collection.push(d)), u[0] = e3;
                }
                if ("" !== m) {
                  let e3 = l.collection.indexOf(h);
                  -1 === e3 && (e3 = l.collection.length, l.xml += '<fill><patternFill patternType="solid">' + m + "</patternFill></fill>", l.collection.push(h)), u[1] = e3;
                }
                g.length > 0 && (u[2] = f), void 0 !== c.numFmt && (u[3] = t.getNumFmtIndex(c.numFmt, r));
                const y = u.toString();
                if ("" !== y) {
                  let e3 = n.collection.indexOf(y);
                  if (-1 === e3) {
                    let t2 = "<xf ";
                    e3 = n.collection.length, void 0 !== u[0] && (t2 += `fontId="${u[0]}" `), void 0 !== u[1] && (t2 += `fillId="${u[1]}" `), void 0 !== u[3] && (t2 += `numFmtId="${u[3]}" `), void 0 !== u[2] ? t2 += `applyAlignment="1" borderId="1"><alignment ${f}/></xf>` : t2 += ' borderId="1"/>', n.xml += t2, n.collection.push(y);
                  }
                  t.cellStyleMapping[a[i] || i] = e3;
                }
              }
            return r.collection.length && (r.xml = `<numFmts count="${r.collection.length}">${r.xml}</numFmts>`), `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2 xr" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision">${r.xml}<fonts count="${o.collection.length}" x14ac:knownFonts="1">${o.xml}</fonts><fills count="${l.collection.length}">${l.xml}</fills><borders count="2"><border><left/><right/><top/><bottom/></border><border><left style="hair"/><right style="hair"/><top style="hair"/><bottom style="hair"/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="${n.collection.length}">${n.xml}</cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>${t.conditionalFormattingXLSX.styles}<dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>`;
          }
        });
      }
    ),
    /***/
    9135: (
      /***/
      () => {
        Smart("smart-scroll-bar", class extends Smart.BaseElement {
          static get properties() {
            return { clickRepeatDelay: { type: "integer", value: 50 }, largeStep: { type: "integer", value: 100 }, min: { type: "integer", value: 0 }, max: { type: "integer", value: 1e3 }, mechanicalAction: { value: "switchWhileDragging", allowedValues: ["switchUntilReleased", "switchWhenReleased", "switchWhileDragging"], type: "string" }, orientation: { type: "string", value: "horizontal", allowedValues: ["horizontal", "vertical"] }, step: { type: "integer", value: 10 }, showButtons: { type: "boolean", value: true, defaultReflectToAttribute: true }, value: { type: "integer", value: 0 } };
          }
          static get styleUrls() {
            return ["smart.scrollbar.css"];
          }
          template() {
            return '<div id="container" class="smart-container" role="presentation">\n                    <div id="nearButton" class="smart-scroll-button smart-arrow-left" role="presentation" aria-hidden="true"></div>\n                    <div  id="track" class="smart-track" role="presentation">\n                        <div id="thumb" class="smart-thumb" role="presentation"></div>\n                    </div>\n                    <div id="farButton" class="smart-scroll-button smart-arrow-right" role="presentation" aria-hidden="true"></div>\n            </div>';
          }
          static get listeners() {
            return { "nearButton.click": "_nearButtonClickHandler", "nearButton.down": "_startRepeat", "nearButton.up": "_stopRepeat", "nearButton.pointerenter": "_updateInBoundsFlag", "nearButton.pointerleave": "_updateInBoundsFlag", "farButton.click": "_farButtonClickHandler", "farButton.down": "_startRepeat", "farButton.up": "_stopRepeat", "farButton.pointerenter": "_updateInBoundsFlag", "farButton.pointerleave": "_updateInBoundsFlag", "track.down": "_trackDownHandler", "track.click": "_trackClickHandler", "track.move": "_trackMoveHandler", "thumb.down": "_dragStartHandler", "document.move": "_dragHandler", "document.up": "_dragEndHandler", up: "_dragEndHandler", "document.selectstart": "_selectStartHandler", resize: "_resizeHandler" };
          }
          _updateInBoundsFlag(t) {
            const e = this, a = t.target;
            a._isPointerInBounds = true, -1 !== t.type.indexOf("leave") && (a._isPointerInBounds = false), 1 !== ("buttons" in t ? t.buttons : t.which) && e._stopRepeat(t);
          }
          _startRepeat(t) {
            const e = this;
            if (e.disabled)
              return;
            const a = t.target;
            a._initialTimer || (a._initialTimer = setTimeout(function() {
              a._repeatTimer = setInterval(() => {
                if (a._isPointerInBounds) {
                  const e2 = "buttons" in t ? t.buttons : t.which;
                  a.$.fireEvent("click", { buttons: e2, clientX: t.clientX, clientY: t.clientY, pageX: t.pageX, pageY: t.pageY, screenX: t.screenX, screenY: t.screenY });
                }
              }, e.clickRepeatDelay);
            }, 3 * e.clickRepeatDelay));
          }
          _stopRepeat(t) {
            if (this.disabled)
              return;
            const e = t.target;
            e._repeatTimer && (clearInterval(e._repeatTimer), e._repeatTimer = null), e._initialTimer && (clearTimeout(e._initialTimer), e._initialTimer = null);
          }
          _calculateThumbSize(t) {
            const e = this, a = e.max - e.min, r = "horizontal" === e.orientation ? e.$.track.offsetWidth > 10 : e.$.track.offsetHeight > 10;
            let n = 0;
            return a >= 1 && r ? (n = t / (a + t) * t, e.$.thumb.className.indexOf("smart-hidden") >= 0 && e.$thumb.removeClass("smart-hidden")) : e.$thumb.addClass("smart-hidden"), Math.max(10, Math.min(n, t));
          }
          _dragStartHandler(t) {
            const e = this;
            e.disabled || (e.thumbCapture = true, e.dragStartX = t.clientX, e.dragStartY = t.clientY, e.dragStartValue = e.value, t.stopPropagation(), t.preventDefault());
          }
          _dragHandler(t) {
            const e = this;
            if (true !== e.thumbCapture)
              return;
            e._isThumbDragged = true;
            const a = (e.max - e.min) / (e.scrollBarSize - e.thumbSize), r = "horizontal" === e.orientation ? (t.clientX - e.dragStartX) * a : (t.clientY - e.dragStartY) * a;
            let n = r;
            e.rightToLeft && "horizontal" === e.orientation && (n = -r), e._updateValue(e.dragStartValue + n), t.stopPropagation(), t.preventDefault(), t.originalEvent && (t.originalEvent.stopPropagation(), t.originalEvent.preventDefault());
          }
          _dragEndHandler(t) {
            const e = this;
            e._trackDownTimer && (clearInterval(e._trackDownTimer), e._trackDownTimer = null), e.thumbCapture && (e.thumbCapture = false, e._isThumbDragged = false, "switchWhenReleased" === e.mechanicalAction ? e._updateValue(e.dragStartValue, e.value) : "switchUntilReleased" === this.mechanicalAction && e._updateValue(e.dragStartValue), t.preventDefault(), t.stopPropagation(), t.originalEvent.preventDefault(), t.originalEvent.stopPropagation());
          }
          _farButtonClickHandler() {
            const t = this;
            if (t.disabled)
              return;
            const e = t.value;
            t._updateValue(t.value + ("horizontal" === t.orientation && t.rightToLeft ? -1 : 1) * t.step), "switchUntilReleased" === t.mechanicalAction && t._updateValue(e);
          }
          _nearButtonClickHandler() {
            const t = this;
            if (t.disabled)
              return;
            const e = t.value;
            t._updateValue(t.value - ("horizontal" === t.orientation && t.rightToLeft ? -1 : 1) * t.step), "switchUntilReleased" === t.mechanicalAction && t._updateValue(e);
          }
          propertyChangedHandler(t, e, a) {
            super.propertyChangedHandler(t, e, a);
            const r = this;
            switch (t) {
              case "min":
              case "max":
              case "orientation":
              case "showButtons":
                r._layout(), "min" === t ? r.setAttribute("aria-valuemin", a) : "max" === t ? r.setAttribute("aria-valuemax", a) : "orientation" === t && r.setAttribute("aria-orientation", a);
                break;
              case "value":
                r._updateValue(e, a);
                break;
              default:
                r._layout();
            }
          }
          render() {
            const t = this;
            t.setAttribute("role", "scrollbar"), t.setAttribute("aria-orientation", t.orientation), t.setAttribute("aria-valuemin", t.min), t.setAttribute("aria-valuemax", t.max), t.setAttribute("aria-valuenow", t.value), t._layout(), super.render();
          }
          _resizeHandler() {
            this._layout();
          }
          refresh() {
            this._layout();
          }
          beginUpdate() {
            this._isUpdating = true;
          }
          endUpdate() {
            this._isUpdating = false, this.refreshValue();
          }
          refreshValue() {
            const t = this;
            t._layout(), t._updateValue(t.value);
          }
          _layout() {
            const t = this;
            t._isUpdating || (t.scrollBarSize = "horizontal" === t.orientation ? t.$.track.offsetWidth : t.$.track.offsetHeight, t.thumbSize = t._calculateThumbSize(t.scrollBarSize), "horizontal" === t.orientation && t.$.thumb.style.width !== t.thumbSize + "px" ? t.$.thumb.style.width = t.thumbSize + "px" : "vertical" === t.orientation && t.$.thumb.style.height !== t.thumbSize + "px" && (t.$.thumb.style.height = t.thumbSize + "px"), "horizontal" === t.orientation ? (t.$.nearButton.classList.contains("smart-arrow-up") && t.$.nearButton.classList.remove("smart-arrow-up"), t.$.farButton.classList.contains("smart-arrow-down") && t.$.farButton.classList.remove("smart-arrow-down"), t.$.nearButton.classList.contains("smart-arrow-left") || t.$.nearButton.classList.add("smart-arrow-left"), t.$.farButton.classList.contains("smart-arrow-right") || t.$.farButton.classList.add("smart-arrow-right")) : (t.$.nearButton.classList.contains("smart-arrow-left") && t.$.nearButton.classList.remove("smart-arrow-left"), t.$.farButton.classList.contains("smart-arrow-right") && t.$.farButton.classList.remove("smart-arrow-right"), t.$.nearButton.classList.contains("smart-arrow-up") || t.$.nearButton.classList.add("smart-arrow-up"), t.$.farButton.classList.contains("smart-arrow-down") || t.$.farButton.classList.add("smart-arrow-down")), t._updateThumbPosition(), (t.value > t.max || t.value < t.min) && t._updateValue(t.value, t.value > t.max ? t.max : t.min));
          }
          _selectStartHandler(t) {
            this.thumbCapture && t.preventDefault();
          }
          _trackDownHandler(t) {
            const e = this;
            t.target === e.$.track && (e._trackDownTimer && clearInterval(e._trackDownTimer), e.thumbCapture || (e._trackDownTimer = setInterval(function() {
              e._trackClickHandler(t);
            }, e.clickRepeatDelay), t.stopPropagation(), t.preventDefault()));
          }
          _trackClickHandler(t) {
            const e = this;
            if (e.disabled)
              return;
            if (e._isThumbDragged)
              return clearInterval(e._trackDownTimer), void (e._trackDownTimer = null);
            const a = e.$.thumb.getBoundingClientRect(), r = t.pageX - window.pageXOffset, n = t.pageY - window.pageYOffset, i = (e.rightToLeft ? -1 : 1) * e.value;
            "horizontal" === e.orientation ? r > (e._isThumbDragged ? e.dragStartX : a.right) ? e._updateValue(e.value + (e.rightToLeft ? -1 : 1) * e.largeStep) : r < (e._isThumbDragged ? e.dragStartX : a.left) && e._updateValue(e.value - (e.rightToLeft ? -1 : 1) * e.largeStep) : n > (e._isThumbDragged ? e.dragStartY : a.bottom) ? e._updateValue(e.value + e.largeStep) : n < (e._isThumbDragged ? e.dragStartY : a.top) && e._updateValue(e.value - e.largeStep), "switchUntilReleased" === e.mechanicalAction && e._updateValue(i);
          }
          _trackMoveHandler(t) {
            "touchmove" === t.originalEvent.type && t.originalEvent.preventDefault();
          }
          _updateValue(t, e) {
            const a = this;
            if (!a._isUpdating && (1 === arguments.length && (e = t, t = a.value), (void 0 === e || isNaN(e)) && (e = a.min), e > a.max && (e = a.max), e < a.min && (e = a.min), a.value = e, t !== e)) {
              if (a.setAttribute("aria-valuenow", e), a._updateThumbPosition(), a.thumbCapture && "switchWhenReleased" === a.mechanicalAction)
                return;
              if (a.onChange)
                return void a.onChange({ value: a.value, oldValue: t, min: a.min, max: a.max, context: a });
              a.$.fireEvent("change", { value: a.value, oldValue: t, min: a.min, max: a.max });
            }
          }
          _updateThumbPosition() {
            const t = this, e = "horizontal" === t.orientation ? t.$.track.offsetWidth : t.$.track.offsetHeight, a = t._calculateThumbSize(e), r = e - a;
            let n = (e - a) / (t.max - t.min) * (t.value - t.min);
            t.rightToLeft && "horizontal" === t.orientation && (n = (e - a) / (t.max - t.min) * (t.max - t.value - t.min)), n = Math.min(r, Math.max(0, n)), "vertical" === t.orientation && t.$.thumb.style.top !== n + "px" ? t.$.thumb.style.top = n + "px" : "horizontal" === t.orientation && t.$.thumb.style.left !== n + "px" && (t.$.thumb.style.left = n + "px");
          }
        });
      }
    )
    /******/
  };
  var __webpack_module_cache__ = {};
  function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== void 0) {
      return cachedModule.exports;
    }
    var module = __webpack_module_cache__[moduleId] = {
      /******/
      // no module.id needed
      /******/
      // no module.loaded needed
      /******/
      exports: {}
      /******/
    };
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    return module.exports;
  }
  (() => {
    __webpack_require__.n = (module) => {
      var getter = module && module.__esModule ? (
        /******/
        () => module["default"]
      ) : (
        /******/
        () => module
      );
      __webpack_require__.d(getter, { a: getter });
      return getter;
    };
  })();
  (() => {
    __webpack_require__.d = (exports, definition) => {
      for (var key in definition) {
        if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
          Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
        }
      }
    };
  })();
  (() => {
    __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
  })();
  var __webpack_exports__ = {};
  (() => {
    "use strict";
    var _smart_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6321);
    var _smart_element_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_smart_element_js__WEBPACK_IMPORTED_MODULE_0__);
    var _smart_button_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2612);
    var _smart_button_js__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_smart_button_js__WEBPACK_IMPORTED_MODULE_1__);
    var _smart_scrollbar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9135);
    var _smart_scrollbar_js__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_smart_scrollbar_js__WEBPACK_IMPORTED_MODULE_2__);
    var _smart_data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6057);
    var _smart_data_js__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_smart_data_js__WEBPACK_IMPORTED_MODULE_3__);
    var _smart_draw_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9613);
    var _smart_draw_js__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_smart_draw_js__WEBPACK_IMPORTED_MODULE_4__);
    var _smart_chart_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7799);
    var _smart_chart_core_js__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_smart_chart_core_js__WEBPACK_IMPORTED_MODULE_5__);
    var _smart_chart_rangeselector_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2157);
    var _smart_chart_rangeselector_js__WEBPACK_IMPORTED_MODULE_6___default = __webpack_require__.n(_smart_chart_rangeselector_js__WEBPACK_IMPORTED_MODULE_6__);
    var _smart_chart_api_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7177);
    var _smart_chart_api_js__WEBPACK_IMPORTED_MODULE_7___default = __webpack_require__.n(_smart_chart_api_js__WEBPACK_IMPORTED_MODULE_7__);
    var _smart_chart_waterfall_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6541);
    var _smart_chart_waterfall_js__WEBPACK_IMPORTED_MODULE_8___default = __webpack_require__.n(_smart_chart_waterfall_js__WEBPACK_IMPORTED_MODULE_8__);
    var _smart_chart_annotations_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(8243);
    var _smart_chart_annotations_js__WEBPACK_IMPORTED_MODULE_9___default = __webpack_require__.n(_smart_chart_annotations_js__WEBPACK_IMPORTED_MODULE_9__);
    var _smart_export_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(6802);
    var _smart_export_js__WEBPACK_IMPORTED_MODULE_10___default = __webpack_require__.n(_smart_export_js__WEBPACK_IMPORTED_MODULE_10__);
    class smartChart extends Smart.Component {
      get name() {
        return "smartChart";
      }
    }
    class smartDataAdapter extends Smart.DataAdapter {
    }
  })();
})();

// node_modules/smart-webcomponents-react/chart/chart.esm.js
var import_react = __toESM(require_react());
if (!window["Smart"]) {
  window["Smart"] = { RenderMode: "manual" };
} else {
  window["Smart"].RenderMode = "manual";
}
var Smart2 = window.Smart;
var Chart = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.componentRef = import_react.default.createRef();
  }
  // Gets the id of the React component.
  get id() {
    if (!this._id) {
      this._id = "Chart" + Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
    }
    return this._id;
  }
  /** Sets or gets the animation mode. Animation is disabled when the property is set to 'none'.
  *	Property type: Animation | string
  */
  get animation() {
    return this.nativeElement ? this.nativeElement.animation : void 0;
  }
  set animation(value) {
    if (this.nativeElement) {
      this.nativeElement.animation = value;
    }
  }
  /** Determines the animation duration in milliseconds. The value must be between 0 and 5000. If it is outside of this range jqxChart will reset it to the default value.
  *	Property type: number
  */
  get animationDuration() {
    return this.nativeElement ? this.nativeElement.animationDuration : void 0;
  }
  set animationDuration(value) {
    if (this.nativeElement) {
      this.nativeElement.animationDuration = value;
    }
  }
  /** Sets the chart's background color. For example: '#DDFFE8'
  *	Property type: string | null
  */
  get backgroundColor() {
    return this.nativeElement ? this.nativeElement.backgroundColor : void 0;
  }
  set backgroundColor(value) {
    if (this.nativeElement) {
      this.nativeElement.backgroundColor = value;
    }
  }
  /** Sets the chart's background image. For example: 'https://www.htmlelements.com/demos/images/carousel-large-1.jpg'
  *	Property type: string
  */
  get backgroundImage() {
    return this.nativeElement ? this.nativeElement.backgroundImage : void 0;
  }
  set backgroundImage(value) {
    if (this.nativeElement) {
      this.nativeElement.backgroundImage = value;
    }
  }
  /** Sets the chart's border color. For example: '#098700'
  *	Property type: string | null
  */
  get borderLineColor() {
    return this.nativeElement ? this.nativeElement.borderLineColor : void 0;
  }
  set borderLineColor(value) {
    if (this.nativeElement) {
      this.nativeElement.borderLineColor = value;
    }
  }
  /** Sets the chart's border line width.
  *	Property type: number
  */
  get borderLineWidth() {
    return this.nativeElement ? this.nativeElement.borderLineWidth : void 0;
  }
  set borderLineWidth(value) {
    if (this.nativeElement) {
      this.nativeElement.borderLineWidth = value;
    }
  }
  /** Sets the caption (title) of the chart.
  *	Property type: string
  */
  get caption() {
    return this.nativeElement ? this.nativeElement.caption : void 0;
  }
  set caption(value) {
    if (this.nativeElement) {
      this.nativeElement.caption = value;
    }
  }
  /** Determines whether to clip plotted elements that overflow the axis boundaries.
  *	Property type: boolean
  */
  get clip() {
    return this.nativeElement ? this.nativeElement.clip : void 0;
  }
  set clip(value) {
    if (this.nativeElement) {
      this.nativeElement.clip = value;
    }
  }
  /** Sets the chart's color pallete. jqxChart suppports 32 color schemes from 'scheme01' to 'scheme32'.
  *	Property type: ChartColorScheme | string
  */
  get colorScheme() {
    return this.nativeElement ? this.nativeElement.colorScheme : void 0;
  }
  set colorScheme(value) {
    if (this.nativeElement) {
      this.nativeElement.colorScheme = value;
    }
  }
  /** Enables or disables overlapping of the column series.
  *	Property type: boolean
  */
  get columnSeriesOverlap() {
    return this.nativeElement ? this.nativeElement.columnSeriesOverlap : void 0;
  }
  set columnSeriesOverlap(value) {
    if (this.nativeElement) {
      this.nativeElement.columnSeriesOverlap = value;
    }
  }
  /** Gets or sets the color of the crosshairs lines. The 'enableCrosshairs' property should be 'true'.
  *	Property type: string | null
  */
  get crosshairsColor() {
    return this.nativeElement ? this.nativeElement.crosshairsColor : void 0;
  }
  set crosshairsColor(value) {
    if (this.nativeElement) {
      this.nativeElement.crosshairsColor = value;
    }
  }
  /** Gets or sets the dash style of the crosshairs lines. The style is a series of numbers indicating line length followed by space length. The 'enableCrosshairs' property should be 'true'. For example: '3,3'
  *	Property type: string
  */
  get crosshairsDashStyle() {
    return this.nativeElement ? this.nativeElement.crosshairsDashStyle : void 0;
  }
  set crosshairsDashStyle(value) {
    if (this.nativeElement) {
      this.nativeElement.crosshairsDashStyle = value;
    }
  }
  /** Gets or sets the width of the crosshairs lines. The 'enableCrosshairs' property should be 'true'
  *	Property type: number
  */
  get crosshairsLineWidth() {
    return this.nativeElement ? this.nativeElement.crosshairsLineWidth : void 0;
  }
  set crosshairsLineWidth(value) {
    if (this.nativeElement) {
      this.nativeElement.crosshairsLineWidth = value;
    }
  }
  /** Sets the chart's data source.
  *	Property type: any[]
  */
  get dataSource() {
    return this.nativeElement ? this.nativeElement.dataSource : void 0;
  }
  set dataSource(value) {
    if (this.nativeElement) {
      this.nativeElement.dataSource = value;
    }
  }
  /** Sets the description text of the chart.
  *	Property type: string
  */
  get description() {
    return this.nativeElement ? this.nativeElement.description : void 0;
  }
  set description(value) {
    if (this.nativeElement) {
      this.nativeElement.description = value;
    }
  }
  /** Enables or disables the chart.
  *	Property type: boolean
  */
  get disabled() {
    return this.nativeElement ? this.nativeElement.disabled : void 0;
  }
  set disabled(value) {
    if (this.nativeElement) {
      this.nativeElement.disabled = value;
    }
  }
  /** Determines the drawing function of jqxChart. When the property is set, you can override the jqxChart's drawing.
  *	Property type: any
  */
  get draw() {
    return this.nativeElement ? this.nativeElement.draw : void 0;
  }
  set draw(value) {
    if (this.nativeElement) {
      this.nativeElement.draw = value;
    }
  }
  /** Function for custom drawing before the caption and other chart elements.
  *	Property type: any
  */
  get drawBefore() {
    return this.nativeElement ? this.nativeElement.drawBefore : void 0;
  }
  set drawBefore(value) {
    if (this.nativeElement) {
      this.nativeElement.drawBefore = value;
    }
  }
  /** Determines if the animation of the axes text is enabled.
  *	Property type: boolean
  */
  get enableAxisTextAnimation() {
    return this.nativeElement ? this.nativeElement.enableAxisTextAnimation : void 0;
  }
  set enableAxisTextAnimation(value) {
    if (this.nativeElement) {
      this.nativeElement.enableAxisTextAnimation = value;
    }
  }
  /** Enables or disables the crosshairs lines. The lines are displayed in line and area series when you move over a data point.
  *	Property type: boolean
  */
  get enableCrosshairs() {
    return this.nativeElement ? this.nativeElement.enableCrosshairs : void 0;
  }
  set enableCrosshairs(value) {
    if (this.nativeElement) {
      this.nativeElement.enableCrosshairs = value;
    }
  }
  /** Determines whether to display the chart using greyscale colors.
  *	Property type: boolean
  */
  get greyScale() {
    return this.nativeElement ? this.nativeElement.greyScale : void 0;
  }
  set greyScale(value) {
    if (this.nativeElement) {
      this.nativeElement.greyScale = value;
    }
  }
  /** Sets the legend's layout.
  *	Property type: any
  */
  get legendLayout() {
    return this.nativeElement ? this.nativeElement.legendLayout : void 0;
  }
  set legendLayout(value) {
    if (this.nativeElement) {
      this.nativeElement.legendLayout = value;
    }
  }
  /** Sets or gets the locale. Used in conjunction with the property messages.
  *	Property type: string
  */
  get locale() {
    return this.nativeElement ? this.nativeElement.locale : void 0;
  }
  set locale(value) {
    if (this.nativeElement) {
      this.nativeElement.locale = value;
    }
  }
  /** Localization object containing culture-specific properties required for formatting currencies, numbers and dates.
  *	Property type: ChartLocalization
  */
  get localization() {
    return this.nativeElement ? this.nativeElement.localization : void 0;
  }
  set localization(value) {
    if (this.nativeElement) {
      this.nativeElement.localization = value;
    }
  }
  /** Sets or gets an object specifying strings used in the widget that can be localized. Used in conjunction with the property locale.
  *	Property type: any
  */
  get messages() {
    return this.nativeElement ? this.nativeElement.messages : void 0;
  }
  set messages(value) {
    if (this.nativeElement) {
      this.nativeElement.messages = value;
    }
  }
  /** Sets the left, top, right and bottom padding of the Chart.
  *	Property type: Padding
  */
  get padding() {
    return this.nativeElement ? this.nativeElement.padding : void 0;
  }
  set padding(value) {
    if (this.nativeElement) {
      this.nativeElement.padding = value;
    }
  }
  /** Determines the rendering engine used to display the chart. When the property is set to an empty string, jqxChart will automatically select an optimal rendering engine depending on the browser capabilities.
  *	Property type: ChartRenderEngine | string
  */
  get renderEngine() {
    return this.nativeElement ? this.nativeElement.renderEngine : void 0;
  }
  set renderEngine(value) {
    if (this.nativeElement) {
      this.nativeElement.renderEngine = value;
    }
  }
  /** Sets or gets a value indicating whether the Chart's layout is mirrored.
  *	Property type: boolean
  */
  get rightToLeft() {
    return this.nativeElement ? this.nativeElement.rightToLeft : void 0;
  }
  set rightToLeft(value) {
    if (this.nativeElement) {
      this.nativeElement.rightToLeft = value;
    }
  }
  /** The seriesGroups property is used to describe all series displayed on the chart. jqxChart supports multiple series of different types and series grouping. Each series group may have its own Value Axis (Y-axis) which allows you to have values with different scales displayed on the same chart at the same time. It also allows you to display multiple series types together on the same chart. For example, you can display all series in one group as lines and the series in a second group as columns. seriesGroups is an array of objects where each object represents one group.
  *	Property type: ChartSeriesGroup[]
  */
  get seriesGroups() {
    return this.nativeElement ? this.nativeElement.seriesGroups : void 0;
  }
  set seriesGroups(value) {
    if (this.nativeElement) {
      this.nativeElement.seriesGroups = value;
    }
  }
  /** Determines whether to display the chart's border line.
  *	Property type: boolean
  */
  get showBorderLine() {
    return this.nativeElement ? this.nativeElement.showBorderLine : void 0;
  }
  set showBorderLine(value) {
    if (this.nativeElement) {
      this.nativeElement.showBorderLine = value;
    }
  }
  /** Determines whether to show or hide the chart series legend.
  *	Property type: boolean
  */
  get showLegend() {
    return this.nativeElement ? this.nativeElement.showLegend : void 0;
  }
  set showLegend(value) {
    if (this.nativeElement) {
      this.nativeElement.showLegend = value;
    }
  }
  /** Enables or disables the chart tooltips.
  *	Property type: boolean
  */
  get showToolTips() {
    return this.nativeElement ? this.nativeElement.showToolTips : void 0;
  }
  set showToolTips(value) {
    if (this.nativeElement) {
      this.nativeElement.showToolTips = value;
    }
  }
  /** Determines whether to show a composite tooltip containing information for all series.
  *	Property type: boolean
  */
  get showToolTipsOnAllSeries() {
    return this.nativeElement ? this.nativeElement.showToolTipsOnAllSeries : void 0;
  }
  set showToolTipsOnAllSeries(value) {
    if (this.nativeElement) {
      this.nativeElement.showToolTipsOnAllSeries = value;
    }
  }
  /** Determines the set of default background, line, text and band colors that will be used in the Chart.
  *	Property type: string
  */
  get theme() {
    return this.nativeElement ? this.nativeElement.theme : void 0;
  }
  set theme(value) {
    if (this.nativeElement) {
      this.nativeElement.theme = value;
    }
  }
  /** Sets the padding of the chart's title (caption).
  *	Property type: Padding
  */
  get titlePadding() {
    return this.nativeElement ? this.nativeElement.titlePadding : void 0;
  }
  set titlePadding(value) {
    if (this.nativeElement) {
      this.nativeElement.titlePadding = value;
    }
  }
  /** Tooltip background color.
  *	Property type: string | null
  */
  get toolTipBackground() {
    return this.nativeElement ? this.nativeElement.toolTipBackground : void 0;
  }
  set toolTipBackground(value) {
    if (this.nativeElement) {
      this.nativeElement.toolTipBackground = value;
    }
  }
  /** Determines the tooltip hide delay in milliseconds.
  *	Property type: {(value?: any, index?: number, series?: any): string}
  */
  get toolTipFormatFunction() {
    return this.nativeElement ? this.nativeElement.toolTipFormatFunction : void 0;
  }
  set toolTipFormatFunction(value) {
    if (this.nativeElement) {
      this.nativeElement.toolTipFormatFunction = value;
    }
  }
  /** Tooltip line color.
  *	Property type: number
  */
  get toolTipHideDelay() {
    return this.nativeElement ? this.nativeElement.toolTipHideDelay : void 0;
  }
  set toolTipHideDelay(value) {
    if (this.nativeElement) {
      this.nativeElement.toolTipHideDelay = value;
    }
  }
  /** Determines the tooltip show delay in milliseconds. Values may range from 0 to 10000 [ms].
  *	Property type: string | null
  */
  get toolTipLineColor() {
    return this.nativeElement ? this.nativeElement.toolTipLineColor : void 0;
  }
  set toolTipLineColor(value) {
    if (this.nativeElement) {
      this.nativeElement.toolTipLineColor = value;
    }
  }
  /** An object with settings about the Chart's y-axis (value axis).
  *	Property type: number
  */
  get toolTipShowDelay() {
    return this.nativeElement ? this.nativeElement.toolTipShowDelay : void 0;
  }
  set toolTipShowDelay(value) {
    if (this.nativeElement) {
      this.nativeElement.toolTipShowDelay = value;
    }
  }
  /** Sets the Chart's xAxis.
  *	Property type: ChartValueAxis
  */
  get valueAxis() {
    return this.nativeElement ? this.nativeElement.valueAxis : void 0;
  }
  set valueAxis(value) {
    if (this.nativeElement) {
      this.nativeElement.valueAxis = value;
    }
  }
  /** undefined
  *	Property type: ChartXAxis
  */
  get xAxis() {
    return this.nativeElement ? this.nativeElement.xAxis : void 0;
  }
  set xAxis(value) {
    if (this.nativeElement) {
      this.nativeElement.xAxis = value;
    }
  }
  // Gets the properties of the React component.
  get properties() {
    return ["animation", "animationDuration", "backgroundColor", "backgroundImage", "borderLineColor", "borderLineWidth", "caption", "clip", "colorScheme", "columnSeriesOverlap", "crosshairsColor", "crosshairsDashStyle", "crosshairsLineWidth", "dataSource", "description", "disabled", "draw", "drawBefore", "enableAxisTextAnimation", "enableCrosshairs", "greyScale", "legendLayout", "locale", "localization", "messages", "padding", "renderEngine", "rightToLeft", "seriesGroups", "showBorderLine", "showLegend", "showToolTips", "showToolTipsOnAllSeries", "theme", "titlePadding", "toolTipBackground", "toolTipFormatFunction", "toolTipHideDelay", "toolTipLineColor", "toolTipShowDelay", "valueAxis", "xAxis"];
  }
  // Gets the events of the React component.
  get eventListeners() {
    return ["onAnnotationClick", "onAnnotationMouseenter", "onAnnotationMouseleave", "onClick", "onMouseout", "onMouseover", "onRangeSelectionChanged", "onRangeSelectionChanging", "onRefreshBegin", "onRefreshEnd", "onToggle", "onCreate", "onReady"];
  }
  /** Adds a new color sheme. If a scheme with the same name already exists, the method will update its colors.
  * @param {string} schemeName. The name of the custom color scheme.
  * @param {any[]} colorsArray. An array of color values.
  */
  addColorScheme(schemeName, colorsArray) {
    if (this.nativeElement.isRendered) {
      this.nativeElement.addColorScheme(schemeName, colorsArray);
    } else {
      this.nativeElement.whenRendered(() => {
        this.nativeElement.addColorScheme(schemeName, colorsArray);
      });
    }
  }
  /** Returns the colors of a color scheme by name. If the scheme doesn't exist the method returns undefined.
    * @param {string} schemeName. The name of the color scheme.
    * @returns {any[]}
  */
  getColorScheme(schemeName) {
    const result = this.nativeElement.getColorScheme(schemeName);
    return result;
  }
  /** Gets the rendered coordinates of a data point element.
    * @param {number} groupIndex. Series group index.
    * @param {number} serieIndex. Series index.
    * @param {number} itemIndex. Item (data point) index.
    * @returns {{ x: number, y: number, width: number, height: number, center: number, centerOffset: number, innerRadius: number, outerRadius: number, selectedRadiusChange: number, fromAngle: number, toAngle: number, radius: number }}
  */
  getItemCoord(groupIndex, serieIndex, itemIndex) {
    const result = this.nativeElement.getItemCoord(groupIndex, serieIndex, itemIndex);
    return result;
  }
  /** Gets the number of rendered items in a specific serie.
    * @param {number} groupIndex. Series group index.
    * @param {number} serieIndex. Series index.
    * @returns {number}
  */
  getItemsCount(groupIndex, serieIndex) {
    const result = this.nativeElement.getItemsCount(groupIndex, serieIndex);
    return result;
  }
  /** Gets the rendered coordinates and values of the valueAxis labels.
    * @param {number} groupIndex. Series group index.
    * @returns {any}
  */
  getValueAxisLabels(groupIndex) {
    const result = this.nativeElement.getValueAxisLabels(groupIndex);
    return result;
  }
  /** Gets the rendered rectangle coordinates of the valueAxis of specific serie group.
    * @param {number} groupIndex. Series group index.
    * @returns {DOMRect}
  */
  getValueAxisRect(groupIndex) {
    const result = this.nativeElement.getValueAxisRect(groupIndex);
    return result;
  }
  /** Gets the valueAxis (vertical axis)'s value.
    * @param {number} offset. Vertical offset.
    * @param {number} groupIndex. Series group index.
    * @returns {any}
  */
  getValueAxisValue(offset, groupIndex) {
    const result = this.nativeElement.getValueAxisValue(offset, groupIndex);
    return result;
  }
  /** Gets the rendered coordinates and values of the xAxis labels.
    * @param {number} groupIndex. Series group index.
    * @returns {any}
  */
  getXAxisLabels(groupIndex) {
    const result = this.nativeElement.getXAxisLabels(groupIndex);
    return result;
  }
  /** Gets the rendered rectangle coordinates of the x-Axis of specific serie group.
    * @param {number} groupIndex. Series group index.
    * @returns {DOMRect}
  */
  getXAxisRect(groupIndex) {
    const result = this.nativeElement.getXAxisRect(groupIndex);
    return result;
  }
  /** Gets the xAxis (horizontal axis)'s value.
    * @param {number} offset. Horizontal offset.
    * @param {number} groupIndex. Series group index.
    * @returns {any}
  */
  getXAxisValue(offset, groupIndex) {
    const result = this.nativeElement.getXAxisValue(offset, groupIndex);
    return result;
  }
  /** Hides a chart serie. The result of calling this function is same as the user unchecking the legend box of a chart serie.
  * @param {number} groupIndex. Series group index.
  * @param {number} serieIndex. Series index.
  * @param {number} itemIndex?. Item (data point) index. Applicable to pie and donut series only.
  */
  hideSerie(groupIndex, serieIndex, itemIndex) {
    if (this.nativeElement.isRendered) {
      this.nativeElement.hideSerie(groupIndex, serieIndex, itemIndex);
    } else {
      this.nativeElement.whenRendered(() => {
        this.nativeElement.hideSerie(groupIndex, serieIndex, itemIndex);
      });
    }
  }
  /** Hides the current tooltip if visible.
  * @param {number} hideDelay?. Hide delay.
  */
  hideToolTip(hideDelay) {
    if (this.nativeElement.isRendered) {
      this.nativeElement.hideToolTip(hideDelay);
    } else {
      this.nativeElement.whenRendered(() => {
        this.nativeElement.hideToolTip(hideDelay);
      });
    }
  }
  /** Prints the chart.
  */
  print() {
    if (this.nativeElement.isRendered) {
      this.nativeElement.print();
    } else {
      this.nativeElement.whenRendered(() => {
        this.nativeElement.print();
      });
    }
  }
  /** Refreshes the content of the chart element after a property or data update.
  */
  refresh() {
    if (this.nativeElement.isRendered) {
      this.nativeElement.refresh();
    } else {
      this.nativeElement.whenRendered(() => {
        this.nativeElement.refresh();
      });
    }
  }
  /** Removes an existing color scheme. If the scheme does not exist, the method has no effect.
  * @param {string} schemeName. The name of the custom color scheme.
  */
  removeColorScheme(schemeName) {
    if (this.nativeElement.isRendered) {
      this.nativeElement.removeColorScheme(schemeName);
    } else {
      this.nativeElement.whenRendered(() => {
        this.nativeElement.removeColorScheme(schemeName);
      });
    }
  }
  /** Exports the chart's content as JPEG image.
  * @param {string} fileName?. File name.
  */
  saveAsJPEG(fileName) {
    if (this.nativeElement.isRendered) {
      this.nativeElement.saveAsJPEG(fileName);
    } else {
      this.nativeElement.whenRendered(() => {
        this.nativeElement.saveAsJPEG(fileName);
      });
    }
  }
  /** Exports the chart's content as PNG image.
  * @param {string} fileName?. File name.
  */
  saveAsPNG(fileName) {
    if (this.nativeElement.isRendered) {
      this.nativeElement.saveAsPNG(fileName);
    } else {
      this.nativeElement.whenRendered(() => {
        this.nativeElement.saveAsPNG(fileName);
      });
    }
  }
  /** Exports the chart's content as PDF.
  * @param {string} fileName?. File name.
  * @param {string} pageOrientation?. PDF page orientation. <strong>Possible values:</strong> 'portrait' (default), 'landscape'.
  */
  saveAsPDF(fileName, pageOrientation) {
    if (this.nativeElement.isRendered) {
      this.nativeElement.saveAsPDF(fileName, pageOrientation);
    } else {
      this.nativeElement.whenRendered(() => {
        this.nativeElement.saveAsPDF(fileName, pageOrientation);
      });
    }
  }
  /** Shows a hidden chart serie. The result of calling this function is same as the user checking the legend box of a chart serie.
  * @param {number} groupIndex. Series group index.
  * @param {number} serieIndex. Series index.
  * @param {number} itemIndex?. Item (data point) index. Applicable to pie and donut series only.
  */
  showSerie(groupIndex, serieIndex, itemIndex) {
    if (this.nativeElement.isRendered) {
      this.nativeElement.showSerie(groupIndex, serieIndex, itemIndex);
    } else {
      this.nativeElement.whenRendered(() => {
        this.nativeElement.showSerie(groupIndex, serieIndex, itemIndex);
      });
    }
  }
  /** Shows a the tooltip for a particular data point.
  * @param {number} groupIndex. Series group index.
  * @param {number} serieIndex. Series index.
  * @param {number} itemIndex. Item (data point) index.
  * @param {number} showDelay?. Show delay.
  * @param {number} hideDelay?. Hide delay.
  */
  showToolTip(groupIndex, serieIndex, itemIndex, showDelay, hideDelay) {
    if (this.nativeElement.isRendered) {
      this.nativeElement.showToolTip(groupIndex, serieIndex, itemIndex, showDelay, hideDelay);
    } else {
      this.nativeElement.whenRendered(() => {
        this.nativeElement.showToolTip(groupIndex, serieIndex, itemIndex, showDelay, hideDelay);
      });
    }
  }
  /** Updates the values of the chart series without full refresh of the entire chart. The method should be used for animation of frequently changing values.
  */
  update() {
    if (this.nativeElement.isRendered) {
      this.nativeElement.update();
    } else {
      this.nativeElement.whenRendered(() => {
        this.nativeElement.update();
      });
    }
  }
  componentDidRender(initialize) {
    const that = this;
    const props = {};
    const events = {};
    let styles = null;
    const stringifyCircularJSON = (obj) => {
      const seen = /* @__PURE__ */ new WeakSet();
      return JSON.stringify(obj, (k, v) => {
        if (v !== null && typeof v === "object") {
          if (seen.has(v))
            return;
          seen.add(v);
        }
        if (k === "Smart") {
          return v;
        }
        return v;
      });
    };
    for (let prop in that.props) {
      if (prop === "children") {
        continue;
      }
      if (prop === "style") {
        styles = that.props[prop];
        continue;
      }
      if (prop.startsWith("on") && that.properties.indexOf(prop) === -1) {
        events[prop] = that.props[prop];
        continue;
      }
      props[prop] = that.props[prop];
    }
    if (initialize) {
      that.nativeElement = this.componentRef.current;
      if (that.nativeElement && !that.nativeElement.isCompleted) {
        that.nativeElement.reactStateProps = JSON.parse(stringifyCircularJSON(props));
      }
    }
    if (initialize && that.nativeElement && that.nativeElement.isCompleted) {
    }
    for (let prop in props) {
      if (prop === "class" || prop === "className") {
        const classNames = props[prop].trim().split(" ");
        if (that.nativeElement._classNames) {
          const oldClassNames = that.nativeElement._classNames;
          for (let className in oldClassNames) {
            if (that.nativeElement.classList.contains(oldClassNames[className]) && oldClassNames[className] !== "") {
              that.nativeElement.classList.remove(oldClassNames[className]);
            }
          }
        }
        that.nativeElement._classNames = classNames;
        for (let className in classNames) {
          if (!that.nativeElement.classList.contains(classNames[className]) && classNames[className] !== "") {
            that.nativeElement.classList.add(classNames[className]);
          }
        }
        continue;
      }
      if (props[prop] !== that.nativeElement[prop]) {
        const normalizeProp = (str) => {
          return str.replace(/-([a-z])/g, function(g) {
            return g[1].toUpperCase();
          });
        };
        if (prop === "hover" || prop === "active" || prop === "focus" || prop === "selected") {
          that.nativeElement.setAttribute(prop, "");
        }
        const normalizedProp = normalizeProp(prop);
        if (that.nativeElement[normalizedProp] === void 0) {
          that.nativeElement.setAttribute(prop, props[prop]);
        }
        if (props[prop] !== void 0) {
          if (typeof props[prop] === "object" && that.nativeElement.reactStateProps && !initialize) {
            if (stringifyCircularJSON(props[prop]) === stringifyCircularJSON(that.nativeElement.reactStateProps[normalizedProp])) {
              continue;
            }
          }
          that.nativeElement[normalizedProp] = props[prop];
        }
      }
    }
    for (let eventName in events) {
      that[eventName] = events[eventName];
      that.nativeElement[eventName.toLowerCase()] = events[eventName];
    }
    if (initialize) {
      Smart2.Render();
      if (that.onCreate) {
        that.onCreate();
      }
      that.nativeElement.whenRendered(() => {
        if (that.onReady) {
          that.onReady();
        }
      });
    }
    if (styles) {
      for (let styleName in styles) {
        that.nativeElement.style[styleName] = styles[styleName];
      }
    }
  }
  componentDidMount() {
    this.componentDidRender(true);
  }
  componentDidUpdate() {
    this.componentDidRender(false);
  }
  componentWillUnmount() {
    const that = this;
    if (!that.nativeElement) {
      return;
    }
    that.nativeElement.whenRenderedCallbacks = [];
    for (let i = 0; i < that.eventListeners.length; i++) {
      const eventName = that.eventListeners[i];
      that.nativeElement.removeEventListener(eventName.substring(2).toLowerCase(), that[eventName]);
    }
  }
  render() {
    return import_react.default.createElement("smart-chart", { ref: this.componentRef }, this.props.children);
  }
};
var chart_esm_default = Chart;
export {
  Chart,
  Smart2 as Smart,
  chart_esm_default as default
};
//# sourceMappingURL=smart-webcomponents-react_chart.js.map
